<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Rikka with Subset]]></title>
    <url>%2F2019%2F06%2F28%2FRikka-with-Subset%2F</url>
    <content type="text"><![CDATA[题目链接题意 有A_{1}到A_{n}的$n$个数字，和为m，于是我们得到了{2}^{m}个子集，每个子集都有一个和，我们现在知道了和为i的子集数量为B_{i}，计算A_{1}到A_{n}. 思路 我们可以贪心的选，举个例子，比如我们知道最小的数字一定是第一个不为$0$的A_{i}，而且它的数量是A_{i}个，那么以它们为子集会产生的贡献我们可以用组合数计算出来，每次我们看到一个新的数字，如果它还有需要的贡献我们没有算，那么就会多出这么多个i，我们再对它计算贡献加到后面去。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第五场</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rikka with Competition]]></title>
    <url>%2F2019%2F06%2F28%2FRikka-with-Competition%2F</url>
    <content type="text"><![CDATA[题目链接思路 只要所有人的差距都在k以内，所有人都会赢，否则，小的那些人一定不会赢，所以数一下差距为k以内的最大的几个人数量就可以了。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第五场</category>
      </categories>
      <tags>
        <tag>签到题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化treap]]></title>
    <url>%2F2019%2F06%2F27%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96treap%2F</url>
    <content type="text"><![CDATA[场景 我们需要修改，区间翻转，区间求值等（平衡树暗示），还要访问历史版本。 前面我们用以前的平衡树就够了，但是要想访问历史版本，就要可持久化了。 考虑各种转断腰的平衡树，我们对它们可持久化操作。 回忆一下我们以前用的可持久化线段树，我们发现它有一个特点方便了我们的可持久化思想，也就是每个点只会去记录它的儿子信息，而不会考虑父亲信息。这样我们就可以在原来基础上进行一些重用和替换。但是我们用旋转的平衡树就很难解决这个问题。 无旋treap treap = tree + heap，顾名思义，它是由一棵平衡树和一个堆构成的，每个点既有val，也有key，这棵树的中序遍历是递增的，而每个结点的key都小于（或都大于）它的儿子结点。 关键函数有两个，一个是split，一个是merge。 split 这个函数的作用主要是把一棵树按照权值或者大小分成左右两棵子树，我们只要按照原来的规则不破坏，形成的两棵子树在很大概率上都是比较平衡的。12345678910111213141516171819void split(int root, int&amp; x, int&amp; y, int val)&#123; if (!root) &#123; x = y = 0; return; &#125; if (treap[root].val &lt;= val) &#123; x = root; split(rs(root), rs(x), y, val); &#125; else &#123; y = root; split(ls(root), x, ls(y), val); &#125; pushup(root);&#125; merge merge的操作是把两棵树合并成一棵树，关键字小的在上，左右顺序在参数顺序中已经知道。12345678910111213141516171819void merge(int &amp;root, int x, int y)&#123; if (!x || !y) &#123; root = x + y; return; &#125; if (treap[x].key &lt; treap[y].key) &#123; root = x; merge(rs(root), rs(x), y); &#125; else &#123; root = y; merge(ls(root), x, ls(y)); &#125; pushup(root);&#125; others 其他的操作都是在这个基础上演变而来的，我不一一详谈，几个例子，比如我们要插入一个数，就要做两件事情。 1.找到这个数字应该在的位置。 2.插进去。 那么我们怎么做呢？我们可以将这棵树分成两棵子树，左树权值都比我们要插进去的数字小，右树都比他大。然后我们为这个新的数字新建一棵树（只有他一个根节点），现在我们只要把三棵树合并一下就好了。1234567891011void insert(int&amp; root, int val)&#123; int x = 0, y = 0, z = ++cur; treap[z].val = val; treap[z].size = 1; ls(z) = rs(z) = 0; treap[z].key = Rand(); split(root, x, y, val); merge(x, x, z); merge(root, x, y);&#125; 我们怎么删除一个数字呢，同样还是找到它的位置，然后分成三棵子树，两边的树合并一下就ok啦。123456789void del(int&amp; root, int val)&#123; int x = 0, y = 0, z = 0; split(root, x, y, val); split(x, x, z, val - 1); merge(z, ls(z), rs(z)); merge(x, x, z); merge(root, x, y);&#125; 可持久化 好了，我们现在已经有了一种能够不旋转就完成区间问题、区间翻转、前驱后继等问题的平衡树，我们的可持久化操作都要在它的基础上发展出来。我找了很久都没有找到一篇单独讲怎样把无旋treap可持久化的专门博客，后来发现之所以这样，是因为它和线段树持久化太像了，几乎一模一样，所以基本都认为你会了怎么不旋转，也就会了怎么持久化。 确实如此，treap持久化也是想线段树的套路一样，把左儿子和右儿子能复制的复制，实在复制不了的新建。 比如我们要split，我们看一下要分裂的区间是否是在当前子树的某一侧，如果是，之前去分裂那个子树，否则，说明是跨过根节点的，我们新建一个点u来代替当前的点（不改变当前点的左右儿子），要得到u的左右儿子我们再去分裂当前点的左右儿子。最后返回u。 这样每次操作会新产生log(n)个节点，很多次操作以后，我们就会产生一些“垃圾点”，因为他们不会再被找到而且还占用了内存，我们需要及时暴力重建整棵树，记录哪些点没有被使用，下次垃圾回收一下。 代码可以参考这样一道模板题。]]></content>
      <categories>
        <category>acm</category>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>可持久化treap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rikka with Sequence]]></title>
    <url>%2F2019%2F06%2F27%2FRikka-with-Sequence%2F</url>
    <content type="text"><![CDATA[题目链接题意支持序列三种操作：1.求(l,r)区间和。2.执行代码”for (int i=l;i&lt;=r;i++) A[i]=A[i-k];”3.将区间(l,r)，序列还原。 思路可持久化treap，在无旋treap的基础上发展而来，这道题算是我的第一次可持久treap吧。要注意的一个是操作二，有可能涉及到一个区间重复很多遍，我们可以用类似快速幂的操作将这个区间复制到一个目的长度。还有要及时回收多余的结点，暴力重建整棵树。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第五场</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>可持久化treap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rikka with Rock-paper-scissors]]></title>
    <url>%2F2019%2F06%2F27%2FRikka-with-Rock-paper-scissors%2F</url>
    <content type="text"><![CDATA[题目链接题意有两个人进行$n$局石头剪刀布游戏，设其中一个人赢了$a$局，另一个人赢了$b$局，$n-a-b$局平局。则分数为$gcd(a,b)$。问分数的期望。 思路ans={3}^{n} \sum_{a=0}^{n} \sum_{b=0}^{n-a} C_{n}^{a} C_{n-a}^{b} gcd(a, b).={3}^{n} \sum_{d=1}^{n} \sum_{a=0}^{n} \sum_{b=0}^{n-a} C_{n}^{a} C_{n-a}^{b} d[gcd(a,b)==d].={3}^{n} \sum_{d=1}^{n} d f(d).f(d) = \sum_{a=0}^{n} \sum_{b=0}^{n-a} C_{n}^{a} C_{n-a}^{b} [gcd(a,b) == d].F(d) = \sum_{a=0}^{n} \sum_{b=0}^{n-a} C_{n}^{a} C_{n-a}^{b} [d | gcd(a, b)].F(d) = \sum_{d | k} f(k).f(d) = \sum_{d | k} \mu( \frac{k}{d}) F(k).F(d) = \sum_{a=0}^{n} \sum_{b=0}^{n-a} C_{n}^{a} C_{n-a}^{b} [d | gcd(a,b)] [gcd(a, b) != 0].= \sum_{a=0}^{ \frac{n}{d} } \sum_{b=0}^{ \frac{n}{d} - a} C_{n}^{ad} C_{n-ad}^{bd} -1.= \sum_{a=0}^{ \frac{n}{d} } \sum_{b=0}^{ \frac{n}{d} - a} \frac{n!}{(ad)!(bd)!(n-ad-bd)!} -1.= \sum_{a=0}^{ \frac{n}{d} } \sum_{b=0}^{a} \frac{n!}{(ad - bd)!(bd)!(n-ad)!} - 1.= n! \sum_{a=0}^{ \frac{n}{d} } \frac{1}{(n - ad)! } \sum_{b=0}^{a} \frac{1}{(bd)!(ad-bd)!} - 1.= n! \sum_{a=0}^{ \frac{n}{d} } \frac{1}{(n - ad)! } (fac * fac)_{a} - 1.可以用FFT优化这个狄利克雷卷积。 ans = {3}^{n} \sum_{d=1}^{n} d f(d).= {3}^{n} \sum_{d=1}^{n} d \sum_{d | k} \mu( \frac{k}{d} ) F(k).= {3}^{n} \sum_{k=1}^{n} \sum_{d | k} d \mu( \frac{k}{d} ) F(k).= {3}^{n} \sum_{k=1}^{n} F(k) \phi(k).]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第五场</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>NTT</tag>
        <tag>Inversion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本实现对拍]]></title>
    <url>%2F2019%2F06%2F27%2Fshell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%8B%8D%2F</url>
    <content type="text"><![CDATA[每天我苦于各种找bug，总是不知道自己哪里写错了，总感觉对于所有数据应该都已经完美了。手动对拍所有数据。不停重复着三条命令：./t &gt; 1.in./a &lt; 1.in./b &lt; 1.in…… 今天我才知道，原来shell的命令脚本可以替代我完成这样枯燥的事情。我真的是愚蠢了！ 1234567891011while true; do ./t &gt; 1.in ./a &lt; 1.in &gt; a.out ./b &lt; 1.in &gt; b.out if diff a.out b.out; then printf "AC\n" else printf "WA\n" exit 0 fidone]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Classic Quotation]]></title>
    <url>%2F2019%2F06%2F26%2FClassic-Quotation%2F</url>
    <content type="text"><![CDATA[题目链接题意有串S和T，询问在S中挖去S.substr(i,j),(1 \leq i \leq L, R \leq j \leq n)后，T在其中出现的次数和。 思路题解讲的很清楚。 说的好像很好写的样子，但是除了上帝没人知道我下面的代码在干什么。挖个坑，回头把它改一改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;char s[N], t[105];int Next[105];void kmp_pre()&#123; int tlen = strlen(t); int i, j; j = Next[0] = -1; i = 0; while (i &lt; tlen) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = Next[j]; Next[++i] = ++j; &#125;&#125;ll pref[N], preg[N], suf[N][105], sum[N][105];ll l, r;int k, n, m;ll get()&#123; ll ans = (n - r) * preg[l];// dbg(n, l, r, ans); for (int i = 0; i &lt; m; i++) &#123;// dbg(i, sum[l][i], suf[r][i]); ans += sum[l][i] * suf[r][i]; &#125; return ans;&#125;void solve()&#123; kmp_pre(); int slen = strlen(s), tlen = strlen(t); int i = 0, j = 0; pref[0] = 0; preg[0] = 0; while (i &lt; slen) &#123; while (j != -1 &amp;&amp; s[i] != t[j]) j = Next[j]; j++, i++; preg[i] = preg[i - 1] + (j == tlen); if (j == tlen) j = Next[j]; pref[i] = j;// dbg(i, pref[i], preg[i]); &#125; for (int i = 0; i &lt;= slen; i++) for (int j = 0; j &lt;= tlen; j++) suf[i][j] = 0; for (int i = slen - 2; i &gt;= 0; i--) for (int j = tlen - 1; j &gt;= 0; j--) &#123; int cj = j; while (cj != -1 &amp;&amp; t[cj] != s[i + 1]) cj = Next[cj]; cj++; suf[i][j] = suf[i + 1][cj % tlen] + (cj == tlen);// dbg(i, j, suf[i][j]); &#125; for (int i = 1; i &lt; slen; i++) preg[i] += preg[i - 1]; for (int j = 0; j &lt; tlen; j++) for (int i = tlen - 2; i &gt;= 0; i--) suf[i][j] += suf[i + 1][j]; for (int i = 0; i &lt;= tlen; i++) for (int j = 0; j &lt;= slen; j++) sum[j][i] = 0; for (int i = 0; i &lt; slen; i++) sum[i + 1][pref[i]]++; for (int i = 0; i &lt; slen; i++) for (int j = 0; j &lt; tlen; j++) sum[i][j] += sum[i - 1][j]; while (k--) &#123; scanf("%lld%lld", &amp;l, &amp;r); l--, r--; printf("%lld\n", get()); &#125;&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); scanf("%s", s); scanf("%s", t); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第三场</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dirt Ratio]]></title>
    <url>%2F2019%2F06%2F26%2FDirt-Ratio%2F</url>
    <content type="text"><![CDATA[题目链接题意给$n$个数，计算$(l,r)$中不同数字数量/$(r-l+1)$.即\frac{size(l, r)}{r - l + 1} 的最小值。 思路二分答案，每次去看$Mid$值是否合法。我们将上面式子变形为 \frac{size(l, r)}{r-l+1} \leq Mid.size(l, r) + l \times Mid \leq Mid \times (r + 1).我们枚举$r$，在线段树上维护到当前$r$每一$l$的size(l,r)+Mid \times l.动态更新r会产生影响的l。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50#define lson rt &lt;&lt; 1#define rson rt &lt;&lt; 1 | 1#define Lson L, mid, lson#define Rson mid + 1, R, rsonconst int N = 6e4 + 5;double lazy[N &lt;&lt; 2];double val[N &lt;&lt; 2];double Mid;void push_up(int rt)&#123; //sum[rt] = sum[lson] + sum[rson]; val[rt] = min(val[lson], val[rson]);&#125;void build(int L, int R, int rt)&#123; //sum[rt] = 0; lazy[rt] = 0; val[rt] = inf; if (L == R) &#123; val[rt] = L * Mid; return; &#125; int mid = (L + R) &gt;&gt; 1; build(Lson); build(Rson); push_up(rt);&#125;void push_down(int len, int rt)&#123; if (lazy[rt]) &#123;// sum[lson] = sum[lson] + (len - (len &gt;&gt; 1)) * lazy[rt];// sum[rson] = sum[rson] + (len &gt;&gt; 1) * lazy[rt]; val[lson] = val[lson] + lazy[rt]; val[rson] = val[rson] + lazy[rt]; lazy[lson] += lazy[rt]; lazy[rson] += lazy[rt]; lazy[rt] = 0; &#125;&#125;void update(int l, int r, int v, int L, int R, int rt)&#123; if (l &lt;= L &amp;&amp; r &gt;= R) &#123; int len = R - L + 1; lazy[rt] += v;// sum[rt] += v * len; val[rt] += v; return; &#125; /* if (L == R) &#123; val[rt] += v; return; &#125; */ int mid = (L + R) &gt;&gt; 1; push_down(R - L + 1, rt); if (l &lt;= mid) update(l, r, v, Lson); if (r &gt; mid) update(l, r, v, Rson); push_up(rt);&#125;double query(int l, int r, int L, int R, int rt)&#123; if (l &lt;= L &amp;&amp; r &gt;= R) return val[rt]; double ans = (1ll &lt;&lt; 50) * 1.0; push_down(R - L + 1, rt); int mid = (L + R) &gt;&gt; 1; if (l &lt;= mid) ans = min(ans, query(l, r, Lson)); if (r &gt; mid) ans = min(ans, query(l, r, Rson)); return ans;&#125;int pre[N];int pos[N];int a[N], n;bool check()&#123; //dbg(Mid); build(1, n, 1); for (int i = 1; i &lt;= n; i++) &#123; // dbg(i); update(pre[i] + 1, i, 1, 1, n, 1); // dbg(query(1, i, 1, n, 1)); if (query(1, i, 1, n, 1) &lt;= Mid * 1.0 * (i + 1)) return true; &#125; return false;&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) pos[i] = 0; for (int i = 1; i &lt;= n; i++) &#123; pre[i] = pos[a[i]]; pos[a[i]] = i; &#125; double l = 0, r = n + 1, eps = 1e-6; while (r - l &gt;= eps) &#123; Mid = (r + l) / 2.0; if (check()) r = Mid; else l = Mid; &#125; printf("%.5f\n", l); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第四场</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Counting Divisors]]></title>
    <url>%2F2019%2F06%2F26%2FCounting-Divisors%2F</url>
    <content type="text"><![CDATA[题目链接题意$d(i)$表示约数函数。计算\sum_{i=l}^{r} d({i}^{k}) mod 998244353.其中1 \leq l \leq r \leq {10}^{12}, r - l \leq {10}^{6}, 1 \leq k \leq {10}^{7}. 思路因为注意到r - l其实范围不大，我们可以计算这个范围内每一个数字的答案，分开素数和非素数。素数的话答案就是k+1，非素数我们可以按唯一分解定理将其分成n={p_{1}}^{e_{1}}{p_{2}}^{e_{2}}...{p_{w}^{e_{w}}}. {n}^{k} = {p_{1}}^{e_{1}k}{p_{2}}^{e_{2}k}...{p_{w}}^{e_{w}k}.d({n}^{k}) = (e_{1}k + 1)(e_{2}k + 1)...(e_{w}k + 1).具体见代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e6 + 100;ll prime[N];int tot;bool vis[N];void pre()&#123; tot = 0; for (int i = 2; i &lt;= 1000010; i++) &#123; if (!vis[i]) prime[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= 1000010; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;ll cnt[N];ll val[N];const ll mod = 998244353;int main()&#123; int T; scanf("%d", &amp;T); pre(); while (T--) &#123; ll l, r, k; scanf("%lld%lld%lld", &amp;l, &amp;r, &amp;k); for (int i = 0; i &lt;= r - l; i++) &#123; cnt[i] = 1; val[i] = i + l; &#125; for (int i = 1; i &lt;= tot &amp;&amp; prime[i] * prime[i] &lt;= r; i++) &#123; //dbg(i); ll cur = l / prime[i] * prime[i]; while (cur &lt; l) &#123; cur = cur + prime[i]; &#125; for (; cur &lt;= r; cur += prime[i]) &#123; ll c = 0; while (val[cur - l] % prime[i] == 0) &#123; val[cur - l] /= prime[i]; c++; &#125; cnt[cur - l] = (cnt[cur - l] * (c * k % mod + 1)) % mod; //dbg(cur, cnt[cur - l + 1]); &#125; &#125; ll ans = 0; for (int i = 0; i + l &lt;= r; i++) &#123; if (val[i] == 1) ans = (ans + cnt[i]) % mod; else ans = (ans + cnt[i] * (k + 1) % mod) % mod; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第四场</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>区间筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Time To Get Up]]></title>
    <url>%2F2019%2F06%2F26%2FTime-To-Get-Up%2F</url>
    <content type="text"><![CDATA[题目链接题意用一个7*21的二维矩阵表示一个时间，要求输出时间。 思路可以记录每条边是否出现，对于这样若干条边的集合记录数字是多少。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50char s[10][30];const int up = 1 &lt;&lt; 8;int hack[up];int check(int t)&#123; int ans = 0; if (s[0][t + 1] == 'X') ans |= (1 &lt;&lt; 1); if (s[1][t + 3] == 'X') ans |= (1 &lt;&lt; 0); if (s[1][t] == 'X') ans |= (1 &lt;&lt; 2); if (s[3][t + 1] == 'X') ans |= (1 &lt;&lt; 3); if (s[4][t] == 'X') ans |= (1 &lt;&lt; 6); if (s[6][t + 1] == 'X') ans |= (1 &lt;&lt; 5); if (s[4][t + 3] == 'X') ans |= (1 &lt;&lt; 4); return hack[ans];&#125;int main()&#123; int T; scanf("%d", &amp;T); hack[119] = 0; hack[17] = 1; hack[107] = 2; hack[59] = 3; hack[29] = 4; hack[62] = 5; hack[126] = 6; hack[19] = 7; hack[127] = 8; hack[63] = 9; while (T--) &#123; for (int i = 0; i &lt; 7; i++) scanf("%s", s[i]); printf("%d%d:%d%d\n", check(0), check(5), check(12), check(17)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第四场</category>
      </categories>
      <tags>
        <tag>模拟题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Questionnaire]]></title>
    <url>%2F2019%2F06%2F26%2FQuestionnaire%2F</url>
    <content type="text"><![CDATA[题目链接题意让你找到合适的m,k，使得n个数字对m取模结果为k的数量为cnt，且cnt不少于n-cnt。 思路我们可以看其中奇数数量和偶数数量，那么就可以让m为2，然后比较一下就可以得到答案了。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;int a[N];int main()&#123; int T; scanf("%d", &amp;T); while (T--)&#123; int n; scanf("%d", &amp;n); int cnt= 0; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); if (x &amp; 1) cnt++; &#125; if (cnt &gt;= n - cnt) printf("2 1\n"); else printf("2 0\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第四场</category>
      </categories>
      <tags>
        <tag>签到题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lazy Running]]></title>
    <url>%2F2019%2F06%2F26%2FLazy-Running%2F</url>
    <content type="text"><![CDATA[题目链接同余最短路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, ll&gt; P;const ll MAX = 1e18;struct POINT&#123; int dis; int id;&#125; a[10][5];ll d[5][60050];void djs(int st, ll m)&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; q.push(P(2, 0)); while (!q.empty()) &#123; P now = q.top(); q.pop(); ll dis1 = now.second; int u = now.first; if(dis1&gt;d[u][dis1%m]) continue; for (int i = 0; i &lt; 2; i++) &#123; ll dis2 = a[u][i].dis + d[u][dis1 % m]; if (dis2 &lt; d[a[u][i].id][dis2 % m]) &#123; d[a[u][i].id][dis2 % m] = dis2; q.push(P(a[u][i].id, dis2)); &#125; &#125; &#125;&#125;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;int main()&#123; int T; read(T); while (T--) &#123; ll k; ll ans = MAX; int d1, d2, d3, d4; read(k), read(d1), read(d2), read(d3), read(d4); a[1][0].dis = d1, a[1][0].id = 2; a[1][1].dis = d4, a[1][1].id = 4; a[2][0].dis = d2, a[2][0].id = 3; a[2][1].dis = d1, a[2][1].id = 1; a[3][0].dis = d3, a[3][0].id = 4; a[3][1].dis = d2, a[3][1].id = 2; a[4][0].dis = d4, a[4][0].id = 1; a[4][1].dis = d3, a[4][1].id = 3; ll m = min(d1, d2) * 2; for (int i = 0; i &lt; 5; i++) for (int j = 0; j &lt;= m; j++) d[i][j] = MAX; d[2][0] = 0; djs(2, m); for (int i = 0; i &lt; m; i++) &#123; if (d[2][i] &lt; k) &#123; ll yu = k - d[2][i], cx; if (yu % m) cx = (yu / m) + 1; else cx = yu / m; ans = min(ans, d[2][i] + cx * m); &#125; else ans = min(ans, d[2][i]); &#125; printf("%lld\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第四场</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXD, tree and sequence]]></title>
    <url>%2F2019%2F06%2F23%2FRXD-tree-and-sequence%2F</url>
    <content type="text"><![CDATA[题目链接题意有一棵树，$n$个结点，有$n$一个排列$p$。现在要求将$p$分成$k$段，每段求出$lca$后使得每段$lca$深度和最小。 思路很明显是一道dp。状态也很容易想到用$dp[i][j]$表示前$i$个数字已经划分了$j$段。要知道一个性质是，每次在一段区间末尾加入一个数字后，值是不增的。 第一种dp所以我们不妨假设$p[i]$加入$p[j]$时不会产生影响。直接$dp[i][j]=dp[i - 1][j].$实际上我们知道这是有条件的，也就是要求$p[i]$与$p[i-1]$的$lca$在这段区间里是不起决定性作用的，那我们这样暴力按照相等转移是对的么？不要着急，其实我们本来不应该直接$dp[i][j] = dp[i - 1][j]$，但是由于这个答案是不增的，所以要么这个式子满足，要么会有更优的答案来代替它。现在我们来看一下其他可能更优秀的转移。（我个人觉得上面这个比较难理解）如上所述，第一种情况，$dp[i][j]=dp[i-1][j].$第二种情况，$p[i]$单独成段，$dp[i][j]=dp[i-1][j-1]+dep(p[i]).$第三种情况，如果$p[i]$是起决定性作用的点，那么这段区间的$lca$可由它和区间里任意一个点的$lca$得到。我们不妨就用$p[i-1]$，$dp[i][j]=dp[i-2][j-1]+dep(lca(p[i], p[i-1])).$ 上面三种情况去最小就好了。 不知道为什么，用邻接表一直WA，改前向星就过了，我这可怜的一个小时就这样过去了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 3e5 + 5;struct Edge &#123; int v, nxt;&#125; E[N * 2];int head[N];int cnt = 0;void add(int u, int v) &#123; E[cnt].v = v; E[cnt].nxt = head[u]; head[u] = cnt++;&#125;int tot, ver[2 * N], deep[2 * N], first[N], lcy[2 * N][30], dir[N];void dfs(int u, int f, int dep)&#123; first[u] = ++tot; ver[tot] = u; deep[tot] = dep; dir[u] = dep; for (int it = head[u]; ~it; it = E[it].nxt) &#123; int v = E[it].v; if (v == f) continue; dfs(v, u, dep + 1); ver[++tot] = u; deep[tot] = dep; &#125;&#125;void ST()&#123; for (int i = 1; i &lt;= tot; i++) lcy[i][0] = i; for (int j = 1; (1 &lt;&lt; j) &lt;= tot; j++) &#123; for (int i = 1; i + (1 &lt;&lt; j) &lt; tot; i++) &#123; int a = lcy[i][j - 1], b = lcy[i + (1 &lt;&lt; (j - 1))][j - 1]; lcy[i][j] = deep[a] &lt; deep[b]? a : b;// dbg(i, j, lcy[i][j]); &#125; &#125;&#125;int RMQ(int l, int r)&#123; int k = 31 - __builtin_clz(r - l + 1); int a = lcy[l][k], b = lcy[r - (1 &lt;&lt; k) + 1][k];// dbg(lcy[l][k], lcy[r - (1 &lt;&lt; k) + 1][k]); if (deep[a] &lt; deep[b]) return a; else return b;&#125;int lca(int x, int y)&#123; int a = first[x], b = first[y];// dbg(a, b); if (a &gt; b) swap(a, b); return ver[RMQ(a, b)];&#125;vector&lt;vector&lt;int&gt; &gt;dp;int p[N];int main()&#123; int n, k; while (scanf("%d%d", &amp;n, &amp;k) != EOF) &#123; tot = 0; cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;p[i]); head[i] = -1; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); add(u, v); add(v, u); &#125; dp.resize(n + 1); for (int i = 0; i &lt;= n; i++) &#123; dp[i].resize(k + 1); for (int j = 1; j &lt;= k; j++) dp[i][j] = 0x3f3f3f3f; &#125; dfs(1, 0, 1); ST();// puts("ove1r"); dp[0][0] = 0;// dbg(lca(4, 6));// puts("over2");// /* for (int j = 1; j &lt;= k; j++) &#123; for (int i = j; i &lt;= n; i++) &#123;// dbg(j, i); dp[i][j] = dp[i - 1][j]; dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + dir[p[i]]); if (i - 1 &gt;= j) dp[i][j] = min(dp[i][j], dp[i - 2][j - 1] + dir[lca(p[i], p[i - 1])]);// dbg(i, j, dp[i][j], first[p[i]], lca(p[i], p[i - 1])); &#125; &#125; printf("%d\n", dp[n][k]);// */ &#125; return 0;&#125; 第二种 cdq分治这也是标程的做法，我在赛中也是想过加速$k$层dp的，但是没想出怎么单调来。这个做法其实也是用了前面的性质，即将一段区间$B$加在区间$A$的后面，$B$的$lca$有可能是具有决定性的，也可能不是。只有这两种可能，我们在cdq分治的时候可以将$l$到$mid$区间分成两部分，一部分是和$mid+1$到$i$拼接起来后$lca$与后半段无关的。另外一部分是要将两部分取$lca$的。这两种情况的分界点，经过观察具有单调性。于是我们就可以用cdq分治在$O(nklogn)$的时间内解决了。 参考博客123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 3e5 + 5;struct node&#123; int v, nxt;&#125;edge[N * 2];int tot, head[N];void add_edge(int u, int v)&#123; edge[++tot].v = v; edge[tot].nxt = head[u]; head[u] = tot;&#125;int first[N], dep[2 * N], st[2 * N][30], ord[2 * N];int cur = 0;void dfs(int u, int f, int d)&#123; dep[u] = d; first[u] = ++cur; st[cur][0] = cur; ord[cur] = u; for (int it = head[u]; ~it; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f) continue;// dbg(u, v); dfs(v, u, d + 1); st[++cur][0] = cur; ord[cur] = u; &#125;&#125;void ST()&#123; for (int j = 1; (1 &lt;&lt; j) &lt;= cur; j++) for (int i = 1; i + (1 &lt;&lt; j) &lt;= cur + 1; i++) &#123; int a = st[i][j - 1], b = st[i + (1 &lt;&lt; (j - 1))][j - 1]; st[i][j] = dep[ord[a]] &lt; dep[ord[b]] ? a : b;// dbg(i, j, dep[ord[st[i][j]]]); &#125;&#125;int RMQ(int l, int r)&#123; int k = 31 - __builtin_clz(r - l + 1); int a = st[l][k], b = st[r - (1 &lt;&lt; k) + 1][k]; if (dep[ord[a]] &lt; dep[ord[b]]) return ord[a]; else return ord[b];&#125;int lca(int u, int v)&#123; int x = first[u], y = first[v]; if (x &gt; y) swap(x, y); return RMQ(x, y);&#125;vector&lt;vector&lt;int&gt; &gt; dp;int p[N];int a[N], b[N], c[N];void cdq(int l, int r, int k)&#123; if (l &gt;= r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid, k); a[mid] = p[mid]; a[mid + 1] = p[mid + 1]; for (int i = mid - 1; i &gt;= l; i--) a[i] = lca(a[i + 1], p[i]); for (int i = mid + 2; i &lt;= r; i++) a[i] = lca(a[i - 1], p[i]); for (int i = mid + 1; i &lt;= r; i++) dp[i][k] = min(dp[mid][k - 1] + dep[a[i]], dp[i][k]); b[l] = 0x3f3f3f3f; for (int i = l + 1; i &lt;= mid; i++) b[i] = min(b[i - 1], dp[i - 1][k - 1] + dep[a[i]]); c[mid + 1] = 0x3f3f3f3f; for (int i = mid; i &gt;= l + 1; i--) c[i] = min(c[i + 1], dp[i - 1][k - 1]); int tmp = lca(a[mid], a[mid + 1]); int pos = mid; while (pos &gt; l &amp;&amp; dep[a[pos]] &gt; dep[tmp]) pos--; for (int i = mid + 1; i &lt;= r; i++) &#123; if (dep[a[i]] &lt; dep[tmp]) tmp = lca(tmp, p[i]); while (pos &gt; l &amp;&amp; dep[a[pos]] &gt; dep[tmp]) pos--; dp[i][k] = min(dp[i][k], c[pos + 1] + dep[tmp]); dp[i][k] = min(dp[i][k], b[pos]); &#125; cdq(mid + 1, r, k);&#125;void init(int n, int k)&#123; for (int i = 1; i &lt;= n; i++) head[i] = -1; tot = cur = 0; dp.resize(n + 1); for (int i = 0; i &lt;= n; i++) dp[i].resize(k + 1);&#125;int main()&#123; int n, k; while (scanf("%d%d", &amp;n, &amp;k) != EOF) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); init(n, k); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); add_edge(u, v); add_edge(v, u); &#125; dfs(1, 0, 1); ST(); dp[0][0] = 0; for (int i = 0; i &lt;= n; i++) for (int j = 1; j &lt;= k; j++) dp[i][j] = 0x3f3f3f3f; int tmp = p[1]; for (int i = 1; i &lt;= n; i++) &#123; tmp = lca(tmp, p[i]); dp[i][1] = dep[tmp]; &#125; for (int kk = 2; kk &lt;= k; kk++) cdq(1, n, kk); printf("%d\n", dp[n][k]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第三场</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Tree</tag>
        <tag>lca</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXD and functions]]></title>
    <url>%2F2019%2F06%2F23%2FRXD-and-functions%2F</url>
    <content type="text"><![CDATA[题目链接题意已知f(x)= \sum_{i=0}^{n} c_{i} {x}^{i}.定义变换$Tr(f,a)$，使得g(x)=Tr(f,a)=f(x-a).已知g_{0}=f，且有g_{i}=Tr(g_{i-1}, a_{i}),g_{m} = \sum_{i=0}^{n} b_{i} {x}^{i}，输入m。求b_{i}对998244353取模。 思路推式子时间到。 f(x) = \sum_{i=0}^{n} c_{i} {x}^{i}Tr(f, a)=f(x-a)g_{0}=f, g_{i}=Tr(g_{i-1}, a_{i}).g_{1}= \sum_{i=0}^{n} c_{i}{(x-a_{1})}^{i}.g_{2}= \sum_{i=0}^{n} c_{i} {(x - a_{1} - a_{2})}^{i}....g_{m} = \sum_{i=0}^{n} c_{i} {(x-a_{1}-a_{2}-a_{3}...)}^{i}.S = \sum_{i=1}^{m} a_{i}.g_{m} = \sum_{i=0}^{n} c_{i} {(x-S)}^{i}.=b_{i}{x}^{i}.b_{i} = \sum_{j=i}^{n}c_{j} C_{j}^{i} {(-S)}^{j-i}.= \sum_{j=i}^{n} c_{j} \times \frac{j!}{(j-i)!i!} {(-S)}^{j-i}.= \frac{1}{i!} \sum_{j=i}^{n} c_{j} \frac{j!}{(j-i)!} {(-S)}^{j-i}.= \frac{1}{i!} \sum_{j=0}^{n-i} c_{i+j} (i+j)! \frac{ {(-S)}^{j} }{j!}.= \frac{1}{i!} \sum_{j=0}^{n-i} c_{i+j} (i+j)! \frac{ {(-S)}^{n-(n-j)} }{(n-(n-j))!}.= \frac{1}{i!} \times (A*B)_{n+i}.其中A_{i} = c_{i} \times i!,B_{i} = \frac{ {(-S)}^{n-i} }{(n-i)!}. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const ll mod = 998244353;const ll g = 3;ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;void change(ll y[],int len)&#123; for(int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); int k = len / 2; while (j &gt;= k) &#123; j -= k; k /= 2; &#125; if (j &lt; k) j += k; &#125;&#125;void ntt(ll y[], int len, int on)&#123; change(y, len); for(int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; ll wn = Pow(g, (mod-1) / h); if(on == -1) wn = Pow(wn, mod-2); for(int j = 0; j &lt; len; j += h) &#123; ll w = 1LL; for (int k = j; k &lt; j + h / 2; k++) &#123; ll u = y[k]; ll t = w * y[k + h / 2] % mod; y[k] = (u + t) % mod; y[k + h / 2] = (u - t + mod) % mod; w = w * wn % mod; &#125; &#125; &#125; if (on == -1) &#123; ll t = Pow(len, mod-2); for(int i = 0; i &lt; len; i++) y[i] = y[i] * t % mod; &#125;&#125;const int N = 1e5 + 5;ll c[N], b[N];ll x1[N &lt;&lt; 2], x2[N &lt;&lt; 2];ll fac[N], inv[N];int main()&#123; ll n, m; fac[0] = 1; for (int i = 1; i &lt;= 100000; i++) fac[i] = fac[i - 1] * i % mod; inv[100000] = Pow(fac[100000], mod - 2); for (int i = 99999; i &gt;= 0; i--) inv[i] = inv[i + 1] * (i + 1) % mod; while (scanf("%lld", &amp;n) != EOF) &#123; for (int i = 0; i &lt;= n; i++) scanf("%lld", &amp;c[i]); ll s = 0; scanf("%lld", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; ll a; scanf("%lld", &amp;a); s = (s + a + mod) % mod; &#125; if (s == 0) &#123; for (int i = 0; i &lt;= n; i++) printf("%lld ", c[i]); putchar('\n'); continue; &#125; int len = 1; while (len &lt;= 2 * (n + 1)) len &lt;&lt;= 1; for (int i = 0; i &lt;= len; i++) x1[i] = x2[i] = 0; for (int i = 0; i &lt;= n; i++) x1[i] = c[i] * fac[i] % mod; ll tmp = 1ll; for (int i = n; i &gt;=0; i--) &#123; x2[i] = tmp * inv[n - i] % mod; tmp = tmp * (-s) % mod; tmp = (tmp + mod) % mod; &#125; ntt(x1, len, 1); ntt(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i] % mod; ntt(x1, len, -1); for (int i = n; i &lt;= 2 * n; i++) printf("%lld ", x1[i] * inv[i - n] % mod); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第三场</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXD and dividing]]></title>
    <url>%2F2019%2F06%2F23%2FRXD-and-dividing%2F</url>
    <content type="text"><![CDATA[题目链接题意有一棵n个点的树，每条边有边权，现在要求将$2,3,4…n$划分成$k$部分，定义$f(S)$为$S$集合的最小斯坦纳树的边权和。求res=\sum_{i=1}^{k}f({1} \bigcup S_{i})最大。 思路首先解释一下什么是斯坦纳树。 斯坦纳树斯坦纳树允许在给定的集合外多加一些点，使得总开销最小。最小生成树是一种特殊的斯坦纳树。 贪心按照贡献计算，每个几何最后都要和1号点也就是根结点连通，所以如果选择他或他的子结点作为一个集合的一部分，那么它上面这条边能产生w_{i}的贡献，他最大贡献即是w_{i} \times min(size(u), k)，只要$dfs$一下就可以了。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第三场</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kanade's trio]]></title>
    <url>%2F2019%2F06%2F23%2FKanade-s-trio%2F</url>
    <content type="text"><![CDATA[题目链接题意数列$A$，计算有多少$i,j,k$满足i < j < k, A_{i} xor A_{j} < A_{j} xor A_{k}. 思路如果已经确定A_{i}与A_{k}，那么我们很容易根据他们两个二进制中最高的不同那位确定出A_{j}这一位是什么。建一棵字典树，我们枚举$k$，在树上插入A_{k}，插入过程中我们可以顺便求出有多少$i$与$j$是满足要求的。假设我们现在找到了A_{k}的第$p$位，如果是0，我们可以去找这一位是1的A_{i}，现在的问题是如何找$j$有多少个。 第一部分，A_{i}与A_{j}都是当前节点的儿子。即二者前$p-1$位都和A_{k}一样。这个比较好理解。第二部分，A_{i}是这个节点的儿子，A_{j}在其它地方。第三部分，第二部分直接计数会有一部分$i &gt; j$的也被计入，所以要把它减去，于是我们想到用一个新东西去记录每个数字被插入前，有多少个数字不在他的子树里，而且当前这一位和他相同。这是下面代码中的$ext$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 2e7 + 5;int tot;int size[N], ch[N][2];ll ext[N], cnt[32][2];int root;int newnode()&#123; size[++tot] = 0; ch[tot][1] = ch[tot][0] = 0; return tot;&#125;ll ans = 0;void insert(ll x)&#123; int cur = root; for (int i = 31; i &gt;= 0; i--) &#123; int d = (x &gt;&gt; i) &amp; 1; ll s = size[ch[cur][!d]]; ans += s * (s - 1) / 2; ans += (cnt[i][!d] - s) * s - ext[ch[cur][!d]]; if (!ch[cur][d]) ch[cur][d] = newnode(); cur = ch[cur][d]; ext[cur] += cnt[i][d] - size[cur]; cnt[i][d]++; size[cur]++; &#125;&#125;int main()&#123; int n, T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); memset(cnt, 0, sizeof(cnt)); memset(ext, 0, sizeof(ext)); tot = 0; root = newnode(); ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); insert(x); &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第三场</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>01-Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kanade's sum]]></title>
    <url>%2F2019%2F06%2F23%2FKanade-s-sum%2F</url>
    <content type="text"><![CDATA[题目链接题意定义$f(l, r, k)$为$A[l…r]$的$k-th$大。计算 \sum_{l=1}^{n} \sum_{r=l}^{n} f(l, r, k). 思路不妨计算每个数字的贡献，我们求出每个数字的贡献区间即可。标程是用链表写的。我觉得其实笛卡尔树也是一个不错的选择，每次删的都是根结点，但是会T，因为如果树的形状是第一个元素次小的样子，去找那$k$个区间的时候是$O(n)$的。我还是把它贴在这里吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 5e5 + 5;ll seed = 17124057;#define ls(x) treap[x].child[0]#define rs(x) treap[x].child[1]struct node&#123; int val, key, size; int child[2];&#125;treap[N];void push_up(int root)&#123; treap[root].size = treap[ls(root)].size + treap[rs(root)].size + 1;&#125;void split(int root, int &amp;x, int &amp;y, int val)&#123; return;&#125;void merge(int &amp;root, int x, int y)&#123; if (!x || !y) &#123; root = x + y; return; &#125; if (treap[x].key &lt;= treap[y].key) &#123; root = x; merge(rs(x), rs(x), y); &#125; else &#123; root = y; merge(ls(y), x, ls(y)); &#125; push_up(root);&#125;int tot = 0;int root;void insert(int val, int key)&#123; int z = ++tot; treap[z].size = 1; treap[z].val = val; treap[z].key = key; ls(z) = 0, rs(z) = 0; merge(root, root, z);&#125;ll ans = 0;ll interval[2][100];int n, k;void dfs(int dir, int u, int &amp;le)&#123; if (!u) return; dfs(dir, treap[u].child[!dir], le); if (le &gt;= k) return; interval[dir][++le] = 1ll * treap[u].val; if (le &gt;= k) return; dfs(dir, treap[u].child[dir], le);&#125;void solve()&#123; int top = root; //dbg(treap[root].val, treap[root].key); int le = 0, ri = 0; dfs(0, ls(root), le); dfs(1, rs(root), ri); interval[0][0] = interval[1][0] = treap[root].val; if (le &lt; k) interval[0][++le] = 0; if (ri &lt; k) interval[1][++ri] = n + 1; for (int i = 1; i &lt;= le; i++) &#123; if (k - i + 1 &gt; ri) continue; ans = ans + treap[root].val * 1ll * (interval[0][i - 1] - interval[0][i]) * (interval[1][k - i + 1] - interval[1][k - i]); &#125; merge(root, ls(root), rs(root));&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;k); tot = 0; root = 0; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); insert(i, x); &#125; ans = 0; for (int i = 1; i &lt;= n; i++) solve(); printf("%lld\n", ans); &#125; return 0;&#125; 链表1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 10;typedef long long ll;int pre[N], nxt[N], v[N], pos[N], n, k;ll a[N], b[N];ll solve(int x) &#123; int c1 = 0, c2 = 0; for(int i = x; i &amp;&amp; c1 &lt;= k; i = pre[i]) a[++c1] = i - pre[i]; for(int i = x; i &lt;= n &amp;&amp; c2 &lt;= k; i = nxt[i]) b[++c2] = nxt[i] - i; ll ans = 0; for(int i = 1; i &lt;= c1; i++) if(k - i + 1 &lt;= c2 &amp;&amp; k - i + 1 &gt;= 1) ans += a[i] * b[k-i+1]; return ans;&#125;void del(int x) &#123; pre[nxt[x]] = pre[x]; nxt[pre[x]] = nxt[x];&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;v[i]), pos[v[i]] = i; for(int i = 0; i &lt;= n + 1; i++) pre[i] = i - 1, nxt[i] = i + 1; pre[0] = 0; nxt[n+1] = n + 1; ll ans = 0; for(int i = 1; i &lt;= n; i++) &#123; ans += solve(pos[i]) * i; del(pos[i]); &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第三场</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kanade's convolution]]></title>
    <url>%2F2019%2F06%2F22%2FKanade-s-convolution%2F</url>
    <content type="text"><![CDATA[题目链接题意已知$A$和$B$数列，且 C_{k} = \sum_{i and j = k} A_{i xor j} \times B_{i or j}.计算 \sum_{i=0}^{ {2}^{m} - 1} C_{i} \times {1526}^{i} mod 998244353. 思路设$i$ $or$ $j = x$,$i$ $xor$ $j = y$.那么$i$ $and$ $j = x$ $xor$ $y$.且要求$x$ $and$ $y = y$. C_{k} = \sum_{x} \sum_{y} [x and y == y] \times [x xor y == k] \times B_{x} \times A_{y} \times {2}^{bit(y)}.C_{k} = \sum_{x xor y = k} [x and y == y] \times B_{x} \times A_{y} \times {2}^{bit(y)}.C_{k} = \sum_{x xor y = k} [bit(x) - bit(y) == bit(k)] \times B_{x} \times A_{y} \times {2}^{bit(y)}.考虑新的函数F(A, k)_{i}表示[bit(i)==k] \times A_{i}，F(B, k)_{i}同理。 则有FWT[F(C, h)] = \sum_{i=k}^{m} FWT[F(A, i-h)] * FWT[F(B, i) )]. C_{k} = F(C, bit(k))_{k}.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const ll mod = 998244353;const ll inv2 = (998244353 + 1) / 2;/*void FWT_or(ll *a, int n, int opt)&#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) for (int k = 0; k &lt; n; ++k) if (opt == 1) a[i + j + k] = a[j + k] + a[i + j + k]; else a[i + j + k] = a[i + j + k] - a[j + k];&#125;void FWT_and(ll *a, int n, int opt)&#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) for (int k = 0; k &lt; i; ++k) if (opt == 1) a[j + k] = a[j + k] + a[i + j + k]; else a[j + k] = a[j + k] - a[i + j + k];&#125;*/void FWT_xor(ll *a, int n, int opt)&#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) for (int k = 0; k &lt; i; ++k) &#123; ll X = a[j + k], Y = a[i + j + k]; a[j + k] = (X + Y) % mod; a[i + j + k] = (X - Y + mod) % mod; if (opt == -1) a[j + k] = 1ll * a[j + k] * inv2 % mod, a[i + j + k] = 1ll * a[i + j + k] * inv2 % mod; &#125;&#125;const int N = 1e6 + 5;ll a[20][N], b[20][N];ll A[N], B[N];ll c[20][N];int main()&#123; int m; scanf("%d", &amp;m); int up = 1 &lt;&lt; m; for (int i = 0; i &lt; up; i++) &#123; scanf("%lld", &amp;A[i]); A[i] = A[i] * (1 &lt;&lt; (__builtin_popcount(i))) % mod; &#125; for (int i = 0; i &lt; up; i++) scanf("%lld", &amp;B[i]); for (int i = 0; i &lt; up; i++) for (int k = 0; k &lt;= m; k++) &#123; a[k][i] = (__builtin_popcount(i) == k)? A[i] : 0; b[k][i] = (__builtin_popcount(i) == k)? B[i] : 0; &#125; for (int k = 0; k &lt;= m; k++) &#123; FWT_xor(a[k], up, 1); FWT_xor(b[k], up, 1); &#125; for (int h = 0; h &lt;= m; h++) for (int k = 0; k &lt;= h; k++) &#123; for (int i = 0; i &lt; up; i++) c[k][i] = (c[k][i] + a[h - k][i] * b[h][i] % mod) % mod; &#125; for (int i = 0; i &lt;= m; i++) FWT_xor(c[i], up, -1); ll ans = 0; ll base = 1; for (int i = 0; i &lt; up; i++) &#123; ans = ans + base * c[__builtin_popcount(i)][i] % mod; ans %= mod; base = base * 1526 % mod; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第三场</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXD and math]]></title>
    <url>%2F2019%2F06%2F22%2FRXD-and-math%2F</url>
    <content type="text"><![CDATA[题目链接题意计算\sum_{i-1}^{ {n}^{k} } { \mu(i)}^{2} \left \lfloor \sqrt{ \frac{ {n}^{k} }{i} } \right \rfloor. 思路赛中是找规律的，规律是比较明显。 根据题解的说法，任意一个数字可以表示成x={a}^{2} \times b.其中$b$是不含二次因子的，| \mu(b)|=1. 这个式子相当于在枚举$b$，然后问能用$a$和$b$表示成${n}^{k}$以内多少个数字.对于每一个$b$，$a$有\left \lfloor \sqrt{ \frac{ {n}^{k} }{i} } \right \rfloor 种。所以相当于所有数字都被数了一遍，答案就是${n}^{k}.$]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第三场</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXD's date]]></title>
    <url>%2F2019%2F06%2F22%2FRXD-s-date%2F</url>
    <content type="text"><![CDATA[题目链接题意找出小于等于35的数字数量即可队友把我咕了好伤心… 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; scanf("%d", &amp;n); int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); cnt += (x &lt;= 35); &#125; printf("%d\n", cnt); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第三场</category>
      </categories>
      <tags>
        <tag>签到题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组套权值线段数]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%A0%91%E5%A5%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[码量预警我们常常使用可持久化线段树来二分求得区间第k大，但是主席树只能应对没有修改的情况，一旦有修改，修改量对于主席树来说将是灾难性的打击。所以我们不能直接修改后面每一棵线段树。处理区间问题我们最常用的套路之一不就是树状数组么，所以我们在这里用树状数组优化出一个log，虽说还是复杂度有点爆炸，但是已经够用了。 树状数组每个点代表一个权值线段树，这棵权值线段树我们也不需要全部建出来，只需要log个点。虽然叫作带修主席树，但他和主席树本质是不一样的，它的思想更像是原本的若干棵权值线段树，每棵树并非承接上一个，而是独立一棵，没有儿子共享的问题。趁着今天大概还明白它是什么东西，赶紧记录一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5e4 + 5;const int M = 1e4 * 2 + N;int n, m;struct query&#123; int x, y, k, type, id;&#125;q[M];int a[N], sum[N];int lowbit(int x)&#123; return x &amp; (-x);&#125;void update(int x, int val)&#123; while (x &lt;= n) &#123; sum[x] += val; x += lowbit(x); &#125;&#125;int get(int x)&#123; if (x == 0) return 0; int ans = 0; while (x) &#123; ans += sum[x]; x -= lowbit(x); &#125; return ans;&#125;int maxnum, tot = 0;char op[5];query q1[M], q2[M];int ans[M];bool is[M];void init()&#123; memset(sum, 0, sizeof(sum)); memset(ans, 0, sizeof(ans)); memset(is, 0, sizeof(is)); return;&#125;void solve(int head, int tail, int l, int r)&#123; if (head &gt; tail) &#123; return; &#125;/* printf("l , r , %d %d\n", l, r); for (int i = head; i &lt;= tail; i++) &#123; printf("query %d %d %d %d %d\n", q[i].x, q[i].y, q[i].k, q[i].type, q[i].id); &#125;*/ if (l == r) &#123; for (int i = head; i &lt;= tail; i++) &#123; if(q[i].type == 2) &#123; is[q[i].id] = 1; ans[q[i].id] = l; &#125; &#125; return; &#125; int mid = l + r &gt;&gt; 1; int f = 0, s = 0; for (int i = head; i &lt;= tail; i++) &#123; if (q[i].type == 1) &#123; if (q[i].y &lt;= mid) &#123; update(q[i].x, q[i].k); q1[++f] = q[i]; &#125; else &#123; q2[++s] = q[i]; &#125; &#125; if (q[i].type == 2) &#123; int ss = get(q[i].y) - get(q[i].x - 1); // printf("ss &amp;&amp; %d %d\n", get(q[i].y), get(q[i].x - 1)); if (ss &gt;= q[i].k) &#123; q1[++f] = q[i]; &#125; else &#123; q[i].k -= ss; q2[++s] = q[i]; &#125; &#125; &#125; for (int i = 1; i &lt;= f; i++) if (q1[i].type == 1) update(q1[i].x, -q1[i].k); int qpos = head; for (int i = 1; i &lt;= f; i++, qpos++) q[qpos] = q1[i]; for (int i = 1; i &lt;= s; i++, qpos++) q[qpos] = q2[i]; solve(head, head + f - 1, l, mid); solve(head + f, tail, mid + 1, r);&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); freopen("out1.txt", "w", stdout); #endif int T; scanf("%d", &amp;T); while (T--) &#123; init(); scanf("%d%d", &amp;n, &amp;m); maxnum = 0; tot = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); maxnum = max(maxnum, a[i]); q[++tot].x = i; q[tot].y = a[i]; q[tot].k = 1; q[tot].type = 1; q[tot].id = tot; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%s", op); int x, y; scanf("%d%d", &amp;x, &amp;y); if (op[0] == 'Q') &#123; q[++tot].type = 2; int k; scanf("%d", &amp;k); q[tot].x = x, q[tot].y = y; q[tot].k = k; q[tot].id = tot; &#125; else &#123; q[++tot].type = 1; q[tot].x = x; q[tot].y = a[x]; q[tot].k = -1; q[tot].id = tot; q[++tot].type = 1; q[tot].x = x; q[tot].y = y; q[tot].id = tot; q[tot].k = 1; maxnum = max(maxnum, y); a[x] = y; &#125; &#125; solve(1, tot, 0, maxnum); for (int i = 1; i &lt;= tot; i++) &#123; if (is[i]) printf("%d\n", ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String and String]]></title>
    <url>%2F2019%2F06%2F22%2FString-and-String%2F</url>
    <content type="text"><![CDATA[题目链接题意输入两个字符串$s$,$t$，且$S$串每个位置有权值$f(i)$，定义$Sval$为$S$串（所有匹配$T$串某一个位置）的子串的右端点权值的和。$q$次操作：1.把 f(a_{i} XOR ans)改为b_{i} XOR ans。 2.询问$T$子串T.substr(a_{i} XOR ans, b_{i} XOR ans)的$Sval$。 思路这题理解了好久，可能还没理解透彻。先整理下思路，后面更新代码。总的来说是一道码量惊人的题目。 后缀自动机实现匹配，我们很容易想到后缀自动机，首先将$S$拼接在$T$后面（反过来也行），建出的后缀自动机，但是由于这题权值定义为右端点，如果用后缀去搞，我们明显更容易确定左端点，所以我们在建串的时候先把两个串反过来。那么能够匹配$T$串某一个子串的$S$串起始位置在后缀树组上其实是一段连续的区间，我们现在要求的其实就是这段区间里其实位置在$S$串要求范围里的$f$值。 RMQ首先我们来看一下怎么找这个区间，利用后缀数组，我们可以知道两个不同位置开始的后缀的$lcp$，我们可以在上面两次二分，找出最大的能够匹配整个要求的$T$子串的范围。怎么check呢？回想我们以前后缀数组的套路，无非就是RMQ一下，看看整个区间是不是height最小值大于等于我们要的长度。 树套数我们现在已经利用RMQ知道了这个后缀数组中的区间在哪里，现在要做的就是求和。也就是\sum_{i=0}^{k}f(y_{i}) (c_{i} XOR ans \leq x_{i}, y_{i} \leq d_{i} XOR ans).如果只是普通求$f$和我们一个线段树或树状数组就可以解决，现在还有一维范围要求，那么我们可以树套数解决这个问题。树状数组的每个点都是一棵线段树，按照sa的顺序往线段树里面加点，这样就可以求出一个后缀数组区间里指定范围内的权值和。 蔡队代码，具体可见wiki123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;bits/stdc++.h&gt;using std::min;using std::printf;using std::reverse;using std::scanf;using std::swap;const int maxn = 1 &lt;&lt; 19;namespace Suffix_Array&#123;char s[maxn];int sa[maxn], t[maxn], t2[maxn], c[maxn], rank[maxn], height[maxn];void build_sa(int m, int n)&#123; n++; int *x = t, *y = t2; for (int i = 0; i &lt; m; i++) c[i] = 0; for (int i = 0; i &lt; n; i++) c[x[i] = s[i]]++; for (int i = 1; i &lt; m; i++) c[i] += c[i - 1]; for (int i = n - 1; ~i; i--) sa[--c[x[i]]] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for (int i = n - k; i &lt; n; i++) y[p++] = i; for (int i = 0; i &lt; n; i++) if (sa[i] &gt;= k) y[p++] = sa[i] - k; for (int i = 0; i &lt; m; i++) c[i] = 0; for (int i = 0; i &lt; n; i++) c[x[y[i]]]++; for (int i = 1; i &lt; m; i++) c[i] += c[i - 1]; for (int i = n - 1; ~i; i--) sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for (int i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++; if (p &gt;= n) break; m = p; &#125; n--; int k = 0; for (int i = 0; i &lt;= n; i++) rank[sa[i]] = i; for (int i = 0; i &lt; n; i++) &#123; if (k) k--; int j = sa[rank[i] - 1]; while (s[i + k] == s[j + k]) k++; height[rank[i]] = k; &#125;&#125;int dp[maxn][30];void initrmq(int n)&#123; for (int i = 1; i &lt;= n; i++) dp[i][0] = height[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125;int rmq(int l, int r)&#123; int k = 31 - __builtin_clz(r - l + 1); return min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);&#125;int lcp(int a, int b)&#123; a = rank[a], b = rank[b]; if (a &gt; b) swap(a, b); return rmq(a + 1, b);&#125;&#125; // namespace Suffix_Arrayusing Suffix_Array::build_sa;using Suffix_Array::initrmq;using Suffix_Array::lcp;using Suffix_Array::rank;using Suffix_Array::rmq;using Suffix_Array::sa;namespace BIT&#123;int n, m;int root[maxn], lson[maxn &lt;&lt; 4], rson[maxn &lt;&lt; 4], sum[maxn &lt;&lt; 4], sz;void init(int n, int m)&#123; BIT::n = n, BIT::m = m; for (int i = 0; i &lt;= n; i++) root[i] = -1; sz = 0;&#125;#define Lson l, m, lson[o]#define Rson m + 1, r, rson[o]void update(int p, int v, int l, int r, int&amp; o)&#123; if (!~o) o = sz++, sum[o] = 0, lson[o] = -1, rson[o] = -1; assert(sz &lt; (maxn &lt;&lt; 4)); sum[o] += v; if (l == r) return; const int m = l + r &gt;&gt; 1; if (p &lt;= m) update(p, v, Lson); else update(p, v, Rson);&#125;int query(int L, int R, int l, int r, int o)&#123; if (!~o) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return sum[o]; const int m = l + r &gt;&gt; 1; int ret = 0; if (L &lt;= m) ret += query(L, R, Lson); if (m &lt; R) ret += query(L, R, Rson); return ret;&#125;void update(int x, int p, int v)&#123; for (int i = x; i &lt;= n; i += i &amp; -i) update(p, v, 0, m, root[i]);&#125;int query(int L, int R, int l, int r)&#123; int ret = 0; for (int i = R; i; i -= i &amp; -i) ret += query(l, r, 0, m, root[i]); for (int i = L - 1; i; i -= i &amp; -i) ret -= query(l, r, 0, m, root[i]); return ret;&#125;&#125; // namespace BITchar s[maxn], t[maxn];int f[maxn];int ans;inline void decode(int&amp; a) &#123; a ^= ans; &#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; ans = 0; scanf("%s%s", s, t); int n = strlen(s), m = strlen(t); reverse(s, s + n), reverse(t, t + m); for (int i = 0; s[i]; i++) scanf("%d", f + i); reverse(f, f + n); int sz = 0; for (int i = 0; s[i]; i++) Suffix_Array::s[sz++] = s[i]; Suffix_Array::s[sz++] = '$'; for (int i = 0; t[i]; i++) Suffix_Array::s[sz++] = t[i]; Suffix_Array::s[sz] = 0; assert(sz == n + m + 1); build_sa(128, sz); initrmq(sz); BIT::init(sz, n - 1); for (int i = 1; i &lt;= sz; i++) if (sa[i] &lt; n) BIT::update(i, sa[i], f[sa[i]]); int q; scanf("%d", &amp;q); while (q--) &#123; static int op, a, b, c, d; scanf("%d", &amp;op); if (op == 1) &#123; scanf("%d%d", &amp;a, &amp;b); decode(a), decode(b); a = n - a - 1; assert(a &lt; n &amp;&amp; a &gt;= 0); BIT::update(rank[a], a, b - f[a]); f[a] = b; &#125; else if (op == 2) &#123; scanf("%d%d%d%d", &amp;c, &amp;d, &amp;a, &amp;b); decode(a), decode(b), decode(c), decode(d); a = n - 1 - a, b = n - 1 - b, c = m - c + n, d = m - d + n; swap(a, b), swap(c, d); int l = 1, r = rank[c] - 1; int lb = rank[c], ub = rank[c]; while (l &lt;= r) &#123; int m = l + r &gt;&gt; 1; if (rmq(m + 1, rank[c]) &gt;= d - c + 1) lb = m, r = m - 1; else l = m + 1; &#125; l = rank[c] + 1, r = sz; while (l &lt;= r) &#123; int m = l + r &gt;&gt; 1; if (rmq(rank[c] + 1, m) &gt;= d - c + 1) ub = m, l = m + 1; else r = m - 1; &#125; b = b - d + c; if (a &gt; b) ans = 0; else ans = BIT::query(lb, ub, a, b); printf("%d\n", ans); &#125; else assert(false); &#125; &#125;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>data structure</tag>
        <tag>String</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[If the starlight never fade]]></title>
    <url>%2F2019%2F06%2F21%2Fstarlight%2F</url>
    <content type="text"><![CDATA[题目链接题意定义$f(i)$表示方程${(x+y)}^{i} \equiv {x}^{i} (mod p), 1 \leq x \leq p-1, 1 \leq y \leq m $ 解的数量, $p$为素数。要求计算\sum_{i=1}^{p-1}if(i)。 思路令g为p的原根,x \equiv {g}^{a} (mod p), y \equiv {g}^{b} (mod p)，那么有 { ({g}^{a}+{g}^{b}) }^{i} \equiv {g}^{ai} (mod p){(1+{g}^{b-a}) }^{i} \equiv 1 (mod p)注意到1+{g}^{b-a} > 1 可以令1+{g}^{b-a} \equiv {g}^{k} (mod p)，则有 {g}^{ki} \equiv 1 (mod p).ki \equiv 0 (mod p-1).k= \frac{s \times (p-1)}{i}k= \frac{t \times (p-1)}{gcd(i, p-1)}因为k不能取0，所以k有gcd(i,p-1)-1种取值，逆推上去，f(i)=m (gcd(i, p-1)-1). \sum_{i=1}^{p-1}if(i) = \sum_{i=1}^{p-1}i m (gcd(i,p-1)-1)= m \sum_{i=1}^{p-1}igcd(i,p-1) - m \frac{(p-1)p}{2}S_{1} = m \sum_{d|(p-1)}^{p-1}{d}^{2} \sum_{e=1}^{ \frac{p-1}{d}}e[gcd(e, \frac{p-1}{d}) == 1]= m \sum_{d|(p-1)}^{p-1}{d}^{2} \frac{ \frac{(p-1)}{d} \varphi(\frac{(p-1)}{d})}{2}.]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>原根</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular polygon]]></title>
    <url>%2F2019%2F06%2F21%2FRegular-polygon%2F</url>
    <content type="text"><![CDATA[题目链接题意二维平面上有$n$个点，问你这些点能组成多少个正多边形。 思路观察一下就可以发现，除了正四边形整数点不可能构成其他多边形，所以我们只需要找有多少个正四边形。注意这个题的四边形其实可以是斜着的，所以我们不能只枚举左下角。需要枚举至少两个点。我的方法是枚举其中两个点，这两个点会构成一个向量$(dx,dy)$，有一个可能的正方形是这样的:$(0,0),(dx,dy),(-dy,dx),(dx-dy,dx+dy).$我们去看是否这四个点都存在，如果存在记录答案，最后答案除以4，因为每个正方形的4条边都被计算了一次。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 205;int mov[3][2]=&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;1,1&#125;&#125;;bool has[210][210];vector&lt;pair&lt;int, int&gt; &gt; v;int main()&#123; int n; while (scanf("%d", &amp;n) != EOF) &#123; for (int i = 0; i &lt;= 209; i++) for (int j = 0; j &lt;= 209; j++) has[i][j] = 0; v.clear(); for (int i = 1; i &lt;= n; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); has[x + 100][y + 100] = true; v.push_back(make_pair(x, y)); &#125; ll cnt = 0; int sz=v.size(); for (int i=0;i&lt;sz;i++) &#123; int x=v[i].first,y=v[i].second; for(int j=0;j&lt;sz;j++)&#123; int xx=v[j].first,yy=v[j].second; if(j==i) continue; int dx=xx-x,dy=yy-y; int flag=1; int dxx=x-dy,dyy=y+dx; if(dxx&lt;-100 || dxx&gt;100 || dyy&lt;-100 || dyy&gt;100||!has[dxx+100][dyy+100])&#123; flag=0; &#125; dxx=x-dy+dx,dyy=y+dx+dy; if(dxx&lt;-100 || dxx&gt;100 || dyy&lt;-100 || dyy&gt;100||!has[dxx+100][dyy+100])&#123; flag=0; &#125; cnt+=flag; &#125; &#125; printf("%lld\n",cnt / 4); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
      <tags>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TrickGCD]]></title>
    <url>%2F2019%2F06%2F21%2FTrickGCD%2F</url>
    <content type="text"><![CDATA[题目链接题意输入$a$数组，询问有多少个$b$数组使得： 1 \leq b_{i} \leq a_{i}gcd(b_{l},b_{l+1},b_{l+2}...b_{r}) \geq 2, 1 \leq l \leq r \leq n.思路首先容易想到这题要求整个$b$数列的最大公约数大于1，简记其$gcd$为$gcd(b)$。不妨设$F(d)$表示$d|gcd(b)$的方案数，$f(d)$表示$gcd(b)=d$的方案数。 F(n)= \sum_{n|d}f(d)f(n) = \sum_{n|d} \mu(\frac{d}{n}) F(d)F(d)= \prod_{i=1}^{n} \left \lfloor \frac{a_{i}}{d} \right \rfloor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;int prime[10000];int tot;bool vis[N];ll miu[N];void pre(int n)&#123; tot = 0; miu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) prime[++tot] = i, miu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; miu[i * prime[j]] = 0; break; &#125; miu[i * prime[j]] = -miu[i]; &#125; &#125;&#125;ll cnt[N];int a[N];const ll mod = 1e9 + 7;ll f[N];ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; int n; pre(100000); int T; scanf("%d", &amp;T); for (int ks = 1; ks &lt;= T; ks++) &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt;= 100000; i++) cnt[i] = 0; int mnv = 0x3f3f3f3f, mxv = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); mnv = min(mnv, a[i]); mxv = max(mxv, a[i]); cnt[a[i]]++; &#125; if (mnv &lt;= 1) &#123; printf("Case #%d: %lld\n", ks, 0ll); continue; &#125; for (int i = 1; i &lt;= mxv; i++) cnt[i] = cnt[i] + cnt[i - 1]; ll ans = 0; int j; for (int i = 0; i &lt;= mxv; i++) f[i] = 0ll; for (int i = 2; i &lt;= mnv; i++) &#123; f[i] = 1ll; for (int l = i; l &lt;= mxv; l += i) &#123; //f[i] = f[i] * (cnt[min(l + i - 1, mxv)] - cnt[l - 1] + mod) % mod * (l / i) % mod; f[i] = f[i] * Pow(1ll * l / i, cnt[min(l + i - 1, mxv)] - cnt[l - 1]) % mod; &#125; //dbg(i, f[i]); /* for (int j = i; j &lt;= mxv; j++) &#123; f[i] = f[i] * Pow(j / i, cnt[j]) % mod; &#125; */ &#125; for (int i = 2; i &lt;= mnv; i++) &#123; for (int d = i; d &lt;= mxv; d += i) ans = (ans + f[d] * miu[d / i] % mod + mod) % mod; &#125; printf("Case #%d: %lld\n", ks, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Mobius inversion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Funny Function]]></title>
    <url>%2F2019%2F06%2F21%2FFunny-Function%2F</url>
    <content type="text"><![CDATA[题目链接题意F_{1,1}=F_{1,2}=1F_{1,i}=F_{1,i-1}+2F_{1,i-2}, i \geq 3F_{i,j}= \sum_{k=j}^{j+n-1} F_{i-1,k} (i \geq 2, j \geq 1)输入$n$和$m$，计算F_{m,1}.对$1000000007$取模。 思路首先很容易可以用特征根计算出F_{1,i}的通项公式。 F_{1,i}= \frac{1}{3} {2}^{i} - \frac{1}{3} {(-1)}^{i}然后无脑计算F_{i,j},容易发现其实他也是等比数列。 F_{i,j} = \sum_{k=j}^{j+n-1} F_{i-1,k}F_{2,j}= \sum_{k=j}^{j+n-1} \frac{1}{3} {2}^{k-1} - \sum_{k=j}^{j+n-1} \frac{1}{3} {(-1)}^{k-1}= (\frac{1}{3} {2}^{n}) {2}^{j} - \frac{1}{3} (1-{(-1)}^{n}) {(-1)}^{j}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const ll mod = 1e9 + 7;ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;int main()&#123; int T; read(T); while (T--) &#123; ll n, m; read(n); read(m); ll ans = 0; ll inv3 = Pow(3, mod - 2); ans = Pow(2, n % (mod - 1)) - 1; ans = (ans + mod) % mod; ans = Pow(ans, m - 1) % mod * inv3 % mod; ans = ans * 2 % mod; if (n % 2 == 1) &#123; ans = (ans + inv3 + mod) % mod; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Sequence]]></title>
    <url>%2F2019%2F06%2F21%2FMaximum-Sequence%2F</url>
    <content type="text"><![CDATA[题目链接队友直接过了，打扰了]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Is Derek lying?]]></title>
    <url>%2F2019%2F06%2F21%2FIs-Derek-lying%2F</url>
    <content type="text"><![CDATA[题目链接题意有$n$到题，有两个人，每个人都做了选择，并且分别得分为$x$, $y$，现在问这个分数是否是真实的。 思路这题解法肯定是去从二者答案相同数量和不同数量去考虑，设相同答案数量为$cnt$，如果分数真实，需要满足以下条件：分数的差异来自于答案的差异，所以分数只差一定小于等于不同答案数量，即$abs(x-y) \leq n-cnt.$两个人分数之和最多是两个人相同的全对，所以$x+y \leq n + cnt$ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 80005;char s1[N], s2[N];int main()&#123; int n; int x, y; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d", &amp;n, &amp;x, &amp;y); scanf("%s%s", s1, s2); int cnt = 0; for (int i = 0; i &lt; n; i++) if (s1[i] == s2[i]) cnt++; if (x + y - cnt &gt; n) &#123; puts("Lying"); continue; &#125; cnt = n - cnt; if (abs(x - y) &gt; cnt) puts("Lying"); else puts("Not lying"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Limited Permutation]]></title>
    <url>%2F2019%2F06%2F21%2FLimited-Permutation%2F</url>
    <content type="text"><![CDATA[题目链接题意有$n$个元素的全排列的合法性定义为：有$n$个区间，对于第$i$个区间[l_{i},r_{i}]有l_{i} \leq i \leq r_{i},对于任意1 \leq L \leq i \leq R \leq n.当且仅当l_{i} \leq L \leq i \leq R \leq r_{i}时,P[i]=min(P[L],P[L+1],...,P[R])。现在给出序列和相应的区间，问多少区间是否合法？ 思路 我们可以先确定的是，这些区间一定是要么包含关系，要么交集为空，而且我们还知道，排列中最小数字的位置左端点一定是$1$，右端点一定是$n$。 我们把$n$个区间进行排序，优先左端点升序，然后右端点降序。这样第一个区间的位置$i$一定放最小的数字，$i$将数列分成两段，我们把$2$到$n$中$i-1$个数放到左边，剩下放到右边，相当于解决一个子问题，答案更新: ans = ans \times C_{n-1}^{i-1}. 123456789ll dfs(int l, int r) &#123; if (l &gt; r) return 1; if (a[rear].l != l || a[rear].r != r) return 0; node now = a[rear++]; ll ret = C(now.r - now.l, now.id - now.l) * dfs(now.l, now.id - 1) % mod; ret = (ret * dfs(now.id + 1, now.r)) % mod; return ret;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>partition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hints of sd0061]]></title>
    <url>%2F2019%2F06%2F21%2FHints-of-sd0061%2F</url>
    <content type="text"><![CDATA[题目链接题意 用给的随机函数可以得到数列$a$，$m$次查询，问第$b_{i}$小的数字。 思路 这道题要线性第$k$小，肯定是不能排序的。 一个思路是手写快排，然后将所有询问一起二分掉，比较卡的做法。 其实这是个套路题 使用STL &lt; algorithm &gt;中的 1nth_element(A, A + k, A + n) 可以在线性时间找到第k大，此题还需要一点小trick，可以先将询问排序，然后每次将排序范围缩小，可以减小枚举量。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>nth element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function]]></title>
    <url>%2F2019%2F06%2F21%2FFunction%2F</url>
    <content type="text"><![CDATA[题目链接题意 已知一个$n$的全排列$a$，和一个$m$的全排列$b$，现在问你有多少种不同的映射$f$使得满足以下条件： f(i)=b_{f(a_{i})}, 0 \leq i < n-1 答案对$1000000007$取模。 思路 假设对于我们现在已有的一个$f$映射，存在这样的关系： f(i)=b_{f(a_{i})}f(a_{i})=b_{f(a_{a_{i}})} ...f(i)=b_{b_{b_{...b_{t}}}}.则我们可以得到一个与$i$有关的闭合环，设$0$到$n-1$中有$w$个这样的环，则这些环之间是不会相互影响的，我们可以分别算出每个环有多少种合法的映射。 对于一个有$x$个数字的环，我们有多少种合法的映射呢？观察以下可以发现，只要确定其中一个位置映射的数字，就可以确定整个环中所有数字的映射，为了使环绕回$i$位置时与原来我们假设的数字不冲突。可以先在$b$数列中求出每个位置循环大小。 设为sz_{b}(i), a中环大小sz_{a}(i)，则a中包含位置i的环合法映射数量为\sum_{j=0}^{j < m} [sz_{b}(j)|sz_{a}(i)] 实际上我们只需要统计数量，所以不需要把每个位置是多少记录下来，只需要处理$a$时记录对应的$sz_{b}(j)$的数量即可。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Division Game]]></title>
    <url>%2F2019%2F06%2F20%2FDivision-Game%2F</url>
    <content type="text"><![CDATA[题目链接题意 用唯一表示法表示出n，输入m，k，表示有k堆石子，每堆有n个，现在拿石子。规则如下： 每次只能在下一堆中拿石子 每次拿走后剩余石子数量d，拿走前n，则必须有$d|n$ 拿到某一堆只剩一颗石子时游戏结束 询问在每一堆石子结束的方案数。 思路 设拿到第$i$堆，拿了$x$次结束的方案数为$f(x)$，则拿到第$i$堆，拿了$x-1$次没结束的方案数也为$f(i)$。 ans(i, x)= \prod_{j=1}^{j < i} {f(x+1)} \times \prod_{j=i+1}^{j \leq k} {f(x)}={f(x+1)}^{i-1} \times {f(x)}^{k-i+1}考虑$x$范围 记$ w= \sum e_{i} $ 当$i = 1$，$x \leq w$；当$i &gt; 1$，$x &lt; w$。 容斥计算$f(x)$ 考虑每个素因子，相当于将$e_{i}$个小球放入$x$个盒子中，不允许空。$g(x)$ 表示$x$盒子，允许空放盒子方案数。 g(x) = \prod_{i=1}^{m} {C_{e_{i}+x-1}^{x-1}} = \sum_{y=0}^{x} {(-1)}^{x-y} g(y) \frac{x!}{y!(x-y)!} 对这个式子NTT即可。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Colorful Tree]]></title>
    <url>%2F2019%2F06%2F20%2FColorful-Tree%2F</url>
    <content type="text"><![CDATA[题目链接题意 一棵有n个节点的树，每个点有一个点权，问在这棵树上所有的$\frac{n(n-1)}{2}$条链颜色种类的和是多少。 思路 对于每种颜色计算其贡献，我们可以先算出每种颜色在多少条链中不出现，用总数减一下就可以得到在多少条链中出现，dfs序处理一下，遍历到一个点的时候我只考虑这个点与其儿子构成的连同块，在这些块里面都不出现这个颜色。 dfs1234567891011121314151617void dfs(int u, int f)&#123; sz[u] = 1; ll all = 0; for (auto &amp;v : G[u]) &#123; if (v == f) continue; ll last = sum[c[u]]; dfs(v, u); sz[u] += sz[v]; ll add = sum[c[u]] - last; ans += (sz[v] - add) * (sz[v] - add - 1) / 2; all += sz[v] - add; &#125; sum[c[u]] += all + 1;&#125; 1234567891011int main()&#123; for (int i = 1; i &lt;= n; i++) &#123; if (!hasc[i]) continue; ans += (n - sum[i]) * (n - sum[i] - 1) / 2ll; &#125; printf("%lld\n", (n - 1) * n / 2 * cnt - ans); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Balala Power!]]></title>
    <url>%2F2019%2F06%2F19%2FBalala-Power%2F</url>
    <content type="text"><![CDATA[题目链接题意输入n个字符串，重新定义字母’a’~’z’的权值，使得给出的字符串在26进制下和最大 思路记录每个字母在每个位置出现的次数，按照贪心高为出现次数多的字母权值大排序（别暴力排，比赛时用个堆维护，一个数组记录最高位置）]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add More Zero]]></title>
    <url>%2F2019%2F06%2F19%2FAdd-More-Zero%2F</url>
    <content type="text"><![CDATA[题目链接题意 输入m，求最大k满足： 10^{k} \leq 2^{m} 其中$1 \leq m \leq 10^{5}$. 思路 因为当k与m均为整数时, 10^{k} \neq 2^{m}10^{k} \leq 2^{m}k \leq lg(2^{m}) = mlg(2) 直接计算答案]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2F2019%2F06%2F19%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[Congratulations for my first blog on github!!!Thanks to github and hexo. Then I probably test some function on this page. Cpp code1234567#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; printf("Hello, world.\n"); return 0;&#125; linkmore markdown rules fomularFibonacci comes like this: F(n)=F(n-1)+F(n-2)Euler function: n = \sum_{d|n} \phi (d)]]></content>
  </entry>
</search>
