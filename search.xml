<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Big Integer]]></title>
    <url>%2F2019%2F08%2F29%2FBig-Integer%2F</url>
    <content type="text"><![CDATA[题目链接题意定义$A(n) = 11111..11$($n$个1)，计算 \sum_{i=1}^{n} \sum_{j=1}^{m} [A(i^j) mod p \equiv 0].思路A(i^j) \equiv \frac{10^{i^j}-1}{9} \equiv mod p显然当该模数是2或5无解。 10^{i^j}-1 \equiv 1 mod(9p)我们去找一下这个东西的循环节$d$,易知d| \varphi(9p).枚举其所有因子，找到$d$，现在计算\sum_{i=1}^{n} \sum_{j=1}^{m} [d|i^j].分解d= \prod_{c} {p_{c} }^{k_{c} }，当确定$j$，那么有\prod_{c} {p_{c} }^{\left \lceil \frac{k_{c} }{j} \right \rceil} | i.这样就很好计算了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const long long LINF = 1e18;const long long MOD = 1e9+7;const int MAXN = 1e5+10; ll pri[105], fac[105], num = 0; void uniqueDecompose(ll x)//唯一分解，pri为对应质数，fac为对应次数&#123; num = 0;//唯一分解后的质数个数 for(int j = 2; j*j &lt;= x; j++) if(x % j == 0) &#123; pri[++num] = j, fac[num] = 0; while(x % j == 0) fac[num]++, x /= j; &#125; if(x &gt; 1) pri[++num] = x, fac[num] = 1;&#125; ll qmul(ll x, ll y, ll m)&#123; ll res = 0; while(y) &#123; if(y &amp; 1) res = (res + x) % m; x = (x + x) % m; y &gt;&gt;= 1; &#125; return res;&#125; ll qpow(ll a, ll n, ll m)&#123; ll res = 1; while(n) &#123; if(n &amp; 1) res = qmul(res, a, m) % m; a = qmul(a, a, m) % m, n &gt;&gt;= 1; &#125; return res;&#125; int main()&#123; int t; cin &gt;&gt; t; while(t--) &#123; //输入与特判 ll p, n, m; scanf("%lld%lld%lld", &amp;p, &amp;n, &amp;m); if(p == 2 || p == 5) &#123; puts("0"); continue; &#125; //求循环节 ll phi = 6 * (p - 1), d = LINF;//phi(9*p), 循环节 assert(qpow(10, phi, 9ll*p) == 1); for(ll i = 1; i*i &lt;= phi; i++) if(phi % i == 0) &#123; ll fac1 = i, fac2 = phi / i; if(qpow(10, fac1, 9ll*p) == 1) d = min(d, fac1); if(qpow(10, fac2, 9ll*p) == 1) d = min(d, fac2); &#125; //求有多少对ij使得d|i^j(i的j次方) uniqueDecompose(d); ll g = 1, ans = 0; for(ll i = 1; i &lt;= min(m, 30ll); i++) &#123; g = 1; for(int j = 1; j &lt;= num; j++) g *= qpow(pri[j], ceil(1.0*fac[j]/i), 2e9); ans += n / g; &#125; if(m &gt; 30) ans += (m - 30) * (n / g); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Subarray]]></title>
    <url>%2F2019%2F08%2F29%2FSubarray%2F</url>
    <content type="text"><![CDATA[题目链接题意询问多少子段和大于等于0. 思路处理每一段1最左和最右能延伸到什么位置。这样处理出的长度是10^7级别的。然后处理这样的一个答案很直觉的一个做法就是找前缀和小于等于当前前缀和的数量有多少。如此做法会有一个\log。观察一下发现我们前缀和每次变化最多是1，所以我们每次询问的答案数量也就在两个相邻数值之间变化。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; #define ERR(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125; void err(istream_iterator&lt;string&gt; it) &#123; cerr &lt;&lt; "\n";&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; "=" &lt;&lt; a &lt;&lt; ", "; err(++it, args...);&#125; #define ERR1(arg,n) &#123; cerr&lt;&lt;""&lt;&lt;#arg&lt;&lt;"=\n "; for(int i=1;i&lt;=n;i++) cerr&lt;&lt;arg[i]&lt;&lt;" "; cerr&lt;&lt;"\n"; &#125;#define ERR2(arg,n,m) &#123; cerr&lt;&lt;""&lt;&lt;#arg&lt;&lt;"=\n"; for(int i=1;i&lt;=n;i++) &#123; cerr&lt;&lt;" "; for(int j=1;j&lt;=m;j++)cerr&lt;&lt;arg[i][j]&lt;&lt;" "; cerr&lt;&lt;"\n"; &#125; &#125; const int INF = 0x3f3f3f3f;const int MAXN = 10000000, MAXM = 1000000; int l[MAXM + 5], r[MAXM + 5], f[MAXM + 5], g[MAXM + 5];int sum[MAXN * 3 + 5], b[MAXN * 3 + 5], c[MAXN * 3 + 5]; int main() &#123;#ifdef Yinku freopen("Yinku.in", "r", stdin);#endif // Yinku int n; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;l[i], &amp;r[i]); f[1] = r[1] - l[1] + 1; //f[i]以i段右端点为结尾的能构造出的最大的前缀和 for(int i = 2; i &lt;= n; i++) f[i] = max(0, f[i - 1] - (l[i] - r[i - 1] - 1)) + r[i] - l[i] + 1; //0：以i-1段右端点结尾的能构造出的最大的前缀和都不足够跨过[i-1,i]之间的-1 //f[i - 1] - (l[i] - r[i - 1] - 1)：跨过之后还剩下多少贡献给这段 g[n] = r[n] - l[n] + 1; //g[i]以i段左端点为开头的能构造出的最大的前缀和 for(int i = n - 1; i &gt;= 1; i--) g[i] = max(0, g[i + 1] - (l[i + 1] - r[i] - 1)) + r[i] - l[i] + 1; //ERR1(f, n); //ERR1(g, n); int i = 1, base = 10000000; ll ans = 0; while(i &lt;= n) &#123; int j = i + 1; while(j &lt;= n &amp;&amp; g[j] + f[j - 1] &gt;= l[j] - r[j - 1] - 1) &#123; //说明这个[j-1,j]之间的-1段可以因为两侧的f[j-1]和g[j]足够大而连接起来 j++; &#125; j--; //此时j是从i开始最远能够连接到的区间 int left = max(0, l[i] - g[i]), right = min(1000000000 - 1, r[j] + f[j]); //left,right是至少会产生一个贡献的范围 //ERR(left, right); int t = i, mi = INF, mx = 0; sum[0] = 0; for(int k = left; k &lt;= right; k++) &#123; //统计这一整段可连接区间的前缀和 if(k &gt;= l[t] &amp;&amp; k &lt;= r[t]) sum[k - left + 1] = sum[k - left] + 1; else sum[k - left + 1] = sum[k - left] - 1; if(k == r[t]) t++; mi = min(mi, sum[k - left + 1] + base); mx = max(mx, sum[k - left + 1] + base); //b记录前缀和出现过的次数 b[sum[k - left + 1] + base] ++; &#125; //ERR1(sum, right); //b记录前缀和出现过的次数的后缀和 for(int k = mx - 1; k &gt;= mi; k--) b[k] += b[k + 1]; //包含最左侧点的贡献 ans += b[base + 1]; for(int k = left; k &lt;= right; k++) &#123; t = sum[k - left + 1] + base; //t表示k位置sum的值 //b[t+1]比t大的值的个数 //c[t+1]比在k位置左侧的比t大的值的个数的lazy b[t + 1] -= c[t + 1]; //把lazy加上去 c[t] += c[t + 1] + 1; //lazy标记下移 c[t + 1] = 0; //清空lazy ans += b[t + 1]; &#125; for(int k = mi; k &lt;= mx; k++) b[k] = 0, c[k] = 0; i = j + 1; &#125; printf("%lld", ans); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kth Minimum Clique]]></title>
    <url>%2F2019%2F08%2F29%2FKth-Minimum-Clique%2F</url>
    <content type="text"><![CDATA[题目链接题意一个人在一张地图上走，每次只能向左右或者向上走，且不能经过墙。现在$q$次询问，每次可能会把一个空地变成墙或墙变空地。也可能询问从$(1,a)$到$(n,b)$的方案数。 思路从第$i$行到第$i+1$行，方案数有多少？我们考虑从$i$行的$j$位置先走到$(i,k)$在到$(i+1,k)$作为一种方案，那么只要在$(i,j)$到$(i,k)$的路上没有墙即可。 dp[i][j] = \sum_{k, a_{k...j}=0} dp[i-1][k].这个东西其实可以被我们写成一个矩阵。接下来的一切理所当然变成线段树维护矩阵乘积。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;const int MAXN = 50005;const int mod = 1e9 + 7; int n, m, q;char c[MAXN][12];int a[MAXN][12]; struct Mat&#123; int m[12][12];&#125;st[MAXN &lt;&lt; 2]; #define lson (p &lt;&lt; 1)#define rson (p &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1) int add(int a, int b)&#123; return a + b &gt;= mod ? a + b - mod : a + b;&#125; int mul(ll a, int b)&#123; return a * b &gt;= mod ? a * b % mod : a * b;&#125; Mat Mmul(Mat a, Mat b)&#123; Mat c; for(int i = 1; i &lt;= m; i ++) for(int j = 1; j &lt;= m; j ++)&#123; c.m[i][j] = 0; for(int k = 1; k &lt;= m; k ++) c.m[i][j] = add(c.m[i][j], mul(a.m[i][k], b.m[k][j])); &#125; return c;&#125; void Mupd(int p, int x)&#123; memset(st[p].m, 0, sizeof(st[p].m)); for(int i = 1; i &lt;= m; i ++) if(!a[x][i])&#123; st[p].m[i][i] = 1; for(int j = i - 1; j &gt;= 1 &amp;&amp; !a[x][j]; j --) st[p].m[j][i] = 1; for(int j = i + 1; j &lt;= m &amp;&amp; !a[x][j]; j ++) st[p].m[j][i] = 1; &#125;&#125; void build(int p, int l, int r)&#123; if(l == r)&#123; Mupd(p, l); return; &#125; build(lson, l, mid); build(rson, mid + 1, r); st[p] = Mmul(st[lson], st[rson]);&#125; void upd(int p, int x, int y, int l, int r)&#123; if(l == r)&#123; Mupd(p, l); return; &#125; if(x &lt;= mid) upd(lson, x, y, l, mid); else upd(rson, x, y, mid + 1, r); st[p] = Mmul(st[lson], st[rson]);&#125; int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i ++)&#123; scanf("%s", c[i] + 1); for(int j = 1; j &lt;= m; j ++) a[i][j] = c[i][j] - '0'; &#125; build(1, 1, n); while(q --)&#123; int op, x, y; scanf("%d%d%d", &amp;op, &amp;x, &amp;y); if(op == 1)&#123; a[x][y] ^= 1; upd(1,x,y,1,n); &#125; else printf("%d\n", st[1].m[x][y]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eddy Walker 2]]></title>
    <url>%2F2019%2F08%2F29%2FEddy-Walker-2%2F</url>
    <content type="text"><![CDATA[题目链接题意一个喝醉的人每次步数是$1~k$中的等概率某一个数字，问他走到$n$的概率是多少。 思路很容易想到dp,$dp[i]$表示走到$i$的概率。 dp[i] = \sum_{j = i-k}^{i-1} dp[j] \frac{1}{k}.这个线性递推显然不能用矩阵快速幂。于是我学会了一个奇技淫巧，快速处理线性递推。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5+ 5;//#define rep(i,a,n) for (int i=a;i&lt;n;i++)//#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)//#define pb push_back//#define mp make_pair//#define all(x) (x).begin(),(x).end()//#define fi first//#define se second//#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1e9 + 7; //修改成题目要求的模数ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;ll Pow(ll a, ll b)&#123; ll ans = 1; a %= mod; assert(b &gt;= 0); while (b) &#123; if (b &amp; 1) ans = ans * a % mod; b &gt;&gt;= 1; a = a * a % mod; &#125; return ans;&#125;// headnamespace linear_seq&#123; const int N = 10010; ll res[N], base[N], _c[N], _md[N]; vector&lt;ll&gt; Md; inline int SZ(vector&lt;ll&gt;&amp; x) &#123; return (int)x.size(); &#125; void mul(ll *a, ll *b, int k) &#123; for (int i = 0; i &lt; k + k; i++) _c[i] = 0; //rep(i,0,k+k) _c[i]=0; //rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i = 0; i &lt; k; i++) if (a[i]) for (int j = 0; j &lt; k; j++) _c[i + j] = (_c[i + j] + a[i] * b[j]) % mod; for (int i = k + k - 1; i &gt;= k; i--) if (_c[i]) for (int j = 0; j &lt; SZ(Md); j++) _c[i - k + Md[j]] = (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % mod; for (int i = 0; i &lt; k; i++) a[i] = _c[i]; &#125; int solve(ll n, vector&lt;ll&gt; a, vector&lt;ll&gt; b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+... // printf("%d\n",SZ(b)); ll ans = 0, pnt = 0; int k = SZ(a); assert(SZ(a) == SZ(b)); //rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; for (int i = 0; i &lt; k; i++) _md[k - 1 - i] = -a[i]; _md[k] = 1; Md.clear(); //rep(i,0,k) if (_md[i]!=0) Md.push_back(i); for (int i = 0; i &lt; k; i++) if (_md[i] != 0) Md.push_back(i); //rep(i,0,k) res[i]=base[i]=0; for (int i = 0; i &lt; k; i++) res[i] = base[i] = 0; res[0] = 1; while ((1ll &lt;&lt; pnt) &lt;= n) pnt++; for (int p = pnt; p &gt;= 0; p--) &#123; mul(res, res, k); if ((n &gt;&gt; p) &amp; 1) &#123; for (int i = k - 1; i &gt;= 0; i--) res[i + 1] = res[i]; res[0] = 0; //rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; for (int j = 0; j &lt; SZ(Md); j++) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod; &#125; &#125; //rep(i,0,k) ans=(ans+res[i]*b[i])%mod; for (int i = 0; i &lt; k; i++) ans = (ans + res[i] * b[i]) % mod; if (ans &lt; 0) ans+=mod; return ans; &#125; vector&lt;ll&gt; BM(vector&lt;ll&gt; s) &#123; vector&lt;ll&gt; C(1,1),B(1,1); int L = 0, m = 1, b = 1; for (int n = 0; n &lt; SZ(s); n++) &#123; ll d = 0; for (int i = 0; i &lt; L + 1; i++) d = (d + (ll)C[i] * s[n-i]) % mod; if (d==0) ++m; else if (2 * L &lt;= n) &#123; vector&lt;ll&gt; T = C; ll c = mod - d * Pow(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.push_back(0); for (int i = 0; i &lt; SZ(B); i++) C[i + m] = (C[i + m] + c * B[i]) % mod; L = n + 1 - L; B = T; b = d; m=1; &#125; else &#123; ll c = mod - d * Pow(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.push_back(0); for (int i = 0; i &lt; SZ(B); i++) C[i + m] = (C[i + m] + c * B[i]) % mod; ++m; &#125; &#125; return C; &#125; ll gao(vector&lt;ll&gt; a,ll n) &#123; vector&lt;ll&gt; c = BM(a); c.erase(c.begin()); for (int i = 0; i &lt; SZ(c); i++) c[i] = (mod - c[i]) % mod; dbg(SZ(c)); return solve(n, c, vector&lt;ll&gt; (a.begin(), a.begin() + SZ(c))); &#125;&#125;;vector&lt;ll&gt; v;int main()&#123; /* int n; while (~scanf("%d",&amp;n)) &#123; vector&lt;int&gt;v; //输入前几项(一般2k项足够) v.push_back(1); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(5); v.push_back(8); //VI&#123;1,1,2,3,5,8&#125; 解出斐波那契数列 printf("i:%d arr:%d\n",n,linear_seq::gao(v,n-1)); &#125; */ int T; scanf("%d", &amp;T); while (T--) &#123; v.clear(); ll n; int k; scanf("%d%lld", &amp;k, &amp;n); ll invk = Pow(k, mod - 2); dbg(invk); if (n &lt; 0) &#123; printf("%lld\n", 2 * Pow(k + 1, mod - 2) % mod); continue; &#125; v.push_back(1); for (int i = 1; i &lt; k; i++) &#123; ll x = 0; for (int j = 0; j &lt; i; j++) x = (x + v[j]) % mod; x = x * invk % mod; v.push_back(x); &#125; for (int i = k; i &lt;= 2 * k + 5; i++) &#123; ll x = 0; for (int j = 1; j &lt;= k; j++) x = (x + v[i - j]) % mod; x = x * invk % mod; v.push_back(x); &#125; printf("%lld\n", linear_seq::gao(v, n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>Linear sequence</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XOR]]></title>
    <url>%2F2019%2F08%2F29%2FXOR%2F</url>
    <content type="text"><![CDATA[题目链接题意计算所有异或起来为0的集合的集合大小之和。即 \sum_{S \subseteq A, \otimes_{x \in S} x = 0} |S|.思路考虑计算每个数字的贡献。即数字a_{i}能参与多少个集合使集合异或和为0。我们先建出整个序列的线性基，那么那些不在线性基里的元素都能被表示，假设我对任何不在线性基里的元素取或不取，整个集合我都可以使异或和为0.为什么呢？因为这是线性基能唯一表示一个数字的特点。那么如果线性基里的元素我都取，其他任取，元素$i$的贡献为2^{n-1-cnt}。对于那些在线性基中的元素，我去检查一下除他以外的数字构成的线性基，用同样的方法去搞一遍。 主要要理解线性基这个工具他可以确定哪些元素是我可以任选，哪些元素是要看其他数字是否都还有的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50 const int N = 1e5 + 5;ll a[N];ll base[65];const ll mod = 1e9 + 7;vector&lt;ll&gt; v;bool vis[N];ll bsc[N];ll tmp[N];ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; int n; while (~scanf("%d", &amp;n)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;a[i]); int tot = 0; v.clear(); for (int i = 1; i &lt;= n; i++) vis[i] = 0; for (int i = 0; i &lt; 64; i++) base[i] = 0; for (int i = 1; i &lt;= n; i++) &#123; ll x = a[i]; for (int j = 63; j &gt;= 0; j--) &#123; if ((x &gt;&gt; j) &amp; 1) &#123; if (!base[j]) &#123; base[j] = x; tot++; vis[i] = true; v.push_back(a[i]); break; &#125; else &#123; x ^= base[j]; &#125; &#125; &#125; &#125; ll ans = Pow(2ll, n - tot - 1) * (n * 1ll - tot) % mod; dbg(ans); for (int j = 0; j &lt; 64; j++) bsc[j] = 0; int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; if (vis[i]) continue; ll x = a[i]; for (int j = 63; j &gt;= 0; j--) if ((x &gt;&gt; j) &amp; 1) &#123; if (!bsc[j]) &#123; bsc[j] = x; cnt++; break; &#125; else &#123; x ^= bsc[j]; &#125; &#125; &#125; for (auto &amp;val : v) &#123; for (int j = 0; j &lt; 64; j++) tmp[j] = bsc[j]; int tcnt = cnt; for (auto &amp; vv : v) if (vv != val) &#123; ll x = vv; for (int j = 63; j &gt;= 0; j--) if ((x &gt;&gt; j) &amp; 1) &#123; if (!tmp[j]) &#123; tmp[j] = x; tcnt++; break; &#125; else &#123; x ^= tmp[j]; &#125; &#125; &#125; ll x = val; for (int j = 63; j &gt;= 0; j--) if ((x &gt;&gt; j) &amp; 1) &#123; if (!tmp[j]) &#123; tmp[j] = x; break; &#125; else &#123; x ^= tmp[j]; &#125; &#125; dbg(val, x); if (x == 0) ans = (ans + Pow(2, n - tcnt - 1)) % mod; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Points Division]]></title>
    <url>%2F2019%2F08%2F29%2FPoints-Division%2F</url>
    <content type="text"><![CDATA[题目链接题意将所有点划分成两个集合，要求集合$A$中的点没有在集合$B$中的点的右下方，且\sum_{i \in A} a_{i} + \sum_{j \in B} b_{j}最大。 思路我们考虑如果这样的答案存在，可以让所有$A$集合中的点向左画一条线，$B$集合中的点向下画一条线，这样让所有的线没有交点。我们不妨让一条折线穿过一些$B$集合的点，满足要求，先将点离散化，然后我们枚举上一次这条线的转折点，就可以进行dp。线段树维护最大值即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1#define mid ll m = (l + r) &gt;&gt; 1 const int M = 1e5+10;ll mx[M&lt;&lt;2],lazy[M&lt;&lt;2];void up(ll rt)&#123; mx[rt] = max(mx[rt&lt;&lt;1],mx[rt&lt;&lt;1|1]);&#125; void pushdown(ll rt)&#123; if(lazy[rt])&#123; lazy[rt&lt;&lt;1] += lazy[rt]; lazy[rt&lt;&lt;1|1] += lazy[rt]; mx[rt&lt;&lt;1] += lazy[rt]; mx[rt&lt;&lt;1|1] += lazy[rt]; lazy[rt] = 0; &#125;&#125; void build(ll l,ll r,ll rt)&#123; lazy[rt] = 0; mx[rt] = 0; if(l == r)&#123; return ; &#125; mid; build(lson); build(rson);&#125; void update(ll p,ll c,ll l,ll r,ll rt)&#123; if(l == r)&#123; mx[rt] = max(mx[rt],c); return ; &#125; pushdown(rt); mid; if(p &lt;= m) update(p,c,lson); else update(p,c,rson); up(rt);&#125; void update1(ll L,ll R,ll c,ll l,ll r,ll rt)&#123; if(L &gt; R) return ; //会出现L &gt; R的情况，需要判下 if(L &lt;= l&amp;&amp;R &gt;= r)&#123; mx[rt] += c; lazy[rt] += c; return ; &#125; pushdown(rt); mid; if(L &lt;= m) update1(L,R,c,lson); if(R &gt; m) update1(L,R,c,rson); up(rt);&#125; ll query(ll L,ll R,ll l,ll r,ll rt)&#123; if(L &gt; R) return 0; if(L &lt;= l&amp;&amp;R &gt;= r)&#123; return mx[rt]; &#125; pushdown(rt); mid; ll ret = 0; if(L &lt;= m) ret = max(ret,query(L,R,lson)); if(R &gt; m) ret = max(ret,query(L,R,rson)); return ret;&#125; struct node&#123; ll x,y,a,b;&#125;v[M];bool cmp(node aa,node bb)&#123; if(aa.x == bb.x) return aa.y &gt; bb.y; return aa.x &lt; bb.x;&#125;ll t[M];int main()&#123; ll n; while(scanf("%lld",&amp;n)!=EOF)&#123; ll cnt = 0; for(ll i = 1;i &lt;= n;i ++)&#123; scanf("%lld%lld%lld%lld",&amp;v[i].x,&amp;v[i].y,&amp;v[i].a,&amp;v[i].b); t[++cnt] = v[i].y; &#125; sort(t+1,t+1+cnt); sort(v+1,v+1+n,cmp); ll m = unique(t+1,t+1+cnt)-t-1; for(ll i = 1;i &lt;= n;i ++) v[i].y = lower_bound(t+1,t+1+m,v[i].y)-t+1; //离散化时点都向后移一位 m ++; //点后移了一位，长度要+1; build(1,m,1); for(ll i = 1;i &lt;= n;i ++)&#123; ll ans = query(1,v[i].y,1,m,1); update1(v[i].y,m,v[i].b,1,m,1); update1(1,v[i].y-1,v[i].a,1,m,1); update(v[i].y,ans+v[i].b,1,m,1); &#125; printf("%lld\n",mx[1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parity of Tuples]]></title>
    <url>%2F2019%2F08%2F29%2FParity-of-Tuples%2F</url>
    <content type="text"><![CDATA[题目链接题意有$n$个$m$元组，定义$count(x)$为满足所有a_{i, j} and x的结果有奇数个1的元组的个数。现在计算\otimes_{x=0}^{ {2}^{k}-1} (count(x) \times {3}^{x} mod ({10}^{9}+7)). 思路FWT首先了解一下快速沃尔什变换在异或上的意义。我们现在都知道FWT怎么用。 FWT(A)_{i} = \sum_{j} f_{i, j} a_{i}.其中f_{i, j}是一个线性变换。 FWT(A)_{i} \times FWT(B)_{i} = \sum_{x} f_{i, x} a_{x} \sum_{y} f_{i, y} b_{y}= \sum_{x} \sum_{y} f_{i, x} f_{i, y} a_{x} b_{y}= \sum_{t} \sum_{x, y, x \otimes y = t} f_{i, x} f_{i, y} a_{x} b_{y}= \sum_{t} \sum_{x, y, x \otimes y = t} f_{i, x} f_{i, y} c_{t}= \sum_{t} f_{i, t} c_{t}.所以有我们去构造一个线性变换满足： f_{i, x} f_{i, y} = f_{i, x \otimes y}.我们观察这样一个式子： {(-1)}^{|i and j|}其中$|x|$表示二进制$x$中1的个数奇偶性。这个式子恰好满足我们要的线性变换。 |i and k| \otimes |j and k| = |(j \otimes i) and k|.言归正传我们继续观察怎样计算$count(x)$。我们可以这样写 count(x) = \frac{ \sum_{i = 1}^{n} \prod_{j = 1}^{m} (1 - {(-1)}^{|a_{i, j} and x|})}{2^m}我们去讨论分子部分。 \prod_{j = 1}^{m} (1-{(-1)}^{|a_{i, j} and x|})= 1 - \sum_{j = 1}^{m} {(-1)}^{|a_{i, j} and x|} + \sum_{j, k, j \neq k}^{m}...对于$-1$来说，我们发现 {(-1)}^{i+j} = {(-1)}^{i \otimes j}.所以上式可以被我们变成FWT： count(x) = \frac{ \sum_{i=1}^{n} \sum_{j=0}^{2^m-1} {(-1)}^{popcount(j)} FWT(f_{i})_{x}}{2^m}.Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 20;ll f[(1 &lt;&lt; 20) + 5];const ll mod = 1e9 + 7;int a[15];int n, m, k;ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125; void dfs(int p, int now, int q)&#123; if (p &gt; m) &#123; f[now] += q; return; &#125; dfs(p + 1, now ^ a[p], -q); dfs(p + 1, now, q);&#125;/*void fwt(ll a[],int m)&#123; int n = __builtin_ctz(m); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; if(j&amp;(1&lt;&lt;i)) &#123; int l = a[j^(1&lt;&lt;i)]; int r = a[j]; a[j^(1&lt;&lt;i)] = (l+r)%mod; a[j] = (l-r+mod)%mod; &#125; &#125; &#125;&#125;*/void FWT_xor(ll *a, int n, int opt)&#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) for (int k = 0; k &lt; i; ++k) &#123; ll X = a[j + k], Y = a[i + j + k]; a[j + k] = X + Y; a[i + j + k] = X - Y; if (opt == -1) a[j + k] = 1ll * a[j + k] / 2, a[i + j + k] = 1ll * a[i + j + k] / 2; &#125;&#125; int main()&#123; while (scanf("%d%d%d", &amp;n, &amp;m, &amp;k)!= EOF) &#123; for (int i = 0 ; i &lt;= (1 &lt;&lt; k) - 1; i++) f[i] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) scanf("%d", &amp;a[j]); dfs(1, 0, 1); &#125; FWT_xor(f, 1 &lt;&lt; k, 1); ll ans = 0, base = 1, inv = Pow(1 &lt;&lt; m, mod - 2); for (int i = 0; i &lt; (1 &lt;&lt; k); i++) &#123; ans = ans ^ (inv * base % mod * f[i] % mod); base = base * 3ll % mod; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rikka with Mista]]></title>
    <url>%2F2019%2F08%2F22%2FRikka-with-Mista%2F</url>
    <content type="text"><![CDATA[题目链接题意一个人有$n$张牌，每张牌$i$正面有w_{i}，反面有$0$，没面概率是\frac{1}{2}。现在所有牌随意摆放，朝上面的数字求和为$S$，记录$S$的十进制表示中$4$的个数。问所有摆放方式的和为多少。 思路计算贡献，每一位为$4$的方案数都计算出来，然后双指针扫一下。关键这个基数排序，比我原来做法少一个$\log$，我觉得其思想我好像还没掌握？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;#define fi first#define se second#define mp make_pair#define pb push_backconst int N=50;int n,w[N];struct atom&#123; long long l,r;&#125;;vector&lt;atom&gt;x,y,A[10],B[10];void solve(int k1,int lim,long long sum,vector&lt;atom&gt;&amp;x)&#123; if (k1&gt;lim)&#123; x.push_back((atom)&#123;sum,0&#125;); return; &#125; solve(k1+1,lim,sum,x); solve(k1+1,lim,sum+w[k1],x);&#125;long long get0(vector&lt;atom&gt;&amp;A,vector&lt;atom&gt;&amp;B,long long lim)&#123; int now=B.size()-1; long long ans=0; for (int i=0;i&lt;A.size();i++)&#123; while (now&gt;=0&amp;&amp;B[now].r+A[i].r&gt;=lim) now--; ans+=now+1; &#125; return ans;&#125;long long get1(vector&lt;atom&gt;&amp;A,vector&lt;atom&gt;&amp;B,long long lim)&#123; int now=0; long long ans=0; for (int i=A.size();i;i--)&#123; while (now&lt;B.size()&amp;&amp;B[now].r+A[i-1].r&lt;lim) now++; ans+=B.size()-now; &#125; return ans;&#125;void solve()&#123; scanf("%d",&amp;n); for (int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); //n=40; //for (int i=1;i&lt;=n;i++) w[i]=rand()%1000000000+1; int mid=n/2; x.clear(); y.clear(); solve(1,mid,0,x); solve(mid+1,n,0,y); long long ans=0; long long base=1; for (int t=1;t&lt;=12;t++)&#123; for (int i=0;i&lt;10;i++) A[i].clear(),B[i].clear(); for (int i=0;i&lt;x.size();i++) A[x[i].l%10].push_back((atom)&#123;x[i].l/10,x[i].r&#125;); for (int i=0;i&lt;y.size();i++) B[y[i].l%10].push_back((atom)&#123;y[i].l/10,y[i].r&#125;); for (int i=0;i&lt;10;i++)&#123; int k1=(14-i)%10,k2=(13-i)%10; ans+=get0(A[i],B[k1],base)+get1(A[i],B[k2],base); &#125; int now=0; for (int i=0;i&lt;10;i++)&#123; long long ex=i*base; for (int j=0;j&lt;A[i].size();j++) x[now++]=(atom)&#123;A[i][j].l,A[i][j].r+ex&#125;; &#125; now=0; for (int i=0;i&lt;10;i++)&#123; long long ex=i*base; for (int j=0;j&lt;B[i].size();j++) y[now++]=(atom)&#123;B[i][j].l,B[i][j].r+ex&#125;; &#125; base*=10; &#125; printf("%lld\n",ans);&#125;int main()&#123; int t; scanf("%d",&amp;t); for (;t;t--) solve(); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>超大背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome Party]]></title>
    <url>%2F2019%2F08%2F22%2FWelcome-Party%2F</url>
    <content type="text"><![CDATA[题目链接题意有$n$个人，每个人都有两个属性，现在要选出若干个人使用第一属性，其余人使用第二属性。使第一属性最大值和第二属性的最大值差的绝对值最小。 思路很容易想到枚举每一个人作为第一属性的能力值最高的人，那么那些第一属性比他高的人都去发挥第二属性，我们维护这批人的第二属性最大值（因为这批人只会往里面添加，不会减少）。我们还可以在其余人里选出一些发挥第二属性，很容易发现选第二属性接近我们当前枚举的人的第一属性的人。那么实现上就只需要一个能维护插入元素的前驱和后继并快速删除的数据结构。如，treap，pbds，splay等。牢牢记住这些东西删除重复元素是全部删除的！！！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endifconst int N = 1e5 + 5;namespace Treap&#123;#define ls(x) treap[x].child[0]#define rs(x) treap[x].child[1] struct node &#123; int child[2], size; ll val; unsigned key; &#125;treap[N]; /* ll seed = 17124057; ll Rand() &#123; return seed = seed * 48271 % 2147483647; &#125;*/ mt19937 rd(time(0)); unsigned Rand[20]; void rand_init() &#123; for (int i = 0; i &lt; 20; i++) Rand[i] = rd(); &#125; int cur; inline void init(int &amp;rt) &#123; rt = cur = 0; rand_init(); ls(0) = rs(0) = 0; treap[0].size = 0; treap[0].val = 0; &#125; void dfs(int root) &#123; dbg(root, ls(root), rs(root)); if (ls(root)) dfs(ls(root)); if (rs(root)) dfs(rs(root)); &#125; inline void pushup(int root) &#123; treap[root].size = treap[ls(root)].size + treap[rs(root)].size + 1; &#125; void split(int root, int &amp;x, int &amp;y, ll v) &#123; if (!root) &#123; x = 0; y = 0; return; &#125; if (treap[root].val &lt;= v) &#123; x = root; split(rs(root), rs(x), y, v); &#125; else &#123; y = root; split(ls(root), x, ls(y), v); &#125; pushup(root); &#125; void merge(int &amp;root, int x, int y) &#123; if (!x || !y) &#123; root = x + y; return; &#125; if (treap[x].key &lt;= treap[y].key) &#123; root = x; merge(rs(root), rs(x), y); &#125; else &#123; root = y; merge(ls(root), x, ls(y)); &#125; pushup(root); &#125; void split_by_rank(int root, int &amp;x, int &amp;y, int k) &#123; //dbg(root, k); if (!root) &#123; x = y = 0; return; &#125; if (treap[ls(root)].size + 1 &lt;= k) &#123; x = root; split_by_rank(rs(root), rs(x), y, k - treap[ls(root)].size - 1); &#125; else &#123; y = root; split_by_rank(ls(root), x, ls(y), k); &#125; pushup(root); &#125; inline unsigned get_rd(int id) &#123; unsigned now = 0; for (int i = 0; i &lt; 20; i++) if (id &amp; (1 &lt;&lt; i)) now ^= Rand[i]; return now; &#125; inline void insert(int &amp;root, ll v) &#123; int x = 0, y = 0, z = ++cur; treap[z].val = v; ls(z) = rs(z) = 0; treap[z].size = 1; treap[z].key = get_rd(cur); split(root, x, y, v); merge(x, x, z); merge(root, x, y); &#125; inline void del(int &amp;root, ll v) &#123; //dbg("del which val is ", v); int x = 0, y = 0, z = 0; split(root, x, y, v); int rk = treap[x].size; split_by_rank(x, x, z, rk - 1); //dbg(z, treap[z].size, treap[z].val); assert(treap[z].size == 1); //dfs(x); //dfs(y); //dfs(z); merge(root, x, y); &#125; inline pair&lt;int, int&gt; lower_bound(int &amp;root, ll v) &#123; //dbg("ask near to ", v); int x = 0, y = 0; split(root, x, y, v - 1); int now = y; while (ls(now)) now = ls(now); int nnow = x; while (rs(nnow)) nnow = rs(nnow); merge(root, x, y); // dbg(nnow, now, treap[nnow].val, treap[now].val); return make_pair(nnow, now); &#125; int rt;&#125; //namespace Treapstruct Node&#123; ll x, y;&#125;arr[N];bool cmp(Node x, Node y)&#123; if (x.x == y.x) return x.y &lt; y.y; return x.x &gt; y.x;&#125;/*int main()&#123; Treap::init(Treap::rt); Treap::insert(Treap::rt, 14); Treap::insert(Treap::rt, 87); Treap::insert(Treap::rt, 9); Treap::insert(Treap::rt, 47); Treap::insert(Treap::rt, 36); Treap::dfs(Treap::rt); Treap::del(Treap::rt, 14); Treap::del(Treap::rt, 87); return 0;&#125;*/int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld%lld", &amp;arr[i].x, &amp;arr[i].y); arr[i].x += 1; arr[i].y += 1; &#125; sort(arr + 1, arr + n + 1, cmp); Treap::init(Treap::rt); ll maxi = -5e18; for (int i = 1; i &lt;= n; i++) &#123; Treap::insert(Treap::rt, arr[i].y); //dbg(i, arr[i].x, arr[i].y); &#125; ll ans = 5e18; for (int i = 1; i &lt;= n; i++) &#123; Treap::del(Treap::rt, arr[i].y); if (maxi &gt;= arr[i].x) &#123; ans = min(ans, maxi - arr[i].x); &#125; else&#123; pair&lt;int, int&gt; p = Treap::lower_bound(Treap::rt, arr[i].x); int pre = p.first, suf = p.second; //dbg(pre, suf, Treap::treap[pre].val, Treap::treap[suf].val, maxi); if (suf) ans = min(ans, abs(max(maxi, Treap::treap[suf].val) - arr[i].x)); if (pre) &#123; ans = min(ans, abs(max(maxi, Treap::treap[pre].val) - arr[i].x)); &#125; //dbg(ans); ans=min(ans,abs(maxi-arr[i].x)); &#125; maxi=max(maxi,arr[i].y); &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure Problem]]></title>
    <url>%2F2019%2F08%2F17%2FData-Structure-Problem%2F</url>
    <content type="text"><![CDATA[题目链接题意要求实现一种数据结构，能够：插入一个二元点对删除还存在的第$r$个点对查询现有数据结构中两个二元点对点积最小 思路首先点积无论最大还是最小一定在凸包上（证明待补?).由于数据随机，凸包上的店的个数期望是$log(n)$个，所以删除一个点的概率是\frac{log(n)}{n}.我们维护这个凸包，如果删除了这上面的元素，我们就暴力重建凸包。还有一个数据结构维护已插入的点，如平衡树。存档凸包模板。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endifconst int N = 1e6 + 5;int X[N], Y[N];namespace Treap&#123; ll seed = 17124057; #define ls(x) treap[x].child[0] #define rs(x) treap[x].child[1] int cur = 0; ll Rand() &#123; return seed = seed * 48271 % 2147483647; &#125; int rt; void init() &#123; rt = cur = 0; &#125; struct node &#123; int val, key, child[2], size; &#125;treap[N]; void pushup(int root) &#123; treap[root].size = treap[ls(root)].size + treap[rs(root)].size + 1; &#125; void split(int root, int&amp; x, int&amp; y, int val) &#123; if (!root) &#123; x = y = 0; return; &#125; if (treap[root].val &lt;= val) &#123; x = root; split(rs(root), rs(x), y, val); &#125; else &#123; y = root; split(ls(root), x, ls(y), val); &#125; pushup(root); &#125; void merge(int &amp;root, int x, int y) &#123; if (!x || !y) &#123; root = x + y; return; &#125; if (treap[x].key &lt; treap[y].key) &#123; root = x; merge(rs(root), rs(x), y); &#125; else &#123; root = y; merge(ls(root), x, ls(y)); &#125; pushup(root); &#125; void insert(int&amp; root, int val) &#123; int x = 0, y = 0, z = ++cur; treap[z].val = val; treap[z].size = 1; ls(z) = rs(z) = 0; treap[z].key = Rand(); split(root, x, y, val); merge(x, x, z); merge(root, x, y); &#125; void del(int&amp; root, int val) &#123; int x = 0, y = 0, z = 0; split(root, x, y, val); split(x, x, z, val - 1); merge(z, ls(z), rs(z)); merge(x, x, z); merge(root, x, y); &#125; int query_rank(int&amp; root, int val) &#123; int x = 0, y = 0; split(root, x, y, val - 1); int ans = treap[x].size + 1; merge(root, x, y); return ans; &#125; int query_value(int root, int rnk) &#123; while (treap[ls(root)].size + 1 != rnk) &#123; if (treap[ls(root)].size &gt;= rnk) &#123; root = ls(root); &#125; else &#123; rnk -= treap[ls(root)].size + 1; root = rs(root); &#125; &#125; return treap[root].val; &#125; int pre_val(int&amp; root, int val) &#123; int x = 0, y = 0; split(root, x, y, val - 1); int ans, tmp = x; while (rs(tmp)) tmp = rs(tmp); ans = treap[tmp].val; merge(root, x, y); return ans; &#125; int suf_val(int&amp; root, int val) &#123; int x = 0, y = 0; split(root, x, y, val); int ans, tmp = y; while (ls(tmp)) tmp = ls(tmp); ans = treap[tmp].val; merge(root, x, y); return ans; &#125;&#125;//namespace Treapnamespace ConvexHull&#123; struct point &#123; int x, y; int id; point(int _x = 0, int _y = 0, int _id = 0): x(_x), y(_y), id(_id) &#123;&#125; bool operator &lt; (const point &amp;v) const &#123; return x &lt; v.x || (x == v.x &amp;&amp; y &lt; v.y); &#125; point operator - (const point &amp;v) const &#123; return point(x - v.x, y - v.y); &#125; &#125;; inline ll cross (const point&amp; a, const point&amp; b, const point&amp; c) &#123; point p = a - c, q = b - c; return 1ll * p.x * q.y - 1ll * p.y * q.x; &#125; vector&lt;int&gt; arr; void clear() &#123; arr.clear(); &#125; void go() &#123; vector&lt;point&gt; s; for (auto &amp;i : arr) s.push_back(point(X[i], Y[i], i)); if ((int)s.size() &gt; 2) &#123; sort(s.begin(), s.end()); vector&lt;point&gt; ret(s.size() * 2); int sz = 0; for (int i = 0; i &lt; s.size(); i++) &#123; while (sz &gt; 1 &amp;&amp; cross(ret[sz - 1], s[i], ret[sz - 2]) &lt; 0) sz--; ret[sz++] = s[i]; &#125; int k = sz; for (int i = (ll)s.size() - 2; i &gt;= 0; i--) &#123; while (sz &gt; k &amp;&amp; cross(ret[sz - 1], s[i], ret[sz - 2]) &lt; 0) sz--; ret[sz++] = s[i]; &#125; ret.resize(sz - ((int)s.size() &gt; 1)); s = ret; &#125; arr.clear(); for (auto &amp;p : s) arr.push_back(p.id); &#125; void insert(int index) &#123; arr.push_back(index); go(); &#125; void dfs(int rtt) &#123; if (!rtt) return; arr.push_back(Treap::treap[rtt].val); dfs(Treap::ls(rtt)); dfs(Treap::rs(rtt)); &#125; void erase(int index) &#123; if (find(arr.begin(), arr.end(), index) != arr.end()) &#123; dbg("found on hull"); arr.clear(); dfs(Treap::rt); go(); &#125; &#125;&#125;//namespace ConvexHullconst unsigned mul = 20190812;class Magic &#123;public: Magic(unsigned state): state(state), ans(0) &#123;&#125; unsigned long long retrieve() &#123; unsigned modulo = 0x7fffffff; state = ((unsigned long long) state * mul + ans) % modulo; unsigned high = state; state = ((unsigned long long) state * mul + ans) % modulo; return high * modulo + state; &#125; int retrieve(int a, int b) &#123; assert (a &lt;= b); return (int) (retrieve() % (b - a + 1)) + a; &#125; void submit(unsigned k) &#123; ans = ans * mul + k; &#125; unsigned retrieveAns() &#123; return ans; &#125;private: unsigned state, ans;&#125;;class DataStructure &#123;public: DataStructure() &#123; // The data structure is initially empty, until it's not. // Implement your initialization here. index = 0; ConvexHull::clear(); Treap::init(); &#125; void add(int x, int y) &#123; // Add a 2D point (x, y) to the DS. // Implement your add here. index++; dbg("add", index, x, y); X[index] = x; Y[index] = y; Treap::insert(Treap::rt, index); ConvexHull::insert(index); &#125; void erase(int r) &#123; // Erase the r-th added point, of all the points that // have still not been erased. // Implement your erase here. dbg("erase", r); assert(Treap::cur != 0); r = Treap::query_value(Treap::rt, r); Treap::del(Treap::rt, r); ConvexHull::erase(r); &#125; int size() &#123; // Return how many points are still in the DS return Treap::treap[Treap::rt].size; &#125; pair&lt;unsigned, unsigned&gt; query() &#123; // find two points p_i, p_j in the DS (not necessarily distinct), // such that the dot product of these two &lt;p_i, p_j&gt; (i &lt;= j) // the smallest among all. Return (i, j). // If the DS is empty for now, return (0, 0). // Implement your query here. // If there are multiple (i, j) satisfying the condition, output the lexicographically smallest pair. ll ans = 9E18; pair&lt;unsigned, unsigned&gt; best = &#123;0, 0&#125;; for (auto &amp;i : ConvexHull::arr) for (auto &amp;j : ConvexHull::arr) &#123; ll dot_product = 1ll * X[i] * X[j] + 1ll * Y[i] * Y[j]; if (dot_product &lt; ans) &#123; ans = dot_product; best = &#123;i, j&#125;; &#125; &#125; if (best.first &gt; best.second) swap(best.first, best.second); return best; &#125;private: int index;&#125;;template &lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;char s[N];int main() &#123; const int lim = 1E9; int q; read(q); for (int k = 0; k &lt; q; ++k) &#123; unsigned state; read(state); scanf("%s", s); int len = strlen(s); DataStructure ds; Magic magic(state); for (int i = 0; i &lt; len; i++) &#123; char c = s[i]; if (c == 'a') &#123; // add one point int x = magic.retrieve(-lim, lim); int y = magic.retrieve(-lim, lim); ds.add(x, y); &#125; else if (c == 'e') &#123; // select the lucky point unsigned pos = magic.retrieve(1, ds.size()); ds.erase((int)pos); &#125; else if (c == 'q') &#123; // query global minimum auto best = ds.query(); magic.submit(best.first); magic.submit(best.second); &#125; &#125; printf("%u\n", magic.retrieveAns()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>凸包</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Calabash and Landlord]]></title>
    <url>%2F2019%2F08%2F17%2FCalabash-and-Landlord%2F</url>
    <content type="text"><![CDATA[题目链接思路求两个矩形分割平面多少块。这是一个套路嘛？？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50#define MAXN 55struct Node&#123; int l, t, r, b; int x1, x2, y1, y2;&#125;node[MAXN];int dir[4][2] = &#123;1, 0, 0, 1, -1, 0, 0, -1&#125;;int tempx[2 * MAXN], tempy[2 * MAXN];bool vis[2 * MAXN][2 * MAXN];bool visx[2 * MAXN][2 * MAXN], visy[2 * MAXN][2 * MAXN];int tx, ty, n;bool check(int x, int y, int xt, int yt)&#123; bool flag = true; if (x == xt) &#123; int yc = max(y, yt); for (int i = 0; i &lt; n; i++) &#123; if (yc == node[i].y1 || yc == node[i].y2) &#123; if (node[i].x1 &lt;= x &amp;&amp; x + 1 &lt;= node[i].x2) &#123; flag = false; break; &#125; &#125; &#125; &#125; else &#123; int xc = max(x, xt); for (int i = 0; i &lt; n; i++) &#123; if (xc == node[i].x1 || xc == node[i].x2) &#123; if (node[i].y1 &lt;= y &amp;&amp; y + 1 &lt;= node[i].y2) &#123; flag = false; break; &#125; &#125; &#125; &#125; return flag;&#125;bool check2(int x, int y, int d)&#123; if (d == 0) &#123; return !visy[x + 1][y]; &#125; else if (d == 2) &#123; return !visy[x][y]; &#125; else if (d == 3) &#123; return !visx[x][y]; &#125; else &#123; return !visx[x][y + 1]; &#125;&#125;void dfs(int x, int y)&#123; vis[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int xt = x + dir[i][0], yt = y + dir[i][1]; if (xt &gt;= 0 &amp;&amp; xt &lt;= tx &amp;&amp; yt &gt;= 0 &amp;&amp; yt &lt;= ty) &#123; if (check2(x, y, i) &amp;&amp; !vis[xt][yt]) &#123; dfs(xt, yt); &#125; &#125; &#125;&#125;void input()&#123; n=2; tx = ty = 0; for (int i = 0; i &lt; n; i++) &#123; int tmp[4]; scanf("%d%d%d%d",&amp;tmp[0],&amp;tmp[1],&amp;tmp[2],&amp;tmp[3]); node[i].l=tmp[0]; node[i].t=tmp[3]; node[i].r=tmp[2]; node[i].b=tmp[1]; tempx[tx++] = node[i].l; tempx[tx++] = node[i].r; tempy[ty++] = node[i].t; tempy[ty++] = node[i].b; &#125; sort(tempx, tempx + tx); sort(tempy, tempy + ty); tx = unique(tempx, tempx + tx) - tempx; ty = unique(tempy, tempy + ty) - tempy; int x1, y1, x2, y2; memset(visx, false, sizeof(visx)); memset(visy, false, sizeof(visy)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; tx; j++) &#123; if (node[i].l == tempx[j]) &#123; x1 = j + 1; &#125; if (node[i].r == tempx[j]) &#123; x2 = j + 1; &#125; &#125; for (int j = 0; j &lt; ty; j++) &#123; if (node[i].t == tempy[j]) &#123; y2 = j + 1; &#125; if (node[i].b == tempy[j]) &#123; y1 = j + 1; &#125; &#125; node[i].x1 = x1, node[i].x2 = x2, node[i].y1 = y1, node[i].y2 = y2; for (int j = x1; j &lt;= x2 - 1; j++) &#123; visx[j][y1] = visx[j][y2] = true; &#125; for (int j = y1; j &lt;= y2 - 1; j++) &#123; visy[x1][j] = visy[x2][j] = true; &#125; &#125; memset(vis, false, sizeof(vis)); int ans = 0; for (int i = 0; i &lt;= tx; i++) &#123; for (int j = 0; j &lt;= ty; j++) &#123; if (!vis[i][j]) &#123; dfs(i, j); ans++; &#125; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; //freopen("C.in", "r", stdin); //freopen("out.txt", "w", stdout); int t; scanf("%d",&amp;t); while(t--) input(); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>矩形分割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Knapsack Cryptosystem]]></title>
    <url>%2F2019%2F08%2F17%2FKnapsack-Cryptosystem%2F</url>
    <content type="text"><![CDATA[题目链接题意有一个数列，现在要求你找出一个集合，使得数字之和为$s$。 思路超大背包裸题。记录自己超大背包签到失败的耻辱。既然物品数量不多，那我们可以二进制枚举选择的物品，但是还是太慢啦。我们换一种方式，可以折半枚举一部分物品，另一半我们去凑那个和。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endifconst int N = 40;map&lt;ll, int&gt; mp;ll dp[1 &lt;&lt; 20];ll arr[N];int main()&#123; int n; ll s; scanf("%d%lld", &amp;n, &amp;s); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;arr[i]); &#125; if (n == 1) &#123; if (s == 0) puts("0"); else puts("1"); return 0; &#125; if (s == 0) &#123; for (int i = 1; i &lt;= n; i++) printf("0"); putchar('\n'); return 0; &#125; int x = n / 2 + 1; int up = (1 &lt;&lt; x); for (int i = 0; i &lt; up; i++) &#123; for (int j = 0; j &lt; x; j++) &#123; if (i &amp; (1 &lt;&lt; j)) dp[i] += arr[j + 1]; &#125; &#125; int upp = (1 &lt;&lt; (n - x)); for (int i = 0; i &lt; upp; i++) &#123; ll sum = 0; for (int j = 0; j &lt; n - x; j++) &#123; if (i &amp; (1 &lt;&lt; j)) sum += arr[j + x + 1]; &#125; mp[sum] = i; &#125; for (int i = 0; i &lt; up; i++) &#123; if (s &lt; dp[i]) &#123; continue; &#125; if (s == dp[i]) &#123; for (int j = 0; j &lt; x; j++) &#123; if (i &amp; (1 &lt;&lt; j)) putchar('1'); else putchar('0'); &#125; for (int j = x; j &lt; n; j++) putchar('0'); return 0; &#125; if (mp.find(s - dp[i]) != mp.end()) &#123; int tmp = mp[s - dp[i]]; for (int j = 0; j &lt; x; j++) &#123; if (i &amp; (1 &lt;&lt; j)) putchar('1'); else putchar('0'); &#125; for (int j = 0; j &lt; n - x; j++) &#123; if (tmp &amp; (1 &lt;&lt; j)) putchar('1'); else putchar('0'); &#125; putchar('\n'); return 0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>超大背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quadratic equation]]></title>
    <url>%2F2019%2F08%2F17%2FQuadratic-equation%2F</url>
    <content type="text"><![CDATA[题目链接题意已知$b,c$,计算x,y(0 \leq x \leq y \leq p)，满足 (x+y)mod p=b(x \times y) mod p = c思路{(x+y)}^{2} = x^2+y^2+2xy.{(x-y)}^{2} = x^2+y^2-2xy=b^2-4c.所以这题主要就让你解一个{(x-y)}^2 \equiv b^2-4c modp。二次剩余模板：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endifconst ll mo = 1e9 + 7;const ll mod = mo;ll ksm(ll k,ll n)&#123; ll s=1; for(;n;n&gt;&gt;=1,k=k*k%mo) if(n&amp;1) s=s*k%mo; return s;&#125; namespace number&#123; ll D; struct Z &#123; ll x,y; Z(ll _x=0,ll _y=0)&#123;x=_x,y=_y;&#125; &#125;; Z operator +(const Z &amp;x,const Z &amp;y) &#123;return Z((x.x+y.x)%mo,(x.y+y.y)%mo);&#125; Z operator -(const Z &amp;x,const Z &amp;y) &#123;return Z((x.x-y.x+mo)%mo,(x.y-y.y+mo)%mo);&#125; Z operator *(const Z &amp;x,const Z &amp;y) &#123;return Z((x.x*y.x%mo+D*x.y%mo*y.y%mo+mo)%mo,(x.y*y.x%mo+x.x*y.y%mo)%mo);&#125; Z opt(const Z &amp;x) &#123;return Z(mo-x.x,mo-x.y);&#125; Z pwr(Z k,ll n) &#123; Z s=Z(1,0); for(;n;n&gt;&gt;=1,k=k*k) if(n&amp;1) s=s*k; return s; &#125;&#125;using namespace number;//其实这部分像减法，相反数什么的都没什么用... pair&lt;ll,ll&gt; cipolla(ll k)&#123; k%=mo; if(ksm(k,(mo-1)/2)==mo-1) return make_pair(-1,-1); if(k==0) return make_pair(0,0); ll a=rand()%mo; while(ksm((a*a%mo-k+mo)%mo,(mo-1)/2)&lt;=1) a=rand()%mo; D=(a*a%mo-k+mo)%mo; ll v=(pwr(Z(a,1),(mo+1)/2)).x; return make_pair(v,mo-v);&#125; int main()&#123; int T; scanf("%d", &amp;T); ll inv2 = (mod + 1) / 2; while (T--) &#123; ll b, c; scanf("%lld%lld", &amp;b, &amp;c); ll tmp = b * b % mod - c * 4 % mod; tmp = (tmp + mod) % mod; pair&lt;ll, ll&gt; f = cipolla(tmp); if (f.first == -1) &#123; puts("-1 -1"); continue; &#125; ll xsuby = f.first; ll x = (b + xsuby) % mod * inv2 % mod; ll y = (b - x + mod) % mod; if (x &gt; y) swap(x, y); printf("%lld %lld\n", x, y); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>二次剩余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string matching]]></title>
    <url>%2F2019%2F08%2F07%2Fstring-matching%2F</url>
    <content type="text"><![CDATA[题目链接题意计算一个字符串与他各个后缀的最长公共前缀。 思路扩展kmp模板题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e6 + 5;int Next[N],extend[N];void getNext(char str[])&#123; int i=0,j,po,len=strlen(str); Next[0]=len; while(str[i]==str[i+1] &amp;&amp; i+1&lt;len) i++; Next[1]=i; po=1; for(i=2;i&lt;len;i++) &#123; if(Next[i-po]+i &lt; Next[po]+po) Next[i]=Next[i-po]; else &#123; j = Next[po]+po-i; if(j&lt;0) j=0; while(i+j&lt;len &amp;&amp; str[j]==str[j+i]) j++; Next[i]=j; po=i; &#125; &#125;&#125;void EXKMP(char s1[],char s2[])&#123; int i=0,j,po,len=strlen(s1),l2=strlen(s2); getNext(s2); while(s1[i]==s2[i] &amp;&amp; i&lt;l2 &amp;&amp; i&lt;len) i++; extend[0]=i; po=0; for(i=1;i&lt;len;i++) &#123; if(Next[i-po]+i &lt; extend[po]+po) extend[i]=Next[i-po]; else &#123; j = extend[po]+po-i; if(j&lt;0) j=0; while(i+j&lt;len &amp;&amp; j&lt;l2 &amp;&amp; s1[j+i]==s2[j]) j++; extend[i]=j; po=i; &#125; &#125;&#125;char s[N];int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%s", s); memset(extend, 0, sizeof(extend)); memset(Next, 0, sizeof(Next)); EXKMP(s, s); ll ans = 0; int len = strlen(s); for (int i = 1; i &lt; len; i++) &#123; if (extend[i] &lt; len - i) ans += extend[i] + 1; else ans += extend[i]; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>exkmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[permutation 2]]></title>
    <url>%2F2019%2F08%2F07%2Fpermutation-2%2F</url>
    <content type="text"><![CDATA[题目链接题意计算有多少种n的全排列，每两项之间的差绝对值都小于等于2，且第一个元素和最后一个元素分别为a,b。 思路略微观察容易发现，1到a和b到n的元素位置其实只有一种可能，都是确定了的。（在纸上画一画就发现，如果这两边不先走，是构不成全排列的。）那么我们要解决的就是中间这一段数字有多少种方法。如1,2,3,4，其实只有两种走法，要么一个一个走，即1,2,3,4，要么1,3,2,4这样。可以推出一个简单的dp式子。 Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 5;const ll mod = 998244353;ll f[maxn];int main()&#123; int T; scanf("%d", &amp;T); f[1] = 1; f[2] = 1; f[3] = 1; for (int i = 4; i &lt;= maxn; i++) f[i] = (f[i - 1] + f[i - 3]) % mod; while (T--) &#123; int n, x, y; scanf("%d%d%d", &amp;n, &amp;x, &amp;y); int len = y - x + 1; if (x != 1) len--; if (y != n) len--; printf("%lld\n", f[len]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[permutation 1]]></title>
    <url>%2F2019%2F08%2F07%2Fpermutation-1%2F</url>
    <content type="text"><![CDATA[题目链接题意找出一个n的全排列，让其后向差分序列字典序最小。 思路1≤K≤min(10000,n!)，注意到这一点，我们可以知道当n大于8的时候，我们前面几项应该是n,1,2,3,4,…直到最后八项。最后八项怎么确定呢，看到这个k范围很小，不妨枚举出所有全排列，然后排个序去找第k大。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) \ do \ &#123; \ cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;"; \ err(x); \ &#125; while (0)void err()&#123; cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template &lt;template &lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123; for (auto v : a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template &lt;typename T, typename... A&gt;void err(T a, A... x)&#123; cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endifconst int N = 25;const int maxn = 100005;int arr[maxn][25];int cha[maxn][25];int id[maxn];int fac[10];int a[N];bool cmp1(int x, int y)&#123; for (int i = 1;; i++) &#123; if (cha[x][i] &lt; cha[y][i]) return true; if (cha[x][i] &gt; cha[y][i]) return false; &#125; return false;&#125;int main()&#123; int T; fac[0] = 1; for (int i = 1; i &lt;= 8; i++) fac[i] = fac[i - 1] * i; scanf("%d", &amp;T); while (T--) &#123; int n, k; scanf("%d%d", &amp;n, &amp;k); int state = 0; int res = n; int pre = -1; if (n &gt; 8) &#123; printf("%d ", n); state |= 1 &lt;&lt; (n - 1), pre = n; for (int i = 1; n - i - 1 &gt;= 8; i++) printf("%d ", i), state |= 1 &lt;&lt; (i - 1), pre = i; res = 8; &#125; int cur = 0; for (int i = 0; i &lt; n; i++) &#123; if (!((1 &lt;&lt; i) &amp; state)) a[cur++] = i + 1; &#125; for (int i = 1; i &lt;= fac[res]; i++) &#123; id[i] = i; &#125; int t = 0; if (pre == -1) &#123; do &#123; t++; for (int i = 0; i &lt; cur; i++) arr[t][i] = a[i]; &#125; while (next_permutation(a, a + cur)); for (int i = 1; i &lt;= fac[res]; i++) &#123; for (int j = 1; j &lt; res; j++) cha[i][j] = arr[i][j] - arr[i][j - 1]; &#125; sort(id + 1, id + fac[res] + 1, cmp1); /* puts("askjdal"); for (int i = 1; i &lt;= fac[res]; i++) &#123; for (int j = 0; j &lt; res; j++) printf("%d ", arr[id[i]][j]); putchar('\n'); &#125; //puts("ajksdfhajkhdfj");*/ for (int i = 1; i &lt;= res; i++) printf("%d%c", arr[id[k]][i - 1], i == res ? '\n' : ' '); &#125; else &#123; do &#123; t++; arr[t][0] = pre; for (int i = 0; i &lt; cur; i++) arr[t][i + 1] = a[i]; &#125; while (next_permutation(a, a + cur)); for (int i = 1; i &lt;= fac[res]; i++) &#123; for (int j = 1; j &lt;= res; j++) cha[i][j] = arr[i][j] - arr[i][j - 1]; &#125; sort(id + 1, id + fac[res] + 1, cmp1); for (int i = 1; i &lt;= res; i++) printf("%d%c", arr[id[k]][i], i == res ? '\n' : ' '); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equation]]></title>
    <url>%2F2019%2F08%2F07%2Fequation%2F</url>
    <content type="text"><![CDATA[题目链接题意有数列$a$和$b$，计算有多少个$x$满足 \sum_{i=1}^{N} |a_{i} \times x +b_{i}| = C.思路若a_{i} \times x + b_{i} > 0，则有x > - \frac{b_{i} }{a_{i}}。我们对这个式子排序然后不断变换$x$的范围看这个解是否合理。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endifconst int N = 1e3 + 5;inline ll gcd(ll a, ll b)&#123; if (a &lt; b) swap(a, b); while (b) &#123; ll t = a; a = b; b = t % b; &#125; return a;&#125;struct frac&#123; ll a, b; bool operator &lt; (const frac&amp; x) const &#123; return a * x.b &lt; b * x.a; &#125; bool operator &gt; (const frac&amp; x) const &#123; return a * x.b &gt; b * x.a; &#125; inline bool operator == (const frac&amp; x) const &#123; return a == x.a &amp;&amp; b == x.b; &#125; inline bool operator != (const frac&amp; x) const &#123; return !(*this == x); &#125; inline bool operator &gt;= (const frac&amp; x) const &#123; return *this &gt; x || *this == x; &#125; inline bool operator &lt;= (const frac&amp; x) const &#123; return *this &lt; x || *this == x; &#125; inline void pretty() &#123; ll g = gcd(abs(a), abs(b)); if (g) a /= g, b /= g; if (a * b &lt; 0) a = -abs(a), b = abs(b); else if (a &lt; 0 &amp;&amp; b &lt; 0) a = abs(a), b = abs(b); &#125; frac(ll _a=0, ll _b=1) &#123; a = _a, b = _b; pretty(); &#125; inline frac operator + (const frac&amp; x) const &#123; frac tmp = frac(); tmp.a = a * x.b + x.a * b; tmp.b = b * x.b; tmp.pretty(); return tmp; &#125; inline frac operator - (const frac&amp; x) const &#123; frac tmp = frac(); tmp.a = a * x.b - b * x.a; tmp.b = b * x.b; tmp.pretty(); return tmp; &#125; inline frac operator * (const frac&amp; x) const &#123; frac ret = frac(); ret.a = a * x.a; ret.b = b * x.b; ret.pretty(); return ret; &#125; inline frac operator / (const frac&amp; x) const &#123; frac ret = frac(); ret.a = a * x.b; ret.b = b * x.a; ret.pretty(); return ret; &#125; inline void print() &#123; if (a == 0) printf("0/1");// else if (b == 1)// printf("%lld\n", a); else printf("%lld/%lld", a, b); &#125;&#125;;struct node&#123; ll a, b; frac cmp; int id; bool operator &lt; (const node&amp; x) const &#123; return cmp &lt; x.cmp; &#125;&#125;a[100005];frac ans[200005];int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n, c; scanf("%d%d", &amp;n, &amp;c); ll sufa = 0, sufb = 0, prea = 0, preb = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld%lld", &amp;a[i].a, &amp;a[i].b); a[i].cmp = frac(-a[i].b, a[i].a); a[i].id = i; sufa += a[i].a; sufb += a[i].b; &#125; sort(a + 1, a + n + 1); int m = 0, f = 0, no = 0; if (sufa != prea) &#123; ll tmpa = prea - sufa; ll tmpb = c - (preb - sufb); ans[m++] = frac(tmpb, tmpa); if (ans[0] &gt;= a[1].cmp) m--; &#125; else &#123; if (c == preb - sufb) f = 1; else no = 1; &#125; /* for (int i = 1; i &lt;= n; i++) &#123; dbg(i);a[i].cmp.print();&#125; */ for (int i = 1; i &lt;= n; i++) &#123; // dbg(i, prea, sufa, preb, sufb); sufa -= a[i].a; sufb -= a[i].b; if (sufa != prea) &#123; ans[m++] = frac(c - (preb - sufb), prea - sufa); if (ans[m - 1] != a[i].cmp) m--; &#125; else &#123; if (c == preb - sufb) ans[m++] = a[i].cmp; &#125; prea += a[i].a; preb += a[i].b; //dbg(i, m); if (sufa != prea) &#123; ans[m++] = frac(c - preb + sufb, prea - sufa); if (ans[m - 1] &lt;= a[i].cmp || !(i == n || ans[m - 1] &lt; a[i + 1].cmp)) m--; &#125; else if (i &lt; n &amp;&amp; a[i].cmp != a[i + 1].cmp) &#123; if (c == preb - sufb) f = 1; else no = 1; break; &#125; &#125; if (f == 1) &#123; puts("-1"); continue; &#125; if (no) m = 0; printf("%d", m); sort(ans, ans + m); for (int i = 0; i &lt; m; i++) putchar(' '), ans[i].print(); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[three arrays]]></title>
    <url>%2F2019%2F08%2F07%2Fthree-arrays%2F</url>
    <content type="text"><![CDATA[题目链接题意打乱两个数列，对应位置异或产生一个新数列，使它字典序最小。 思路建两棵字典树，然后尽量走他们相同的边，这样异或出的数字尽量小，排一下序，让最小的在前面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;const int maxn = N * 2 * 25;int tot;int ch[maxn][2];int sum[maxn];int root1, root2;int newnode()&#123; tot++; for (int i = 0; i &lt; 2; i++) ch[tot][i] = 0; sum[tot] = 0; return tot;&#125;void insert(int root, int x)&#123; int cur = root; for (int p = 29; p &gt;= 0; p--) &#123; int t = (x &gt;&gt; p) &amp; 1; int u = ch[cur][t]; if (!u) &#123; ch[cur][t] = newnode(); u = ch[cur][t]; &#125; sum[cur]++; cur = u; &#125; sum[cur]++;&#125;int ans[N];int cnt;inline bool exist(int u)&#123; if (!u || sum[u] == 0) return false; return true;&#125;int query(int u, int v, int tmp1, int tmp2)&#123; if (!ch[u][0] &amp;&amp; !ch[u][1]) &#123; int s = min(sum[u], sum[v]); for (int i = 1; i &lt;= min(sum[u], sum[v]); i++) ans[++cnt] = tmp1 ^ tmp2; sum[u] -= s; sum[v] -= s; //dbg(sum[u], sum[v], tmp1, tmp2); return s; &#125; int s = 0; for (int i = 0; i &lt; 2; i++) &#123; if (exist(ch[u][i]) &amp;&amp; exist(ch[v][i])) &#123; //puts("same"); //dbg(tmp1, tmp2, i); int t = query(ch[u][i], ch[v][i], tmp1 &lt;&lt; 1 | i, tmp2 &lt;&lt; 1 | (i)); sum[u] -= t; sum[v] -= t; s += t; &#125; &#125; for (int i = 0; i &lt; 2; i++) &#123; if (exist(ch[u][i]) &amp;&amp; exist(ch[v][!i])) &#123; //puts("diff"); //dbg(tmp1, tmp2, i); int t = query(ch[u][i], ch[v][!i], tmp1 &lt;&lt; 1 | i, tmp2 &lt;&lt; 1 | (!i)); sum[u] -= t; sum[v] -= t; s += t; &#125; &#125; return s;&#125;int a[N], b[N];void init()&#123; tot = 0; root1 = newnode(); root2 = newnode(); cnt = 0;&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;b[i]); init(); for (int i = 1; i &lt;= n; i++) insert(root1, a[i]); for (int i = 1; i &lt;= n; i++) insert(root2, b[i]); assert(query(root1, root2, 0, 0) == n); sort(ans + 1, ans + n + 1); for (int i = 1; i &lt;= n; i++) printf("%d%c", ans[i], i == n? '\n': ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xor]]></title>
    <url>%2F2019%2F08%2F03%2Fxor%2F</url>
    <content type="text"><![CDATA[题目链接题意每次询问是否一个区间里的集合是否都能表示某一个元素。 思路每一个点都是一个线性基。题目的询问其实就是询问，是否这个区间的线性空间交能表示这个数字。线性空间求交模板题。注意查询的时候不需要真的全都交起来，可以直接在线段树上看可不可行，代替把整个区间内的交求出来多一个log。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50typedef unsigned int ui;const int N = 5e4 + 5;#define lson rt &lt;&lt; 1#define rson rt &lt;&lt; 1 | 1#define Lson L, mid, lson#define Rson mid + 1, R, rsonui base[N &lt;&lt; 4][33]; bool insert(int c, ui x)&#123; for (int i = 31; i &gt;= 0; i--) if ((x &gt;&gt; i) &amp; 1) &#123; //dbg(i, base[c][i], x); if (base[c][i]) &#123; x ^= base[c][i]; if (x == 0) return 1; &#125; else &#123; base[c][i] = x; return 0; &#125; &#125; return x == 0;&#125;int tot[33], tmp[33];void merge(int a, int b, int c)&#123; //puts("Merge!!!!!!"); //dbg(a, b, c); for(int i = 0; i &lt; 32; i++) &#123; //dbg(base[a][i]); tot[i] = base[a][i]; tmp[i] = base[a][i]; base[c][i] = 0; &#125; for(int i = 0; i &lt; 32; i++) if (base[b][i]) &#123; ui cur = base[b][i], add = 0; for (int j = i; j &gt;= 0; j--) if ((cur &gt;&gt; j) &amp; 1) &#123; //dbg(j, tot[j], cur, add, tmp[j]); if (tot[j]) &#123; cur ^= tot[j]; add ^= tmp[j]; //dbg(cur, add); if (!cur) &#123; base[c][i] = add; //dbg(base[c][i]); break; &#125; &#125; else &#123; tot[j] = cur; tmp[j] = add; break; &#125; &#125; &#125;&#125;int siz;void push_up(int rt)&#123; merge(lson, rson, rt);&#125; template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &lt; '0' || c &gt; '9'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125; void build(int L, int R, int rt)&#123; //dbg(L, R); if (L == R) &#123; for (int i = 31; i &gt;= 0; i--) base[rt][i] = 0; read(siz); for (int i = 1; i &lt;= siz; i++) &#123; ui x; read(x); insert(rt, x); &#125; /* for (int i = 31; i &gt;= 0; i--) &#123; if (base[rt][i]) dbg(rt, i, base[rt][i]); &#125; */ return; &#125; for (int i = 31; i &gt;= 0; i--) base[rt][i] = 1 &lt;&lt; i; int mid = (L + R) &gt;&gt; 1; build(Lson); build(Rson); push_up(rt);&#125; bool check(int a, ui x)&#123; for (int i = 0; i &lt; 32; i++) &#123; base[0][i] = base[a][i]; &#125; return insert(0, x);&#125; bool query(int l, int r, ui x, int L, int R, int rt)&#123; if (l &lt;= L &amp;&amp; r &gt;= R) &#123; return check(rt, x); &#125; int mid = (L + R) &gt;&gt; 1; bool ans = 1; if (l &lt;= mid) ans = ans &amp;&amp; query(l, r, x, Lson); if (r &gt; mid) ans = ans &amp;&amp; query(l, r, x, Rson); return ans;&#125; int main()&#123; int n, m; scanf("%d%d", &amp;n, &amp;m); build(1, n, 1); for (int q = 1; q &lt;= m; q++) &#123; int l, r; ui x; read(l); read(r); read(x); if (query(l, r, x, 1, n, 1)) puts("YES"); else puts("NO"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[subsequence 1]]></title>
    <url>%2F2019%2F08%2F03%2Fsubsequence-1%2F</url>
    <content type="text"><![CDATA[题目链接题意有两个字符串$S,T$，询问有多少个$S$的子序列比$T$串大。 思路$S$的长度比$T$大的一定大，所以可以先找出这样的子序列数量。若长度相等，那么一定从某一个位置开始$S$比$T$大。$dp[i][j]$表示$S$串以$i$开头有多少个子序列比$T$串以$j$开头的子串大。转移方程见代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 3005;ll dp[N][N];const ll mod = 998244353;ll C[N][N], sum[N][N];char s[N], t[N];int main()&#123; C[0][0] = 1; for (int i = 1; i &lt;= 3000; i++) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; j++) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod; &#125; sum[0][0] = 1; for (int i = 1; i &lt;= 3000; i++) &#123; sum[i][0] = 1; for (int j = 1; j &lt;= i; j++) sum[i][j] = (sum[i][j - 1] + C[i][j]) % mod; &#125; int T; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); scanf("%s%s", s, t); for (int i = 0; i &lt;= n + 2; i++) for (int j = 0; j &lt;= m + 2; j++) dp[i][j] = 0; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = m - 1; j &gt;= 0; j--) &#123; if (s[i] == t[j]) &#123; dp[i][j] = dp[i + 1][j + 1]; &#125; else if (s[i] &lt; t[j]) &#123; dp[i][j] = 0; &#125; else &#123; dp[i][j] = C[n - i - 1][m - j - 1]; &#125; dp[i][j] = (dp[i + 1][j] + dp[i][j]) % mod; &#125; &#125; ll ans = 0; for(int i=0;i &lt; n - m;i++) &#123; if(s[i] != '0') &#123; ans = (ans + mod + sum[n-i-1][n-i-1] - sum[n-i-1][m-1]) % mod; // cout&lt;&lt;ans&lt;&lt;' '&lt;&lt;i&lt;&lt;endl; &#125; else continue; &#125; printf("%lld\n", (ans + dp[0][0]) % mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[generator 2]]></title>
    <url>%2F2019%2F08%2F03%2Fgenerator-2%2F</url>
    <content type="text"><![CDATA[题目链接题意给一个一阶递推式，计算在$modp$意义下第几个数字等于$v$，一共有$Q$次询问。 思路首先由给的递推式计算出一个特征方程。然后就变成了一个离散对数的问题。 {a}^{n} \equiv V mod p.{a}^{i \times m-j} \equiv V mod p.{a}^{i \times m} \equiv V \times {a}^{j} mod p.预处理出小步，然后枚举大步。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; const ll maxn = 1e6;ll mod;struct HASH &#123; static const int mod = 12000005; int hs[mod], head[mod], nxt[mod], id[mod], top; void init()&#123; memset(head, -1, sizeof(head)); top = 1; &#125;; void insert(ll x, int y) &#123; int k = x % mod; hs[top] = x, id[top] = y, nxt[top] = head[k], head[k] = top++; &#125; int find(int x) &#123; int k = x % mod; for (int i = head[k]; i != -1; i = nxt[i]) if (hs[i] == x) return id[i]; return -1; &#125;&#125;mp;ll bin(ll x, ll n, ll MOD)&#123; ll ret = MOD != 1; for (x %= MOD; n; n &gt;&gt;= 1, x = x * x % MOD) if (n &amp; 1) ret = ret * x % MOD; return ret;&#125;inline ll get_inv(ll x, ll p) &#123; return bin(x, p - 2, p); &#125; ll m, ma;ll Init(ll a, ll p)&#123; mp.init(); ll v = 1; for(int i=1;i&lt;=m;i++) &#123; v = v * a % p; mp.insert(v,i); &#125; return v;&#125; ll BSGS(ll a, ll b, ll p, ll init_d)&#123; a %= p; if (!a &amp;&amp; !b) return 1; if (!a) return -1; ll v = init_d; ll vv = init_d; ll inv_b = get_inv(b, p); for(ll i=1;i&lt;=ma;i++) &#123; auto it = mp.find(vv * inv_b % p); if (it != -1) return i * m - it; vv = vv * v % p; &#125; return -1;&#125; int main()&#123; ios::sync_with_stdio(false); ll T; cin&gt;&gt;T; while (T--) &#123; ll n, x0, a, b, p; ll Q; cin&gt;&gt;n&gt;&gt;x0&gt;&gt;a&gt;&gt;b&gt;&gt;p&gt;&gt;Q; if (a == 0) &#123; while (Q--) &#123; ll v; cin&gt;&gt;v; if (v == x0) &#123; cout&lt;&lt;0&lt;&lt;endl; &#125; else if (v == b) &#123; cout&lt;&lt;1&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;-1&lt;&lt;endl; &#125; &#125; &#125; else if (a == 1) &#123; ll invb = get_inv(b, p); while (Q--) &#123; ll v; cin&gt;&gt;v; ll ans = (((v - x0 + p) % p) * invb) % p; if (ans &gt;= n) &#123; cout&lt;&lt;-1&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; &#125; else &#123; ll bais = b * get_inv(a - 1, p) % p; ll y0 = (x0 + bais) % p; ll inv_y0 = get_inv(y0, p); m = min(maxn, n); ma = p / maxn + 3; ll init_d = Init(a, p); while (Q--) &#123; ll v; cin&gt;&gt;v; v = (v + bais) % p; v = (v * inv_y0) % p; ll res = BSGS(a, v, p, init_d); if (res &gt;= n) res = -1; cout&lt;&lt;res&lt;&lt;endl; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[generator 1]]></title>
    <url>%2F2019%2F08%2F03%2Fgenerator-1%2F</url>
    <content type="text"><![CDATA[题目链接题意计算一个递推式的第n项，n是一个大数。 思路很容易想到矩阵快速幂，但是为了避免一个把这个大数分解成二进制的过程，我们使用十进制的快速幂。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll mod;struct matrix&#123; ll a[2][2]; void init() &#123; a[0][0] = 0; a[1][0] = 0; a[1][1] = 0; a[0][1] = 0; &#125; inline ll* operator [] (int i) &#123; return a[i]; &#125;&#125;; inline matrix mult(matrix a, matrix b)&#123; matrix ans; ans.init(); for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) ans[i][j] = (ans[i][j] + a[i][k] * b[k][j] % mod) % mod; return ans;&#125;char s[1000005]; inline matrix Pow_q(matrix a, ll b)&#123; matrix ans; ans.init(); ans[0][0] = 1; ans[1][1] = 1; while (b) &#123; if (b &amp; 1) ans = mult(ans, a); a = mult(a, a); b &gt;&gt;= 1; &#125; return ans;&#125;/* matrix Pow(matrix a)&#123; int len = strlen(s); matrix ans; ans.init(); ans[0][0] = 1; ans[1][1] = 1; for (int i = len - 1; i &gt;= 0; i--) &#123; if (s[i] != '0') &#123; //dbg(s[i] - '0'); ans = mult(ans, Pow_q(a, s[i] - '0')); &#125; a = Pow_q(a, 10); &#125; //dbg(ans[0][0], ans[0][1], ans[1][0], ans[1][1]); return ans;&#125; */matrix base[15];int main()&#123; ll x0, x1, a, b; scanf("%lld%lld%lld%lld", &amp;x0, &amp;x1, &amp;a, &amp;b); ll n; scanf("%s%lld", s, &amp;mod); int len = strlen(s); if (len == 1 &amp;&amp; s[0] == '0') &#123; printf("%lld\n", x0); return 0; &#125; if (len == 1 &amp;&amp; s[0] == '1') &#123; printf("%lld\n", x1); return 0; &#125; s[len - 1]--; int i; for (i = len - 1; i &gt;= 0; i--) if (s[i] &lt; '0') s[i] = '9', s[i - 1]--; else break; if (s[0] == '0') &#123; for (int i = 0; i &lt; len - 1; i++) s[i] = s[i + 1]; s[len - 1] = 0; &#125; //puts(s); matrix lcy; lcy[0][0] = a; lcy[0][1] = b; lcy[1][0] = 1ll; lcy[1][1] = 0; len = strlen(s); matrix ans; ans.init(); ans[0][0] = 1; ans[1][1] = 1; base[0].init(); base[0][0][0] = 1; base[0][1][1] = 1; for (int i = 1; i &lt;= 9; i++) base[i] = mult(base[i - 1], lcy); for (int i = 0; i &lt; len; i++) &#123; ans = Pow_q(ans, 10); if (s[i] != '0') &#123; //dbg(s[i] - '0'); ans = mult(ans, base[s[i] - '0']); &#125; &#125; ll ret = x1 * ans[0][0] % mod + x0 * ans[0][1] % mod; ret %= mod; printf("%lld\n", ret); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find the answer]]></title>
    <url>%2F2019%2F07%2F31%2FFind-the-answer%2F</url>
    <content type="text"><![CDATA[题目链接题意对于一个序列的前缀，你可以删除它前面的某些数字，是的这个前缀和小于等于$m$，询问最少删除几个。 思路二分删除$k$个，在一棵权值线段树上维护数字个数，求出前$k$大的数字和，如果满足当前除去这些数字后的和小于等于$m$，那么就可行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;typedef long long ll;#define lson rt &lt;&lt; 1#define rson rt &lt;&lt; 1 | 1#define Lson L, mid, lson#define Rson mid + 1, R, rsonint cnt[N &lt;&lt; 2];ll sum[N &lt;&lt; 2];void push_up(int rt)&#123; cnt[rt] = cnt[lson] + cnt[rson]; sum[rt] = sum[lson] + sum[rson];&#125;void build(int L, int R, int rt)&#123; if (L == R) &#123; cnt[rt] = 0; sum[rt] = 0; return; &#125; int mid = (L + R) &gt;&gt; 1; build(Lson); build(Rson); push_up(rt);&#125;vector&lt;int&gt; des;void update(int v, int L, int R, int rt)&#123; if (L == R) &#123; cnt[rt]++; sum[rt] += des[v - 1]; return; &#125; int mid = (L + R) &gt;&gt; 1; if (v &lt;= mid) update(v, Lson); else update(v, Rson); push_up(rt);&#125;ll query(int k, int L, int R, int rt)&#123; //printf("k %d, L %d R %d cnt %d sum %lld\n", k, L, R, cnt[rt], sum[rt]); if (L == R) &#123; ll t = k * 1ll * des[L - 1]; //printf("t %lld %d\n", t, des[L - 1]); return t; &#125; if (sum[rt] == 0) return 0; if (k == cnt[rt]) return sum[rt]; int mid = (L + R) &gt;&gt; 1; if (k &lt;= cnt[rson]) return query(k, Rson); ll ans = query(cnt[rson], Rson) + query(k - cnt[rson], Lson); //printf("l %d, r %d, ans %lld\n", L, R, ans); return ans;&#125;int a[N];template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &lt; '0' || c &gt; '9'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;int get_id(int v)&#123; return lower_bound(des.begin(), des.end(), v) - des.begin() + 1;&#125;int main()&#123; int T; read(T); while (T--) &#123; int n; ll m; read(n); read(m); des.clear(); for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); des.push_back(a[i]); &#125; sort(des.begin(), des.end()); des.erase(unique(des.begin(), des.end()), des.end()); build(1, des.size(), 1); ll pre = 0; for (int i = 1; i &lt;= n; i++) &#123; if (i &gt; 1) &#123; int l = 0, r = i - 1; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; //printf("mid %d, query %d\n", mid, query(mid, 1, des.size(), 1)); ll ret = query(mid, 1, des.size(), 1); if (pre - ret + a[i] &lt;= m) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; printf("%d ", l); &#125; else &#123; printf("0 "); &#125; update(get_id(a[i]), 1, des.size(), 1); pre += a[i]; &#125; putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fansblog]]></title>
    <url>%2F2019%2F07%2F31%2FFansblog%2F</url>
    <content type="text"><![CDATA[题目链接题意给一个素数$P$，要你找它前一个素数$Q$，计算$Q! % P$。 思路首先考虑找前一个素数。在这个范围里，素数分布的距离不是很远，我们可以筛去$P$及它前面一个区间的合数，来找素数。由威尔逊定理，我们还可以得到(n-1)! mod n = 1。 Q! mod P = \frac{(P-1)!}{(P-1)(P-2)...(Q+1)} mod P= inv((P-1)(P-2)...(Q+1) mod P)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e7 + 5;int prime[N];int tot;bool vis[N];__int128 power_mod(__int128 a, ll b, __int128 mod)&#123; __int128 ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;void pre(int n)&#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) &#123; prime[++tot] = i; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;int main()&#123; pre(10000000); int T; scanf("%d", &amp;T); while (T--) &#123; ll n; scanf("%lld", &amp;n); int siz = 3000000; ll st = n - siz; for (int i = 0; i &lt;= siz; i++) &#123; vis[i] = 0; &#125; for (int j = 1; j &lt;= tot; j++) &#123; for (ll k = (st / prime[j] + 1) * prime[j]; k &lt;= n; k += prime[j]) vis[k - st] = 1; &#125; ll p; for (int i = n - st - 1; i &gt;= 0; i--) if (!vis[i]) &#123; p = 1ll * i + st; break; &#125; __int128 now=1; long long ans=0; // dbg(p); for(__int128 i=p+1;i&lt;n;i++) now=now*i%n; ans=power_mod(now,n-2ll,n)%n*(n-1ll)%n; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>区间筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Distribution of books]]></title>
    <url>%2F2019%2F07%2F30%2FDistribution-of-books%2F</url>
    <content type="text"><![CDATA[题目链接题意将$n$本书的前若干本分成$k$段，使每一段的和的最大值最小。 思路二分答案，然后动态规划check。接下来考虑怎样计算一个mid是否可行。$dp[i]$表示以第$i$本书为结尾最多分几段，那么$dp[i] = max(dp[j]) + 1.$ sum_{a_{j}...a_{i} } \leq mid.sum_{a_{i} } - sum_{a_{j}} \leq mid.sum_{a_{j} } \geq sum_{a_{i} } - mid.在线段树维护这个前缀和就好了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 2e5 + 5;int seg[N &lt;&lt; 2];vector&lt;ll&gt; des;#define lson rt &lt;&lt; 1#define rson rt &lt;&lt; 1 | 1#define Lson L, mid, lson#define Rson mid + 1, R, rsonint dp[N];void push_up(int rt)&#123; seg[rt] = dp[seg[lson]] &lt; dp[seg[rson]]? seg[rson] : seg[lson]; &#125;ll sum[N];void build(int L, int R, int rt)&#123; if (L == R) &#123; seg[rt] = 200001; return; &#125; int mid = (L + R) &gt;&gt; 1; build(Lson); build(Rson); push_up(rt);&#125;void update(int p, int v, int L, int R, int rt)&#123; if (L == R) &#123; if (dp[seg[rt]] &lt; dp[p]) seg[rt] = p; return; &#125; int mid = (L + R) &gt;&gt; 1; if (v &lt;= mid) update(p, v, Lson); else update(p, v, Rson); push_up(rt);&#125;int query(int l, int r, int L, int R, int rt)&#123; if (l &gt; r) return 200001; if (l &lt;= L &amp;&amp; r &gt;= R) &#123; return seg[rt]; &#125; int mid = (L + R) &gt;&gt; 1; int ans = 200001; if (l &lt;= mid) &#123; int t = query(l, r, Lson); ans = dp[ans] &lt; dp[t]? t : ans; &#125; if (r &gt; mid) &#123; int t = query(l, r, Rson); ans = dp[ans] &lt; dp[t]? t : ans; &#125; return ans;&#125;int get_id(ll v)&#123; return lower_bound(des.begin(), des.end(), v) - des.begin() + 1;&#125;int k, n;bool check(ll mid)&#123; //dbg(mid); build(1, des.size(), 1); dp[0] = 0; dp[200001] = -1; update(0, get_id(0), 1, des.size(), 1); for (int i = 1; i &lt;= n; i++) &#123; ll s = sum[i] - mid; int v = get_id(s); //dbg(s, v); int t = query(v, des.size(), 1, des.size(), 1); if (dp[t] == -1) dp[i] = -1; else dp[i] = dp[t] + 1; // dbg(i, dp[i], t, dp[t]); update(i, get_id(sum[i]), 1, des.size(), 1); &#125; for (int i = 1; i &lt;= n; i++) if (dp[i] &gt;= k) return true; return false;&#125;int a[N];int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;k); des.clear(); sum[0] = 0; des.push_back(0); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); //des.push_back(a[i] * 1ll); sum[i] = sum[i - 1] + a[i]; des.push_back(sum[i]); &#125; sort(des.begin(), des.end()); des.erase(unique(des.begin(), des.end()), des.end()); ll l = -200000000000000ll, r = 200000000000000ll;// ll l = -2, r = 4; while (l &lt; r) &#123; ll mid = (l + r) &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; printf("%lld\n", l); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>二分</tag>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[number]]></title>
    <url>%2F2019%2F07%2F28%2Fnumber%2F</url>
    <content type="text"><![CDATA[题目链接题意问这个字符串中有多少个子串表示的是300的倍数。 思路记录位置到末尾的后缀和对3的余数。所有那些余数和这个数字相等的且后面有2个零的都是可行的位置。记录这样的位置数量。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;char s[N];int sum[3];int main()&#123; scanf("%s", s); int len = strlen(s); ll ans = 0; ll cnt = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; if (s[i] == '0') &#123; cnt++; if (cnt == 1) ans++; else if (cnt &gt;= 2) ans += 2; &#125; else &#123; //ans += cnt * (cnt + 1) / 2; cnt = 0; &#125; &#125;// ans += cnt * (cnt + 1) / 2;// dbg(ans); int lianxu = 0; int pre = 0; sum[0] = 0; sum[1] = 0; sum[2] = 0;// ans = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; pre = pre + s[i] - '0'; pre = pre % 3;// dbg(i, pre); ans += sum[pre]; if (i + 1 &lt; len &amp;&amp; s[i] == '0' &amp;&amp; s[i + 1] == '0') sum[pre]++; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[free]]></title>
    <url>%2F2019%2F07%2F28%2Ffree%2F</url>
    <content type="text"><![CDATA[题目链接Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;const int INF=1e9+7;using namespace std;#define pii pair&lt;int, pair&lt;int, int&gt; &gt;const int N = 10000 + 2;const int M = 50000 + 2;int tot, K, s, t, n, m;int head[N], d[N][11];struct Edge&#123; int to, w, nex;&#125; edge[M * 2];priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q;void add(int u, int v, int w)&#123; edge[++tot] = (Edge)&#123;v, w, head[u]&#125;; head[u] = tot; edge[++tot] = (Edge)&#123;u, w, head[v]&#125;; head[v] = tot;&#125;void dij()&#123; while (!q.empty()) q.pop(); memset(d, INF, sizeof(d)); q.push(make_pair(0, make_pair(s, 0))); d[s][0] = 0; while (!q.empty()) &#123; int x = q.top().second.first, k = q.top().second.second; q.pop(); for (int i = head[x]; i; i = edge[i].nex) &#123; int y = edge[i].to, l = edge[i].w; if (d[x][k] + l &lt; d[y][k]) &#123; d[y][k] = d[x][k] + l; q.push(make_pair(d[y][k], make_pair(y, k))); &#125; if (k + 1 &lt;= K &amp;&amp; d[x][k] &lt; d[y][k + 1]) &#123; d[y][k + 1] = d[x][k]; q.push(make_pair(d[y][k + 1], make_pair(y, k + 1))); &#125; &#125; &#125;&#125;int main()&#123; tot=0; scanf("%d%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t, &amp;K); while (m--) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); &#125; dij(); int ans = INF; for (int i = 0; i &lt;= K; i++) ans = min(d[t][i],ans); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string]]></title>
    <url>%2F2019%2F07%2F28%2Fstring%2F</url>
    <content type="text"><![CDATA[题目链接题意定义两个字符串$a, b$等价$a=b$或$a \neq rev(b)$。现有字符串$s$，问从其中所有字串选出一个集合，集合中所有串都不相交。询问集合最大大小。 思路贪心的想，集合最大，就是$a$的本质不同的串和$rev(a)$的本质不同的串，的和的一半，因为每一个串在$a$中对应于一个$rev(a)$中的串，但在某些情况下这两个串是一样的。没错，就是当选择的这个子串是回文串。我们建立新串s=a+ # +rev(a)，计算其中本质不同串的个数，减去那些含有’$’的串，这个结果记为$p$。$a$中的回文串数量为$q$，那么答案就是\frac{p+q}{2}。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 4e5 + 5; int t1[N], t2[N], c[N]; bool cmp(int *r, int a, int b, int l)&#123; return r[a] == r[b] &amp;&amp; r[a + l] == r[b + l];&#125; void da(int str[], int sa[], int rank[], int height[], int n, int m)&#123; n++; int *x = t1, *y = t2, p; for (int i = 0; i &lt; m; i++) c[i] = 0; for (int i = 0; i &lt; n; i++) c[x[i] = str[i]]++; for (int i = 1; i &lt; m; i++) c[i] += c[i - 1]; for (int i = n - 1; i &gt;= 0; i--) sa[--c[x[i]]] = i; for (int j = 1; j &lt;= n; j &lt;&lt;= 1) &#123; p = 0; for (int i = n - j; i &lt; n; i++) &#123; y[p++] = i; &#125; for (int i = 0; i &lt; n; i++) if (sa[i] &gt;= j) y[p++] = sa[i] - j; for (int i = 0; i &lt; m; i++) c[i] = 0; for (int i = 0; i &lt; n; i++) c[x[y[i]]]++; for (int i = 1; i &lt; m; i++) c[i] += c[i - 1]; for (int i = n - 1; i &gt;= 0; i--) sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for (int i = 1; i &lt; n; i++) x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++; if (p &gt;= n) break; m = p; &#125; int k = 0; n--; for (int i = 0; i &lt;= n; i++) rank[sa[i]] = i; for (int i = 0; i &lt; n; i++) &#123; if (k) k--; int j = sa[rank[i] - 1]; while (str[i + k] == str[j + k]) k++; height[rank[i]] = k; &#125;&#125;int Rank[N], height[N], sa[N];int r[N];const int maxn = 2e5 + 5;char a[maxn], b[maxn]; struct Palindrome_Tree&#123; int n, sz, last; int ch[maxn][27], fail[maxn], len[maxn], s[maxn]; ll cnt[maxn]; int new_node(int x) &#123; for (int i = 0; i &lt; 26; i++) ch[sz][i] = 0; cnt[sz] = 0; len[sz] = x; return sz++; &#125; void init() &#123; sz = 0; new_node(0), new_node(-1); last = 0; n = 0; s[0] = -1, fail[0] = 1; fail[1] = 0, s[1] = 0; &#125; int get_fail(int u) &#123; while (s[n - len[u] - 1] != s[n]) u = fail[u]; return u; &#125; void add(int c) &#123; c -= 'a'; s[++n] = c; int u = get_fail(last); if (!ch[u][c]) &#123; int np = new_node(len[u] + 2); fail[np] = ch[get_fail(fail[u])][c]; ch[u][c] = np; &#125; last = ch[u][c]; // cnt[last]++; &#125; void counnt() &#123; for (int i = sz - 1; i &gt; 1; i--) cnt[fail[i]] += cnt[i]; &#125; void dfs(int u) &#123; for (int i = 0; i &lt; 26; i++) if (ch[u][i]) &#123; printf("%d %d\n", u, i); dfs(ch[u][i]); &#125; &#125;&#125;;Palindrome_Tree pt;int main()&#123; scanf("%s", a);// scanf("%s", b); int len = 0, lena = strlen(a), lenb = lena; for (int i = 0; i &lt; lena; i++) b[i] = a[lena - 1 - i]; b[lena] = 0; for (int i = 0; i &lt; lena; i++) r[len++] = a[i]; r[len++] = 'z' + 1; for (int i = 0; i &lt; lenb; i++) r[len++] = b[i]; r[len] = 0; da(r, sa, Rank, height, len, 128); ll p = (len + 1) * 1ll * len / 2; //dbg(0, sa[0], height[0], p, len); //dbg(1, sa[1], height[1]); for (int i = 2; i &lt;= len; i++) &#123; p -= height[i]; //dbg(i, sa[i], height[i], p); &#125; p -= (lena + 1ll) * (lenb + 1ll); //dbg(p, len); pt.init(); for (int i = 0; i &lt; lena; i++) pt.add(a[i]); //pt.counnt(); //ll q = pt.cnt[0] + pt.cnt[1]; printf("%lld\n", (p + pt.sz - 2) / 2); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>回文树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[triples I]]></title>
    <url>%2F2019%2F07%2F27%2Ftriples-I%2F</url>
    <content type="text"><![CDATA[题目链接题意给一个$n$，然后要求构造最少的数字，使得他们都是3的倍数，且或起来为$n$。 思路1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;int fjw[64];typedef long long ll;vector&lt;int&gt; x[3];int main()&#123; for (int p = 0; p &lt;= 62; p++) fjw[p] = (1ll &lt;&lt; p) % 3; int T; scanf("%d", &amp;T); while (T--) &#123; ll n; scanf("%lld", &amp;n); x[1].clear(); x[2].clear(); for (int p = 0; p &lt;= 62; p++) if ((n &gt;&gt; p) &amp; 1) x[fjw[p]].push_back(p); if (n % 3 == 0) &#123; printf("1 %lld\n", n); continue; &#125; if (x[n % 3].size() &gt;= 2) &#123; printf("2 %lld %lld\n", n - (1ll &lt;&lt; x[n % 3][0]), n - (1ll &lt;&lt; x[n % 3][1])); &#125; else if (x[n % 3].size() == 1) &#123; printf("2 %lld %lld\n", n - (1ll &lt;&lt; x[n % 3][0]), (1ll &lt;&lt; x[n % 3][0]) + (1ll &lt;&lt; x[(3 - n % 3) % 3][1])); &#125; else &#123; printf("2 %lld %lld\n", n - (1ll &lt;&lt; x[(3 - n % 3) % 3][0]) - (1ll &lt;&lt; x[(3 - n % 3) % 3][1]), (1ll &lt;&lt; x[(3 - n % 3) % 3][0]) + (1ll &lt;&lt; x[(3 - n % 3) % 3][1]) + (1ll &lt;&lt; x[(3 - n % 3) % 3][2])); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sequence]]></title>
    <url>%2F2019%2F07%2F27%2Fsequence%2F</url>
    <content type="text"><![CDATA[题目链接题意有两个序列$a, b$。计算 \max_{1 \leq l \leq r \leq n} min(a_{l...r}) max(b_{l..r}).思路单调栈枚举每个数字的贡献，我们就要计算出b_{i}产生作用的区间，用单调栈可以扫两遍处理。在这个区间里(l_{i}, r_{i})数字b_{i}是最小的。 线段树或ST表我们记sum_{i}表示a_{1} + a_{2}+...+a_{i}。若b_{i} \geq 0，那么我们要找max( a_{j} + a_{j + 1} + ... + a_{k} )，也就是max(sum_{k} - sum_{j - 1})。只要找到max(sum_{k}), min(sum_{j-1})就可以了。若b_{i} \leq 0可以类似处理。用ST表或线段树处理区间最大或最小值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;#define lson rt&lt;&lt;1#define rson rt&lt;&lt;1|1#define Lson L,mid,lson#define Rson mid+1,R,rsonconst int maxn=3e6+10;typedef long long ll;ll tree[maxn*4];ll tree2[maxn*4];ll a[maxn*4];ll sum[maxn];int stk[maxn];int Left[maxn],Right[maxn];void pushup(int rt)&#123; tree[rt]=max(tree[lson],tree[rson]); tree2[rt]=min(tree2[lson],tree2[rson]); //printf("tree %lld %lld\n", tree[rt], tree2[rt]);&#125;void build(int L,int R,int rt)&#123; if(L==R) &#123; tree[rt]=sum[L]; tree2[rt]=sum[L]; // printf("build end %lld %lld\n", tree[rt], tree2[rt]); return; &#125; int mid=(L+R)&gt;&gt;1; build(Lson); build(Rson); pushup(rt); // printf("build %d %d %lld %lld\n", L, R, tree[rt], tree2[rt]);&#125;ll query1(int l,int r,int L,int R,int rt)&#123; if(l&lt;=L&amp;&amp;r&gt;=R) &#123; // printf("%d %d %lld\n", L, R, tree[rt]); return tree[rt]; &#125; int mid=(L+R)&gt;&gt;1; ll res=-1e15; if(l&lt;=mid) res=max(res,query1(l,r,Lson)); if(r&gt;mid) res=max(res,query1(l,r,Rson)); return res;&#125;ll query2(int l,int r,int L,int R,int rt)&#123; if(l&lt;=L&amp;&amp;r&gt;=R) &#123; return tree2[rt]; &#125; int mid=(L+R)&gt;&gt;1; ll res=1e15; if(l&lt;=mid) res=min(res,query2(l,r,Lson)); if(r&gt;mid) res=min(res,query2(l,r,Rson)); return res;&#125;ll b[maxn];int main()&#123; int N; scanf("%d",&amp;N); for(int i=1;i&lt;=N;i++) &#123; scanf("%lld",&amp;b[i]); //sum[i]=sum[i-1]+a[i]; // printf("sum %d %lld\n", i, sum[i]); //cout&lt;&lt;sum[i]&lt;&lt;endl; &#125; for (int i = 1; i &lt;= N; i++) &#123; scanf("%lld", &amp;a[i]); sum[i]=sum[i - 1] + a[i]; &#125; build(1,N,1); int top=-1; for(int i=1;i&lt;=N;i++) &#123; while(top!=-1&amp;&amp;b[stk[top]]&gt;b[i]) Right[stk[top--]] = i - 1; /* if(top==-1) Left[i]=i; else Left[i]=stk[top]+1; */ stk[++top]=i; &#125; while (top != -1) &#123; Right[stk[top--]] = N; &#125; top=-1; for(int i=N;i&gt;=1;i--) &#123; while(top!=-1&amp;&amp;b[stk[top]]&gt;b[i]) &#123; //cout&lt;&lt;i&lt;&lt;" "&lt;&lt;top&lt;&lt;endl; Left[stk[top--]] = i + 1; &#125; /* if(top==-1) Left[i]=i; else Left[i]=stk[top]-1; */ stk[++top]=i; &#125; while (top != -1) &#123; Left[stk[top--]] = 1; &#125;/* for(int i=1;i&lt;=N;i++) cout&lt;&lt;Left[i]&lt;&lt;" "&lt;&lt;Right[i]&lt;&lt;endl; */ // printf("fuck %d %d\n", Left[3], Right[3]); // printf("%lld %lld ** ?? \n", query1(Left[3], 3 - 1, 1, N, 1), query2(3, Right[3], 1, N, 1)); ll ans=0; for(int i=1;i&lt;=N;i++) &#123; if(b[i]&gt;=0) ans=max(ans,b[i]*(sum[Right[i]]-sum[Left[i]-1])); else &#123; if (Left[i] == i &amp;&amp; Right[i] == i) &#123; ans = max(ans, b[i] * 1ll * b[i]); &#125; else if(Left[i]==i) &#123; // cout&lt;&lt;query2(i,Right[i],1,N,1)&lt;&lt;endl; ans=max(ans,b[i]*(query2(i,Right[i],1,N,1)-sum[i] + a[i])); &#125; else if(Right[i]==i)&#123; ans=max(ans,b[i]*(sum[i-1]-query1(Left[i],i-1,1,N,1) + a[i])); ans = max(ans, b[i] * (sum[i - 1] - sum[Left[i] - 1] + a[i])); &#125; else&#123; ans=max(ans,b[i]*(sum[i-1]-query1(Left[i],i-1,1,N,1)+query2(i,Right[i],1,N,1)-sum[i]+a[i])); ans = max(ans, b[i] * (sum[i - 1] - sum[Left[i] - 1] + query2(i, Right[i], 1, N, 1) - sum[i] + a[i])); // printf("%d %lld %lld ?????\n", i, query1(Left[i] - 1, i - 1, 1, N, 1), query2(i, Right[i], 1, N, 1)); &#125; // cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; printf("%lld\n",ans); return 0;&#125; 另一个思路先$O(n)$建出笛卡尔树（单调栈），每个点都在它和子树的区间有作用。我们递归地处理每个点表示的区间的左最大、左最小、右最大和右最小（像线段树区间合并问题那样那样）。然后就可以更新答案了。复杂度更低一点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 3e6 + 5; #define ls(x) treap[x].child[0]#define rs(x) treap[x].child[1] struct node&#123; int child[2]; ll val; int size; ll lmin, rmin, lmax, rmax; int len[4];&#125;treap[N]; int a[N], b[N];int root;int top, fjw[N];ll ans = 0; void push_up(int rt)&#123; treap[rt].size = treap[ls(rt)].size + treap[rs(rt)].size + 1; treap[rt].val += treap[ls(rt)].val + treap[rs(rt)].val; treap[rt].lmin = treap[ls(rt)].lmin; treap[rt].len[0] = treap[ls(rt)].len[0]; //if (treap[ls(rt)].len[0] == treap[ls(rt)].size) //&#123; /* if (treap[rt].lmin &gt; treap[ls(rt)].lmin + b[rt]) &#123; treap[rt].lmin = treap[ls(rt)].lmin + b[rt]; treap[rt].len[0]++; &#125; */ if (treap[rt].lmin &gt; treap[ls(rt)].val + b[rt] + treap[rs(rt)].lmin) &#123; treap[rt].lmin = treap[ls(rt)].val + b[rt] + treap[rs(rt)].lmin; treap[rt].len[0] = treap[ls(rt)].size + 1 + treap[rs(rt)].len[0]; &#125; //&#125; treap[rt].lmax = treap[ls(rt)].lmax; treap[rt].len[1] = treap[ls(rt)].len[1]; //if (treap[ls(rt)].len[1] == treap[ls(rt)].size) //&#123; /* if (treap[rt].lmax &lt; treap[ls(rt)].lmax + b[rt]) &#123; treap[rt].lmax = treap[ls(rt)].lmax + b[rt]; treap[rt].len[1]++; &#125; */ if (treap[rt].lmax &lt; treap[ls(rt)].val + b[rt] + treap[rs(rt)].lmax) &#123; treap[rt].lmax = treap[ls(rt)].val + b[rt] + treap[rs(rt)].lmax; treap[rt].len[1] = treap[ls(rt)].size + 1 + treap[rs(rt)].len[1]; &#125; //&#125; treap[rt].rmin = treap[rs(rt)].rmin; treap[rt].len[2] = treap[rs(rt)].len[2]; //if (treap[rs(rt)].len[2] == treap[rs(rt)].size) //&#123; /* if (treap[rt].rmin &gt; treap[rs(rt)].rmin + b[rt]) &#123; treap[rt].rmin = treap[rs(rt)].rmin + b[rt]; treap[rt].len[2]++; &#125; */ if (treap[rt].rmin &gt; treap[rs(rt)].val + b[rt] + treap[ls(rt)].rmin) &#123; treap[rt].rmin = treap[rs(rt)].val + b[rt] + treap[ls(rt)].rmin; treap[rt].len[2] = treap[rs(rt)].size + 1 + treap[ls(rt)].len[2]; &#125; //&#125; treap[rt].rmax = treap[rs(rt)].rmax; treap[rt].len[3] = treap[rs(rt)].len[3];// if (treap[rs(rt)].len[3] == treap[rs(rt)].size)// &#123; /* if (treap[rt].rmax &lt; treap[rs(rt)].lmin + b[rt]) &#123; treap[rt].lmin = treap[ls(rt)].lmin + b[rt]; treap[rt].len[0]++; &#125; */// dbg(rt, rs(rt), b[rt], treap[rt].rmax, treap[rs(rt)].rmax); if (treap[rt].rmax &lt; treap[rs(rt)].val + b[rt] + treap[ls(rt)].rmax) &#123; treap[rt].rmax = treap[rs(rt)].val + b[rt] + treap[ls(rt)].rmax; treap[rt].len[3] = treap[rs(rt)].size + 1 + treap[ls(rt)].len[3]; &#125;// &#125;&#125; void dfs(int u)&#123; if (!u) return; //dbg(u, ls(u), rs(u)); dfs(ls(u)); dfs(rs(u)); if (a[u] &gt;= 0) ans = max(ans, a[u] * (b[u] + treap[ls(u)].rmax + treap[rs(u)].lmax)); else ans = max(ans, a[u] * (b[u] + treap[ls(u)].rmin + treap[rs(u)].lmin)); push_up(u); //dbg(u, treap[u].lmin, treap[u].lmax, treap[u].rmin, treap[u].rmax, ans);&#125; int main()&#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;b[i]); top = 0; for (int i = 1; i &lt;= n; i++) &#123; rs(i) = ls(i) = 0; treap[i].val = b[i]; while (top &gt;= 1 &amp;&amp; a[fjw[top]] &gt;= a[i]) &#123; ls(i) = fjw[top]; top--; &#125; if (top &gt;= 1) rs(fjw[top]) = i; else root = i; fjw[++top] = i; &#125; ans = -1e15; dfs(root); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>datastructure</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[meeting]]></title>
    <url>%2F2019%2F07%2F27%2Fmeeting%2F</url>
    <content type="text"><![CDATA[题目链接题意有一颗$n$个点的树，其中有$k$个点有人居住，树上每条边花费都是1，现要找到一个点，使得所有人到这个点的花费的最大值最小。 思路树形dp每个点作为答案的话，我们可以先$dfs$一遍算出，所有点的子树中到有人的点到它的最远距离。接下来考虑，第二遍$dfs$，我们要计算，来自他的父亲的有人的点到他的最远距离。第二遍dp比较复杂，需要考虑较多东西，要仔细一点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50 const int N = 1e5 + 5;int tot;int head[N];struct E&#123; int v, nxt, mx;&#125;edge[2 * N];int son[N];bool is[N];int mx[N]; void add_edge(int u, int v)&#123; edge[++tot].v = v; edge[tot].nxt = head[u]; head[u] = tot;&#125; void dfs(int u, int f)&#123; for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f) continue; dfs(v, u); if (mx[v] != -1 &amp;&amp; (son[u] == -1 || mx[u] &lt; mx[v] + 1)) &#123; son[u] = v; mx[u] = mx[v] + 1; &#125; if (is[v] &amp;&amp; (son[u] == -1 || mx[u] &lt; 1)) &#123; son[u] = v; mx[u] = 1; &#125; &#125; //dbg(u, mx[u]);&#125;int ans; void dfs2(int u, int f, int t)&#123; int pmx = -1, qmax = max(mx[u], t); if (qmax == -1) qmax = -1; else qmax += 1; if (is[u]) pmx = max(pmx, 0), qmax = max(qmax, 1); for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f) continue; if (v != son[u]) &#123; if (mx[v] != -1) pmx = max(pmx, mx[v] + 1); if (is[v]) pmx = max(pmx, 1); dfs2(v, u, qmax); &#125; &#125; //dbg(u, pmx, qmax, t, max(t, pmx)); if (son[u] != -1) dfs2(son[u], u, max(t, pmx) == -1? -1 : max(t, pmx) + 1); mx[u] = max(mx[u], t); if (mx[u] &lt; mx[ans]) ans = u; //dbg(u, mx[u], ans);&#125;int main()&#123; int n, k; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) head[i] = -1, son[i] = -1, mx[i] = -1; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); add_edge(u, v); add_edge(v, u); &#125; for (int i = 1; i &lt;= k; i++) &#123; int x; scanf("%d", &amp;x); is[x] = 1; &#125; if (k == 0) &#123; puts("0"); return 0; &#125; dfs(1, 0); ans = 1; dfs2(1, 0, -1); printf("%d\n", mx[ans]); return 0;&#125; 直径也可以在这些点中找直径，若直径是$d$，那么这些点都可以在\left \lceil \frac{d}{2} \right \rceil内到达这点。这种方法比较好写。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int mx[N];int is[N];struct E&#123; int v, nxt;&#125;edge[2 * N];int tot;int head[N];void add_edge(int u, int v)&#123; edge[++tot].v = v; edge[tot].nxt = head[u]; head[u] = tot;&#125;int dep[N];void dfs(int u, int f)&#123; mx[u] = 0; dep[u] = dep[f] + 1; for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f) continue; dfs(v, u); if (is[v]) if (mx[u] == 0) mx[u] = v; if (mx[v]) mx[u] = dep[mx[u]] - dep[u] &gt;= dep[mx[v]] - dep[u] + 1? mx[u] : mx[v]; &#125;&#125;int main()&#123; int n, k; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; head[i] = -1; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); add_edge(u, v); add_edge(v, u); &#125; for (int i = 1; i &lt;= k; i++) &#123; int x; scanf("%d", &amp;x); is[x] = 1; &#125; dep[0] = 0; dfs(1, 0); int rt = mx[1]; dfs(rt, 0); printf("%d\n", (dep[mx[rt]] - dep[rt] + 1) / 2); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Planting Trees]]></title>
    <url>%2F2019%2F07%2F26%2FPlanting-Trees%2F</url>
    <content type="text"><![CDATA[题目链接题意找一个最大的子矩阵，使里面所有元素的大小之差不大于m。 思路降维通过枚举上边界，下边界，可以在O(n*n)的时间内得到每一列的最大值和最小值。 单调队列用两个单调队列维护最大和最小，最大值递减，最小值递增，更新答案。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50 const int N = 505;int a[N][N];int mxh[N], mnh[N];int inc[N], decr[N];int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) scanf("%d", &amp;a[i][j]); int ans = 0; for (int up = 1; up &lt;= n; up++) &#123; for (int j = 1; j &lt;= n; j++) mxh[j] = 0, mnh[j] = 0x3f3f3f3f; for (int down = up; down &lt;= n; down++) &#123; //dbg(up, down); int pre = 0; int h1 = 0, h2 = 0, t1 = -1, t2 = -1; for (int j = 1; j &lt;= n; j++) &#123; mxh[j] = max(mxh[j], a[down][j]); mnh[j] = min(mnh[j], a[down][j]); while (h1 &lt;= t1 &amp;&amp; mxh[decr[t1]] &lt;= mxh[j]) t1--; decr[++t1] = j; while (h2 &lt;= t2 &amp;&amp; mnh[inc[t2]] &gt;= mnh[j]) t2--; inc[++t2] = j; //dbg(t1, t2, decr[t1], inc[t2]); while (h1 &lt;= t1 &amp;&amp; h2 &lt;= t2 &amp;&amp; mxh[decr[h1]] - mnh[inc[h2]] &gt; m) &#123; // dbg(h1, h2, decr[h1], inc[h2]); pre = min(decr[h1], inc[h2]); if (decr[h1] &lt; inc[h2]) h1++; else if (decr[h1] &gt; inc[h2]) h2++; else &#123; h1++; h2++; &#125; &#125; if (h1 &lt;= t1 || h2 &lt;= t2) ans = max(ans, (down - up + 1) * (j - pre)); else pre = j; //dbg(j, pre, mxh[j], mnh[j], ans); &#125; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vacation]]></title>
    <url>%2F2019%2F07%2F23%2FVacation%2F</url>
    <content type="text"><![CDATA[题目链接题意有$n$辆车在你前面开，你们都要过红绿灯（可以认为始终保持绿灯），每辆车都有最大速度v_{i}，可以认为每个司机技术很好，可以保持和前一辆车零距离。现在问你你这两车要开到红绿灯处需要多久的时间。 思路二分时间口胡：二分时间然后去check是否这$n+1$辆车不会发生碰撞，而且最后一辆车可以在这个时间内到达终点。 贪心最后的情况一定有一辆车堵着后面所有的车。我们去找这一辆车，它的时间只是和他自己有关，再把后面的车长考虑进去。所有的车取最大就可以了。123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;ll l[N], s[N], v[N];int main()&#123; int n; while (~scanf("%d", &amp;n)) &#123; for (int i = 0; i &lt;= n; i++) scanf("%lld", &amp;l[i]); for (int i = 0; i &lt;= n; i++) scanf("%lld", &amp;s[i]); for (int i = 0; i &lt;= n; i++) scanf("%lld", &amp;v[i]); double ans = 1.0 * s[0] / (double)v[0]; ll sum = 0; for (int i = 1; i &lt;= n; i++) &#123; sum += l[i]; ans = max(ans, 1.0 * (s[i] + sum) / (double)v[i]); //dbg(i, ans, sum); &#125; printf("%.6f\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function]]></title>
    <url>%2F2019%2F07%2F23%2FFunction-1%2F</url>
    <content type="text"><![CDATA[题目链接题意计算 \sum_{i = 1}^{n} gcd( \left \lfloor \sqrt[3]{i} \right \rfloor, i).对$998244353$取模。$1 \leq n \leq {10}^{21}.$ 思路ans = \sum_{i = {r}^{3} }^{n} gcd(i, \left \lfloor \sqrt[3]{n} \right \rfloor ) + \sum_{a=1}^{r-1} \sum_{i={a}^{3} }^{ {(a+1)}^{3}-1}gcd(i, {a}^{3}).\sum_{i=1}^{n}gcd(i, a) = \sum_{d=1}^{n} d \sum_{i=1}^{n}[gcd(i, a) = d].= \sum_{d|a} d \sum_{i=1}^{ \frac{n}{d} } [gcd(i, \frac{a}{d}) = 1]= \sum_{d|a} d \sum_{i=1}^{ \frac{n}{d} } \mu(i) \left \lfloor \frac{n}{di} \right \rfloor= \sum_{d|a} d \sum_{T|a, d|T} \mu( \frac{T}{d} ) \left \lfloor \frac{n}{T} \right \rfloor= \sum_{T|a} \left \lfloor \frac{n}{T} \right \rfloor \sum_{d|T} d \mu( \frac{T}{d})= \sum_{T|a} \left \lfloor \frac{n}{T} \right \rfloor \varphi(T).\sum_{a=1}^{x} \sum_{i={a}^{3} }^{ {(a+1)}^{3} - 1} gcd(i,{a}^{3})= \sum_{a=1}^{x} \sum_{T|a} \varphi(T) ( \left \lfloor \frac{ {(a+1)}^{3}-1}{T} \right \rfloor - \left \lfloor \frac{ {a}^{3} - 1}{T} \right \rfloor)= \sum_{T=1}^{x} \varphi(T) \sum_{i=1}^{ \left \lfloor \frac{x}{T} \right \rfloor} \left \lfloor \frac{ {(iT+1)}^{3}-1}{T} \right \rfloor - \left \lfloor \frac{ {(iT)}^{3}-1}{T} \right \rfloor= \sum_{T=1}^{x} \varphi(T) \sum_{i=1}^{ \left \lfloor \frac{x}{T} \right \rfloor} 3T{i}^{2}+3i+1.复杂度O( \sqrt[3]{n})。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operation]]></title>
    <url>%2F2019%2F07%2F23%2FOperation%2F</url>
    <content type="text"><![CDATA[题目链接题意有n个数，每次要么询问区间的最大异或和，要么在最后加一个数。 思路首先很容易想到这个问题要维护区间线性基，每次询问得到区间线性基后从高位到低位贪心的选。似乎是一道线段树维护线性基的裸题，但是分析一下复杂度，线段树本身一个log，线性基一个log，似乎不是很容易卡过去。复杂度类似的用平衡树维护线性基也是如此。这里引出一种算法，贪心地维护序列的前缀线性基。 可持久化线性基我们称它为可持久化线性基。每个位置维护它的前缀线性基，然后用心最后一个位置贪心更新，每个基底一定是越靠后越好。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 5e5 + 5;struct liner_base&#123; int a[31]; int pos[31]; int cnt; int&amp; operator [] (int i) &#123; return a[i]; &#125; void add(int x, int p) &#123; for (int i = 30; i &gt;= 0; i--) if (1 &lt;&lt; i &amp; x) &#123; //dbg(i, x, pos[i], a[i]); if (pos[i] == 0) &#123; pos[i] = p; a[i] = x; break; &#125; if (pos[i] &lt; p) &#123; // dbg(x, a[i]); swap(pos[i], p); swap(x, a[i]); &#125; x ^= a[i]; //dbg(x, a[i]); &#125; /* for (int i = 30; i &gt;= 0; i--) if (pos[i]) dbg(i, pos[i], a[i]); */ &#125;&#125;x[N];int a[N];int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n, q; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 0; i &lt; 31; i++) x[0].pos[i] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= 30; j++) x[i].a[j] = x[i - 1].a[j], x[i].pos[j] = x[i - 1].pos[j]; x[i].add(a[i], i); &#125; int ans = 0; while (q--) &#123; int type; scanf("%d", &amp;type); if (type == 0) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); l = (l ^ ans) % n + 1; r = (r ^ ans) % n + 1; if (l &gt; r) swap(l, r); dbg(l, r); ans = 0; for (int i = 30; i &gt;= 0; i--) &#123; if (x[r].pos[i] &gt;= l &amp;&amp; (ans ^ x[r].a[i]) &gt; ans) ans ^= x[r].a[i]; //dbg(ans, x[r].a[i], x[r].pos[i]); &#125; printf("%d\n", ans); &#125; else &#123; scanf("%d", &amp;a[++n]); a[n] ^= ans; for (int i = 0; i &lt;= 30; i++) x[n].a[i] = x[n - 1].a[i], x[n].pos[i] = x[n - 1].pos[i]; x[n].add(a[n], n); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD of Sequence]]></title>
    <url>%2F2019%2F07%2F21%2FGCD-of-Sequence%2F</url>
    <content type="text"><![CDATA[题目链接题意给一个序列，让你计算有多少序列$b$满足:1.每个位置1 \leq b_{i} \leq m。2.gcd(b_{1}, b_{2}...b_{n})=d。3.和原来数列恰好有$k$个位置数字不同。 思路思路不难想，计算出$F(d)$，然后去暴力计算每一个$f(d)$。 F(d) = C_{k - n + c}^{c} { (\frac{m}{d} - 1)}^{k - n + c} { (\frac{m}{d}) }^{n - p}.f(n) = \sum_{n | d} \mu(\frac{d}{n} ) F(d).其中$c$为数字$d$的倍数出现的次数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 3e5 + 5;int a[N];int prime[N];int tot, vis[N];int miu[N];ll F[N];void pre(int n)&#123; miu[1] = 1; tot = 0; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) &#123; prime[++tot] = i; miu[i] = -1; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; miu[i * prime[j]] = 0; break; &#125; miu[i * prime[j]] = -miu[i]; &#125; &#125;&#125;int cnt[N];const ll mod = 1e9 + 7;ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;ll fac[N];ll C(int n, int m)&#123; return fac[n] * Pow(fac[n - m] * fac[m] % mod, mod - 2) % mod;&#125;int main()&#123; fac[0] = 1; for (int i = 1; i &lt;= 300000; i++) fac[i] = fac[i - 1] * 1ll * i % mod; pre(300000); int n, m, k; while (~scanf("%d%d%d", &amp;n, &amp;m, &amp;k)) &#123; memset(cnt, 0, sizeof(cnt)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); cnt[a[i]]++; &#125; for (int i = 1; i &lt;= m; i++) &#123; ll c = 0; for (ll d = i; d &lt;= m; d += i) &#123; c += cnt[d]; &#125; if (n - c &gt; k) F[i] = 0; else F[i] = C(c, k - n + c) * Pow(m / i - 1ll, k - n + c) % mod * Pow(m / i, n - c) % mod; //dbg(i, F[i], k, n, c); &#125; for (int i = 1; i &lt;= m; i++) &#123; ll ans = 0; for (ll d = i; d &lt;= m; d += i) ans = (ans + miu[d / i] * F[d] % mod + mod) % mod; printf("%lld%c", ans, i == m? '\n': ' '); &#125; &#125; return 0;&#125; 这里提供另一种思路计算某个数字的倍数的出现次数的方法，用莫比乌斯函数容斥一下。但让我百思不得其解的是这种方法竟然比上面要慢。如果有人可以帮我证明这两种方法的优劣性，欢迎联系我。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 3e5 + 5;int a[N];int prime[N];int tot, vis[N];int miu[N];ll F[N];void pre(int n)&#123; miu[1] = 1; tot = 0; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) &#123; prime[++tot] = i; miu[i] = -1; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; miu[i * prime[j]] = 0; break; &#125; miu[i * prime[j]] = -miu[i]; &#125; &#125;&#125;int cnt[N];const ll mod = 1e9 + 7;ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;ll fac[N];ll dfs(int p, int m)&#123; if (vis[p]) return cnt[p]; for (int i = 2; p * i &lt;= m; i++) if (miu[i]) cnt[p] = (cnt[p] - miu[i] * dfs(p * i, m) % mod + mod) % mod; vis[p] = 1; //dbg(p, cnt[p]); return cnt[p];&#125;ll C(int n, int m)&#123; return fac[n] * Pow(fac[n - m] * fac[m] % mod, mod - 2) % mod;&#125;int main()&#123; fac[0] = 1; for (int i = 1; i &lt;= 300000; i++) fac[i] = fac[i - 1] * 1ll * i % mod; pre(300000); int n, m, k; while (~scanf("%d%d%d", &amp;n, &amp;m, &amp;k)) &#123; memset(cnt, 0, sizeof(cnt)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); cnt[a[i]]++; &#125; for (int i = 1; i &lt;= m; i++) vis[i] = 0; dfs(1, m); for (int i = 1; i &lt;= m; i++) &#123; /* ll c = 0; for (ll d = i; d &lt;= m; d += i) &#123; c += cnt[d]; &#125; */ ll c = cnt[i]; if (n - c &gt; k) F[i] = 0; else F[i] = C(c, k - n + c) * Pow(m / i - 1ll, k - n + c) % mod * Pow(m / i, n - c) % mod; //dbg(i, F[i], k, n, c); &#125; for (int i = 1; i &lt;= m; i++) &#123; ll ans = 0; for (ll d = i; d &lt;= m; d += i) ans = (ans + miu[d / i] * F[d] % mod + mod) % mod; printf("%lld%c", ans, i == m? '\n': ' '); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Mobius inversion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eddy Walker]]></title>
    <url>%2F2019%2F07%2F21%2FEddy-Walker%2F</url>
    <content type="text"><![CDATA[题目链接题意有一个大小为$n$的环，现在从位置$0$开始走，或前或后，直到走到所有点都经过一遍停下来，问停在M_{i}的概率。 思路我们可以手玩几个小的$n,m$。当$n$为2： p=1.当$n$为3： p_{1} = \frac{1}{2}.当$n$为4： p_{1} = \frac{1}{2} p_{2} + \frac{1}{2} p_{2}.p_{1} + p_{2} = 1.p_{1} = p_{2} = \frac{1}{3}.当$n$为5： p_{2} = \frac{1}{2} p_{1} + \frac{1}{2} p_{2}.p_{1} + p_{2} = \frac{1}{2}.…所以当m不为$0$，概率是\frac{1}{n - 1}。1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod=1e9+7;inline ll powmod(ll a,ll b)&#123; ll ans=1; while(b)&#123;if(b&amp;1ll) ans=ans*a%mod;b&gt;&gt;=1;a=a*a%mod;&#125; return ans;&#125;int main()&#123; #ifdef local freopen("a.txt","r",stdin); #endif // local int t,n,m; ll ans=1; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d",&amp;n,&amp;m); if(!m)&#123; if(n&gt;1) ans=0; &#125; else ans=ans*powmod(n-1,mod-2)%mod; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Partition problem]]></title>
    <url>%2F2019%2F07%2F21%2FPartition-problem%2F</url>
    <content type="text"><![CDATA[题目链接题意将2n个人分成两组，使每组n个人，最大化每组对另外一组所有人的竞争力的和。 思路dfs，在dfs时顺便在O(n)的时间内计算影响。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=30;ll graph[maxn][maxn];int cnt[maxn][2];int n,msk;ll ans;int w[30];inline void dfs(int num,int stat,int len,ll res,int p)&#123; if(p)&#123; for(int i=0;i&lt;num-1;i++)&#123; if(stat&amp;(1&lt;&lt;i)) res-=graph[i][num-1]; else res+=graph[i][num-1]; &#125; for(int i=num;i&lt;2*n;i++)&#123; res+=graph[i][num-1]; &#125; &#125; if(len==n)&#123; ans=max(ans,res); return ; &#125; if(num&gt;=2*n) return ; if(2*n-num&lt;n-len) return ; dfs(num+1,stat|w[num],len+1,res,1); dfs(num+1,stat,len,res,0);&#125;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;template&lt;class T&gt;void write(T x)&#123; if (x == 0) &#123; putchar('0'); return; &#125; if (x &gt;= 10) write(x / 10); putchar('0' + x % 10);&#125;int main()&#123; read(n); for(int i=0;i&lt;2*n;i++)&#123; for(int j=0;j&lt;2*n;j++) read(graph[i][j]); &#125; for (int i = 0; i &lt;= 2 * n; i++) w[i] = 1 &lt;&lt; i; ans=0; dfs(0,0,0,0,0); write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Second Large Rectangle]]></title>
    <url>%2F2019%2F07%2F20%2FSecond-Large-Rectangle%2F</url>
    <content type="text"><![CDATA[题目链接题意在一个01矩阵中找出第二大的满足全部由1构成的子矩阵。 思路首先预处理出每个位置向上最大连续1的高度，然后对每一行单调栈处理处这一行中，以每个高度为最高的矩形面积是多少。遍历所有矩形，找出最大的两个和答案去比较，并且更新。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 5;int g[N][N];char s[N];int mxh[N][N];int lm[N], rm[N];stack&lt;int&gt; st;struct node&#123; int v, l, r; node(int v, int l, int r): v(v), l(l), r(r) &#123;&#125; bool operator &lt; (const node&amp; x) const &#123; return v &gt; x.v; &#125; bool operator == (const node&amp; x) const &#123; return v == x.v &amp;&amp; l == x.l &amp;&amp; r == x.r; &#125;&#125;;vector&lt;node&gt; fjw;int ans1, ans2;void use(int v)&#123; if (v &gt;= ans1) &#123; ans2 = ans1; ans1 = v; &#125; else if (v &gt;= ans2) &#123; ans2 = v; &#125;&#125;int main()&#123; int n, m; scanf("%d%d", &amp;n, &amp;m); ans1 = 0, ans2 = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", s + 1); for (int j = 1; j &lt;= m; j++) g[i][j] = s[j] - '0'; while (!st.empty()) st.pop(); for (int j = 1; j &lt;= m; j++) &#123; mxh[i][j] = g[i][j]? mxh[i - 1][j] + 1: 0; while (!st.empty() &amp;&amp; mxh[i][j] &lt;= mxh[i][st.top()]) st.pop(); if (st.empty()) lm[j] = 1; else lm[j] = st.top() + 1; st.push(j); &#125; while (!st.empty()) st.pop(); for (int j = m; j &gt;= 1; j--) &#123; while (!st.empty() &amp;&amp; mxh[i][j] &lt;= mxh[i][st.top()]) st.pop(); if (st.empty()) rm[j] = m; else rm[j] = st.top() - 1; st.push(j); &#125; fjw.clear(); for (int j = 1; j &lt;= m; j++) &#123;// printf("%d %d %d %d %d\n", i, j, lm[j], rm[j], mxh[i][j]); fjw.push_back(node((rm[j] - lm[j] + 1) * mxh[i][j], lm[j], rm[j])); &#125; sort(fjw.begin(), fjw.end()); fjw.erase(unique(fjw.begin(), fjw.end()), fjw.end()); int cnt = 0; for (auto &amp;x : fjw) &#123; cnt++;// printf("set %d %d %d %d\n", i, x.v, x.l, x.r); use(x.v); use(x.v - (x.r - x.l + 1)); use(x.v - x.v / (x.r - x.l + 1)); if (cnt &gt;= 2) break; &#125; &#125; printf("%d\n", ans2); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>greedy</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FMT与FWT]]></title>
    <url>%2F2019%2F07%2F20%2FFMT%E4%B8%8EFWT%2F</url>
    <content type="text"><![CDATA[首先感谢几篇良心博客的博主，教程写得真的很好。真正理解快速沃尔什变换/快速莫比乌斯变换(FWT|FMT) (已完结)FMT 与 子集(逆)卷积FWT快速沃尔什变换学习笔记 集合卷积我们时常要解决一些与集合有关的卷积问题，像快速傅里叶变换那样，对下标有一些要求和限制。FWT和FMT可以成为我们解决这类问题的有力武器。 FMT我个人认为，FMT比FWT从原理角度上更好理解。接下来介绍一下快速莫比乌斯变换。 原理首先我们要证明FMT可以像FFT那样乘来乘去并保证正确性。 证明对于长度为{2}^{n}的序列，我们定义集合并卷积， h_{S} = \sum_{L \subseteq S} \sum_{R \subseteq S} [L \cup R = S]f_{L} * g_{R}.定义它的莫比乌斯变换为 \widehat{h_{S} } = \sum_{L \subseteq S} h_{L}.对集合并卷积的式子两边做FMT， \widehat{h_{S} } = \sum_{T \subseteq S} \sum_{L \subseteq T} \sum_{R \subseteq T} [L \cup R = T] f_{L} * g_{R}.\widehat{h_{S} } = \sum_{L \subseteq S} \sum_{R \subseteq S} [L \cup R \subseteq S] f_{L} * g_{R}.\widehat{h_{S} } = \widehat{f_{S} } * \widehat{g_{S} }.至此我们就证明了其具有线性变换的性质。 正变换直接暴力进行计算，其复杂度是O({n}^{3})的，这个复杂度很容易证明（虽然写烂了的话就变成O({4}^{n})）。一种优美的方法是分层进行递归处理，我们处理某一位$i$，假设一个集合$S$是不包含$i$的，那么S \cup (1 < i)]]></content>
      <categories>
        <category>acm</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Euclidean Distance]]></title>
    <url>%2F2019%2F07%2F19%2FEuclidean-Distance%2F</url>
    <content type="text"><![CDATA[题目链接题意$n$维平面上有一个点，坐标是( \frac{a_{1} }{m}, \frac{a_{2} }{m}...)，现在想找一个点$P$，试他们的欧几里得距离最短。要求$P$的坐标满足：1.p_{1}, p_{2},...p_{n} \geq 0.2.p_{1} + p_{2}+...+p_{n} = 1. 思路拉格朗日乘数法f(p, \lambda) = \sum_{i} {(p_{i} - a_{i})}^{2} + 2 \lambda (\sum_{i} p_{i} - 1).f_{p_{i} }(p, \lambda) = 2(p_{i} - a_{i}) + 2 \lambda = 0.f_{ \lambda}(p, \lambda) = \sum_{i} p_{i} - 1 = 0.p_{i} = a_{i} - \lambda.\sum_{i} a_{i} - n \lambda = 1.\lambda = \frac{ \sum_{i} a_{i} - 1}{n}.p_{i} = a_{i} - \frac{ \sum_{i} a_{i} - 1}{n}.贪心现在如果没有p_{i}大于0的限制我们就已经解决了这道题，现在考虑一下，如何加上这样的限制。我们可以贪心地把一部分正数填补到负数来，让原本负数取最值的点处于边界(0)，那么正数怎么来弥补呢。经过观察可以发现，最好是正数均摊，这样产生的额外增加的比较少。想不明白可以自己画一下。于是我们就有了这样的方案： Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e4 + 5; inline ll gcd(ll a, ll b)&#123; if (a &lt; b) swap(a, b); while (b) &#123; ll t = a; a = b; b = t % b; &#125; return a;&#125; struct frac&#123; ll a, b; frac(ll a=0, ll b=1): a(a), b(b) &#123;&#125; inline bool operator &lt; (const frac&amp; x) const &#123; return a * x.b &lt; b * x.a; &#125; inline bool operator &gt; (const frac&amp; x) const &#123; return a * x.b &gt; b * x.a; &#125; inline bool operator == (const frac&amp; x) const &#123; return a == x.a &amp;&amp; b == x.b; &#125; inline bool operator &gt;= (const frac&amp; x) const &#123; return *this &gt; x || *this == x; &#125; inline bool operator &lt;= (const frac&amp; x) const &#123; return *this &lt; x || *this == x; &#125; inline void pretty() &#123; ll g = gcd(abs(a), abs(b)); if (g) a /= g, b /= g; if (a * b &lt; 0) a = -abs(a), b = abs(b); else if (a &lt; 0 &amp;&amp; b &lt; 0) a = abs(a), b = abs(b); &#125; inline frac operator + (const frac&amp; x) const &#123; frac tmp = frac(); tmp.a = a * x.b + x.a * b; tmp.b = b * x.b; tmp.pretty(); return tmp; &#125; inline frac operator - (const frac&amp; x) const &#123; frac tmp = frac(); tmp.a = a * x.b - b * x.a; tmp.b = b * x.b; tmp.pretty(); return tmp; &#125; inline frac operator * (const frac&amp; x) const &#123; frac ret = frac(); ret.a = a * x.a; ret.b = b * x.b; ret.pretty(); return ret; &#125; inline frac operator / (const frac&amp; x) const &#123; frac ret = frac(); ret.a = a * x.b; ret.b = b * x.a; ret.pretty(); return ret; &#125; inline void print() &#123; if (a == 0) printf("0\n"); else if (b == 1) printf("%lld\n", a); else printf("%lld/%lld\n", a, b); &#125;&#125;;frac a[N];int main()&#123; int n, m; frac sum = frac(0, 1), one = frac(1, 1); while (~scanf("%d%d", &amp;n, &amp;m)) &#123; frac sum = frac(0, 1); for (int i = 1; i &lt;= n; i++) &#123; ll x; scanf("%lld", &amp;x); a[i] = frac(x, m); sum = sum + a[i]; &#125; sort(a + 1, a + n + 1); frac remedy = frac(0, 1); frac c = (sum - one) / frac(n, 1); int p; for (int i = 1; i &lt;= n; i++) &#123; if (a[i] &gt;= c + remedy / frac(n - i + 1, 1)) &#123; p = i; break; &#125; remedy = remedy - a[i] + c; &#125; //dbg(remedy.a, remedy.b, c.a, c.b, p); frac ans = frac(0, 1); remedy = remedy / frac(n - p + 1, 1) + c; for (int i = 1; i &lt; p &amp;&amp; i &lt;= n; i++) &#123; ans = ans + a[i] * a[i]; // dbg(i, a[i].a, a[i].b, ans.a, ans.b); &#125; ans = ans + remedy * remedy * frac(n - p + 1, 1); ans.print(); &#125; return 0;&#125; 顺便藏个分数模板。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ABBA]]></title>
    <url>%2F2019%2F07%2F18%2FABBA%2F</url>
    <content type="text"><![CDATA[题目链接题意一个长度为$2(n+m)$字符串只由$’A’,’B’$构成，且可以将它分成$n+m$个子序列，其中$n$个为$AB$，$m$个为$BA$。问这样的字符串有多少个。 思路dp$dp[i][j]$表示到第$i$个字符，选了$j$个$A$，我们判断一下是否合法状态，转移就行了。 Code12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e3 + 5;const ll mod = 1e9 + 7;ll dp[N * 2][N];bool check(int i, int j, int n, int m)&#123; return j &gt;= 0 &amp;&amp; j &lt;= i &amp;&amp; j - (i - j) &lt;= n &amp;&amp; (i - j) - j &lt;= m;&#125;int main()&#123; int n, m; while (scanf("%d%d", &amp;n, &amp;m) == 2) &#123; dp[0][0] = 1; for (int i = 1; i &lt;= 2 * (n + m); i++) &#123; for (int j = 0; j &lt;= n + m; j++) &#123; if (check(i - 1, j - 1, n, m)) dp[i][j] = (dp[i - 1][j - 1] + dp[i][j]) % mod; if (check(i - 1, j, n, m)) dp[i][j] = (dp[i - 1][j] + dp[i][j]) % mod; &#125; &#125; printf("%lld\n", dp[2 * (n + m)][n + m]); for (int i = 1; i &lt;= 2 * (n + m); i++) for (int j = 0; j &lt;= n + m; j++) dp[i][j] = 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Integration]]></title>
    <url>%2F2019%2F07%2F18%2FIntegration%2F</url>
    <content type="text"><![CDATA[题目链接题意已知 \int_{0}^{ \infty} \frac{1}{1+{x}^{2}} = \frac{ \pi}{2}.计算 \frac{1}{ \pi} \int_{0}^{ \infty} \frac{1}{ \prod_{i} ({a_{i} }^{2} + {x}^{2} )}.思路这我哪想得出来。。。\frac{1}{ \prod_{i} ({a_{i} }^{2} + {x}^{2})} = \sum_{i} \frac{c_{i} }{({a_{i} }^{2}+{x}^{2} )}.1 = \sum_{i} \frac{c_{i} \prod_{j} ({a_{j} }^{2} + {x}^{2} )}{({a_{i} }^{2} + {x}^{2})}.1 = c_{i} \prod_{i \neq j} ({a_{j} }^{2} + {x}^{2}) + \sum_{j \neq i} \frac{c_{j} \prod_{k \neq j} ({a_{k} }^{2} + {x}^{2})}{ {a_{j}}^{2} + {x}^{2} }.x = a_{i} i.$i$为单位虚根. 1 = c_{i} \prod_{j \neq i} ({a_{j} }^{2} - {a_{i} }^{2}) + 0.c_{i} = \frac{1}{ \prod_{j \neq i} ({a_{j} }^{2} - {a_{i} }^{2})}.Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const ll mod = 1e9 + 7;ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;const int N = 1e3 + 5;ll a[N], c[N];template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;int main()&#123; int n; ll inv2 = (mod + 1) / 2; while (~scanf("%d", &amp;n)) &#123; for (int i = 1; i &lt;= n; i++) read(a[i]); ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; ll t = 1; for (int j = 1; j &lt;= n; j++) &#123; if (i == j) continue; ll x = a[j] * a[j] % mod - a[i] * a[i] % mod; x = (x + 2 * mod) % mod; t = t * Pow(x, mod - 2) % mod; &#125; ans = (ans + t * Pow(a[i], mod - 2) % mod) % mod; &#125; printf("%lld\n", ans * inv2 % mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Random Point in Triangle]]></title>
    <url>%2F2019%2F07%2F18%2FRandom-Point-in-Triangle%2F</url>
    <content type="text"><![CDATA[题目链接题意有一个三角形，在其中任意选一点P，定义其v为P分割出的三个小三角形中面积最大值，问v期望。 思路学会了个套路，不会算的话就模拟，答案一定是正比于总面积，计算系数就行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50struct node&#123; double x, y; node(double x = 0, double y = 0): x(x), y(y) &#123;&#125;&#125;;double dis(node a, node b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;double s(node a, node b, node c)&#123; double ab = dis(a, b); double bc = dis(b, c); double ac = dis(a, c); double p = (ab + bc + ac) / 2; return sqrt(p * (p - ab) * (p - bc) * (p - ac));&#125;int main()&#123; node p1 = node(0, 0); node p2 = node(1, 1); node p3 = node(2, 0); int t = 10000000; double cur = 0, ans = 0.0;// printf("%.6f\n", cur); srand((unsigned)time(NULL)); while (t--) &#123; double x, y; double ss; while (1) &#123; x = rand() % 1000000 * 2.0 / 1000000.0; y = rand() % 1000000 * 1.0 / 1000000.0; node nn = node(x, y); ss = max(s(p1, p2, nn), max(s(p1, p3, nn), s(p2, p3, nn))); if (isnan(ss)) continue; if (y &gt;= 0 &amp;&amp; x + y &lt;= 2 &amp;&amp; y - x &lt;= 0) break; &#125; cur += ss; if (cur &gt;= 1000000.0) &#123; ans += cur / 10000000.0; cur = 0.0; &#125; &#125; //printf("%.6f %.6f\n", ans, cur); ans += (double)cur / 10000000.0; printf("%.6f\n", ans * 36.0); return 0;&#125; 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;int main()&#123; ll x1, x2, x3, y1, y2, y3; while (scanf("%lld%lld%lld%lld%lld%lld", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3) != EOF) &#123; double S = 0.0; ll ans = 0; ans = 11 * ((x1 * y2 + y1 * x3 + x2 * y3) - (x1 * y3 + y2 * x3 + y1 * x2)); ans = abs(ans); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fraction Comparision]]></title>
    <url>%2F2019%2F07%2F18%2FFraction-Comparision%2F</url>
    <content type="text"><![CDATA[题目链接题意给两个分数，判断大小。 Code1234567891011while True: try: x, a, y, b = map(int, input().split()) except: break if x * b == a * y: print('=') elif x * b &gt; a * y: print('&gt;') elif x * b &lt; a * y: print('&lt;')]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>签到题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Equivalent Prefixes]]></title>
    <url>%2F2019%2F07%2F18%2FEquivalent-Prefixes%2F</url>
    <content type="text"><![CDATA[题目链接题意定义一个序列的$RMQ(u,l,r)$表示u_{l}到u_{r}的最小值的下标。称两个长度为$m$的序列$equivvalent$当$l \leq i \leq r,RMQ(u,l,r) = RMQ(v, l, r).$现在要求找到最大的$p$满足u_{1}..u_{p}与v_{1}..v_{p}是$equivalent$的。 思路贪心从第一个位置开始往后选，只要这个位置的起作用的范围两个数列是一样的就可以。 单调栈处理每个位置的作用范围，可以用单调栈搞定。这题算是单调晗的应用吧。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endifconst int N = 1e5 + 5;int a[N], b[N];int l[2][N], r[2][N];int pos[N], nxt[N], las[N];int n;stack&lt;int&gt; lcy;void get(int arr[], int a[], int st, int ed, int bd, int dir)&#123; while (!lcy.empty()) lcy.pop(); for (int i = st; i != ed; i += dir) &#123; while (!lcy.empty() &amp;&amp; a[i] &lt; a[lcy.top()]) lcy.pop(); if (lcy.empty()) arr[i] = bd; else arr[i] = lcy.top() + dir; lcy.push(i); &#125;&#125;int main()&#123; while (scanf("%d", &amp;n) != EOF) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); get(l[0], a, 1, n + 1, 1, 1); get(r[0], a, n, 0, n, -1); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;b[i]); get(r[1], b, n, 0, n, -1); get(l[1], b, 1, n + 1, 1, 1); int t = 1, war = n; for (int i = 2; i &lt;= war; i++) &#123; /* if (a[i] &lt; a[m1]) m1 = i; if (b[i] &lt; b[m2]) m2 = i; if (m1 == m2) t = i; */ if (l[0][i] == l[1][i]) &#123; if (min(r[0][i], i) == min(r[1][i], i)) &#123; t = i; if (r[0][i] != r[1][i]) war = min(war, min(r[0][i], r[1][i])); &#125; &#125; else break; //dbg(i, l[0][i], l[1][i], r[0][i], r[1][i], t, war); &#125; printf("%d\n", t); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2019多校赛</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>greedy</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Paths]]></title>
    <url>%2F2019%2F07%2F12%2FTwo-Paths%2F</url>
    <content type="text"><![CDATA[题目链接Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define ka1 getchar()#define iis std::ios::sync_with_stdio(false)using namespace std;typedef long long LL;const int N = 100005;const int INF = 0x3f3f3f3f;const LL mod = 10000;const double eps = 1e-8;struct lp&#123; int to; LL w; lp(int a,LL b)&#123;to=a;w=b;&#125; bool operator &lt;(const lp &amp;a)const &#123; if(w!=a.w) return w&gt;a.w; return to&lt;a.to; &#125;&#125;;vector&lt;lp&gt;mp[N];LL dis1[N],dis2[N];int n,m;void init()&#123; for(int i=0;i&lt;=n;++i)mp[i].clear();&#125;void dij(int s)&#123; memset(dis1,0x3f,sizeof(dis1)); memset(dis2,0x3f,sizeof(dis2)); dis1[s]=0; priority_queue&lt;lp&gt;Q; Q.push(lp(s,0)); while(!Q.empty() )&#123; lp x=Q.top();Q.pop(); int u=x.to; if(dis2[u]&lt;x.w)continue; for(int i=0;i&lt;mp[u].size();++i)&#123; lp y=mp[u][i]; if(dis2[y.to]&gt;(x.w+y.w))&#123; dis2[y.to]=x.w+y.w; Q.push(lp(y.to,dis2[y.to])); &#125; if(dis2[y.to]&lt;dis1[y.to])&#123; swap(dis2[y.to],dis1[y.to]); &#125; &#125; &#125; printf("%lld\n",dis2[n]);&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int a,b,c; scanf("%d%d",&amp;n,&amp;m); init(); for(int i=0;i&lt;m;++i)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); mp[a].push_back(lp(b,c)); mp[b].push_back(lp(a,c)); &#125; dij(1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Schedule]]></title>
    <url>%2F2019%2F07%2F12%2FSchedule%2F</url>
    <content type="text"><![CDATA[题目链接题意有若干个项目，时间冲突的项目不能在同一台机器上完成，问最少要多少台机器，这时最少要多少总时间。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;vector&lt;int&gt; des;int t_sum[2 * N];int st[N], ed[N];int mac_st[N], mac_ed[N];int get_id(int v)&#123; return lower_bound(des.begin(), des.end(), v) - des.begin() + 1;&#125;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;int main()&#123; int T; read(T); while (T--) &#123; int n; read(n); des.clear(); for (int i = 1; i &lt;= n; i++) &#123; read(st[i]); read(ed[i]); des.push_back(st[i]); des.push_back(ed[i]); &#125; sort(des.begin(), des.end()); des.erase(unique(des.begin(), des.end()), des.end()); for (int i = 1; i &lt;= n; i++) &#123; int p = get_id(st[i]); t_sum[p]++; p = get_id(ed[i]); t_sum[p]--; &#125; int k = 0, cur = 0;; for (int i = 0; i &lt;= des.size(); i++) &#123; if (i &gt; 0) t_sum[i] += t_sum[i - 1]; if (t_sum[i] &gt; k) &#123; while (k &lt; t_sum[i]) mac_st[++k] = i; &#125; &#125; cur = 0; int kk = 0; for (int i = des.size(); i &gt;= 0; i--) &#123; while (kk &lt; t_sum[i]) &#123; mac_ed[++kk] = i + 1; &#125; &#125; ll ans = 0; for (int i = 1; i &lt;= k; i++) ans += des[mac_ed[i] - 1] - des[mac_st[i] - 1]; printf("%d %lld\n", k, ans); for (int i = 0; i &lt;= des.size() + 1; i++) t_sum[i] = 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Monkeys]]></title>
    <url>%2F2019%2F07%2F12%2FMonkeys%2F</url>
    <content type="text"><![CDATA[题目链接Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 1e5 + 10;using namespace std;struct edge&#123; int v, next;&#125; f[maxn * 2];int head[maxn * 2], res, ans, vis[maxn * 2], kk, cnt = 0, n, tt, k;namespace IO&#123;#define BUF_SIZE 100000#define OUT_SIZE 100000#define ll long long //fread-&gt;read bool IOerror=0; inline char nc()&#123; static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if (p1==pend)&#123; p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if (pend==p1)&#123;IOerror=1;return -1;&#125; //&#123;printf("IO error!\n");system("pause");for (;;);exit(0);&#125; &#125; return *p1++; &#125; inline bool blank(char ch)&#123;return ch==' '||ch=='\n'||ch=='\r'||ch=='\t';&#125; inline void read(int &amp;x)&#123; bool sign=0; char ch=nc(); x=0; for (;blank(ch);ch=nc()); if (IOerror)return; if (ch=='-')sign=1,ch=nc(); for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())x=x*10+ch-'0'; if (sign)x=-x; &#125; inline void read(ll &amp;x)&#123; bool sign=0; char ch=nc(); x=0; for (;blank(ch);ch=nc()); if (IOerror)return; if (ch=='-')sign=1,ch=nc(); for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())x=x*10+ch-'0'; if (sign)x=-x; &#125; inline void read(double &amp;x)&#123; bool sign=0; char ch=nc(); x=0; for (;blank(ch);ch=nc()); if (IOerror)return; if (ch=='-')sign=1,ch=nc(); for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())x=x*10+ch-'0'; if (ch=='.')&#123; double tmp=1; ch=nc(); for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())tmp/=10.0,x+=tmp*(ch-'0'); &#125; if (sign)x=-x; &#125; inline void read(char *s)&#123; char ch=nc(); for (;blank(ch);ch=nc()); if (IOerror)return; for (;!blank(ch)&amp;&amp;!IOerror;ch=nc())*s++=ch; *s=0; &#125; inline void read(char &amp;c)&#123; for (c=nc();blank(c);c=nc()); if (IOerror)&#123;c=-1;return;&#125; &#125; //fwrite-&gt;write struct Ostream_fwrite&#123; char *buf,*p1,*pend; Ostream_fwrite()&#123;buf=new char[BUF_SIZE];p1=buf;pend=buf+BUF_SIZE;&#125; void out(char ch)&#123; if (p1==pend)&#123; fwrite(buf,1,BUF_SIZE,stdout);p1=buf; &#125; *p1++=ch; &#125; void print(int x)&#123; static char s[15],*s1;s1=s; if (!x)*s1++='0';if (x&lt;0)out('-'),x=-x; while(x)*s1++=x%10+'0',x/=10; while(s1--!=s)out(*s1); &#125; void println(int x)&#123; static char s[15],*s1;s1=s; if (!x)*s1++='0';if (x&lt;0)out('-'),x=-x; while(x)*s1++=x%10+'0',x/=10; while(s1--!=s)out(*s1); out('\n'); &#125; void print(ll x)&#123; static char s[25],*s1;s1=s; if (!x)*s1++='0';if (x&lt;0)out('-'),x=-x; while(x)*s1++=x%10+'0',x/=10; while(s1--!=s)out(*s1); &#125; void println(ll x)&#123; static char s[25],*s1;s1=s; if (!x)*s1++='0';if (x&lt;0)out('-'),x=-x; while(x)*s1++=x%10+'0',x/=10; while(s1--!=s)out(*s1); out('\n'); &#125; void print(double x,int y)&#123; static ll mul[]=&#123;1,10,100,1000,10000,100000,1000000,10000000,100000000, 1000000000,10000000000LL,100000000000LL,1000000000000LL,10000000000000LL, 100000000000000LL,1000000000000000LL,10000000000000000LL,100000000000000000LL&#125;; if (x&lt;-1e-12)out('-'),x=-x;x*=mul[y]; ll x1=(ll)floor(x); if (x-floor(x)&gt;=0.5)++x1; ll x2=x1/mul[y],x3=x1-x2*mul[y]; print(x2); if (y&gt;0)&#123;out('.'); for (size_t i=1;i&lt;y&amp;&amp;x3*mul[i]&lt;mul[y];out('0'),++i); print(x3);&#125; &#125; void println(double x,int y)&#123;print(x,y);out('\n');&#125; void print(char *s)&#123;while (*s)out(*s++);&#125; void println(char *s)&#123;while (*s)out(*s++);out('\n');&#125; void flush()&#123;if (p1!=buf)&#123;fwrite(buf,1,p1-buf,stdout);p1=buf;&#125;&#125; ~Ostream_fwrite()&#123;flush();&#125; &#125;Ostream; inline void print(int x)&#123;Ostream.print(x);&#125; inline void println(int x)&#123;Ostream.println(x);&#125; inline void print(char x)&#123;Ostream.out(x);&#125; inline void println(char x)&#123;Ostream.out(x);Ostream.out('\n');&#125; inline void print(ll x)&#123;Ostream.print(x);&#125; inline void println(ll x)&#123;Ostream.println(x);&#125; inline void print(double x,int y)&#123;Ostream.print(x,y);&#125; inline void println(double x,int y)&#123;Ostream.println(x,y);&#125; inline void print(char *s)&#123;Ostream.print(s);&#125; inline void println(char *s)&#123;Ostream.println(s);&#125; inline void println()&#123;Ostream.out('\n');&#125; inline void flush()&#123;Ostream.flush();&#125;#undef ll#undef OUT_SIZE#undef BUF_SIZE&#125;;using namespace IO;void init(int n)&#123; for(int i=1;i&lt;=n;i++) head[i]=-1; for(int i=1;i&lt;=n;i++) vis[i]=0;&#125;void add_edge(int u, int v)&#123; f[cnt].v = v; f[cnt].next = head[u]; head[u] = cnt++;&#125;void dfs(int u, int fa)&#123; for (int i = head[u]; i != -1; i = f[i].next) &#123; int v = f[i].v; if (v != fa &amp;&amp; v != u) &#123; dfs(v, u); if (vis[v] == 0 &amp;&amp; vis[u] == 0) &#123; vis[v] = 1; vis[u] = 1; tt++; &#125; &#125; &#125;&#125;int main()&#123; int T; read(T); while (T--) &#123; ans = 0; res = 0; cnt = 0; tt=0; read(n); read(k); init(n); for (int i = 1; i &lt;= n - 1; i++) &#123; int now; read(now); add_edge(now, i + 1); add_edge(i + 1, now); &#125; dfs(1, 0); if (2 * tt &lt; k) &#123; ans = k - tt; &#125; else ans = (k + 1) / 2; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array Challenge]]></title>
    <url>%2F2019%2F07%2F12%2FArray-Challenge%2F</url>
    <content type="text"><![CDATA[题目链接思路队友连答案的规律都能直接找出来，我只能提供一个矩阵。然后就过了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=14;typedef long long ll;const int N=10;const ll mo=1000000007;ll tmp[N][N];ll c[N][N],d[N][N];ll ans[5]=&#123;0,0,31,197,1255&#125;;void multi(ll a[][N],ll b[][N],int n)&#123; memset(tmp,0,sizeof (tmp)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++)&#123; tmp[i][j]+=a[i][k]*b[k][j]; tmp[i][j]%=mo;&#125; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) a[i][j]=tmp[i][j];&#125; ll res[N][N]; void Pow(ll a[][N],ll n,int cnt)&#123; memset(res,0,sizeof (res)); for(int i=0;i&lt;cnt;i++) res[i][i]=1; while(n) &#123; if(n&amp;1) multi(res,a,cnt); multi(a,a,cnt); n&gt;&gt;=1; &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; ll n; scanf("%lld",&amp;n); if(n&lt;=4) &#123;printf("%lld\n",ans[n]); continue;&#125; c[0][0]=4; c[0][1]=17; c[0][2]=-12; c[1][0]=1; c[1][1]=c[1][2]=c[2][0]=c[2][2]=0; c[2][1]=1; Pow(c,n-4,3); d[0][0]=ans[4]; d[1][0]=ans[3]; d[2][0]=ans[2]; multi(res,d,3); printf("%lld\n",(mo+res[0][0])%mo); &#125;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ch’s gift]]></title>
    <url>%2F2019%2F07%2F09%2FCh%E2%80%99s-gift%2F</url>
    <content type="text"><![CDATA[题目链接题意一棵树每个点有点权，m次询问，每次询问一条路径上点权在一个区间内的点有多少。 思路树链剖分+可持久化线段树在树上建可持久化线段树，维护树链剖分的id序列的权值数量。每次查询时候在树链上查主席树的结果。很不幸这种做法T掉了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;ll seg[N &lt;&lt; 5];int lson[N &lt;&lt; 5], rson[N &lt;&lt; 5];int root[N], val[N];int size[N], son[N], dep[N], id[N], top[N], fa[N];int cur;struct node&#123; int v, nxt;&#125;edge[2 * N];int head[N], tot, t;vector&lt;int&gt; des;void dfs1(int u, int f, int d)&#123; size[u] = 1; dep[u] = d; son[u] = -1; fa[u] = f; for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f) continue; dfs1(v, u, d + 1); size[u] += size[v]; if (son[u] == -1 || size[v] &gt; size[son[u]]) son[u] = v; &#125;&#125;/*void dfs2(int u, int f, int t)&#123; top[u] = t; id[u] = ++cur; if (son[u] != -1) dfs2(son[u], u, t); for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f || v == son[u]) continue; dfs2(v, u, v); &#125;&#125;*/void push_up(int rt)&#123; seg[rt] = seg[lson[rt]] + seg[rson[rt]];&#125;void update(int p, int old, int L, int R, int &amp;rt)&#123; rt = ++t; seg[rt] = seg[old]; lson[rt] = lson[old]; rson[rt] = rson[old]; if (L == R) &#123; seg[rt] += des[p - 1];// dbg(p, seg[rt]); return; &#125; int mid = (L + R) &gt;&gt; 1; if (p &lt;= mid) update(p, lson[old], L, mid, lson[rt]); else update(p, rson[old], mid + 1, R, rson[rt]); push_up(rt);&#125;int query(int l, int r, int L, int R, int rt)&#123;// dbg(l, r, L, R, rt); if (rt == 0) return 0; if (l &lt;= L &amp;&amp; r &gt;= R) return seg[rt]; int mid = (L + R) &gt;&gt; 1; int ans = 0; if (l &lt;= mid) ans += query(l, r, L, mid, lson[rt]); if (r &gt; mid) ans += query(l, r, mid + 1, R, rson[rt]);// dbg(ans); return ans;&#125;void dfs2(int u, int f, int t)&#123; top[u] = t; id[u] = ++cur; int p = lower_bound(des.begin(), des.end(), val[u]) - des.begin() + 1; update(p, root[cur - 1], 1, des.size(), root[cur]);// dbg(p, cur); if (son[u] != -1) dfs2(son[u], u, t); for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f || v == son[u]) continue; dfs2(v, u, v); &#125;&#125;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;void init(int n)&#123; for (int i = 1; i &lt;= n; i++) &#123; son[i] = -1; head[i] = -1; root[i] = 0; &#125; t = 0; tot = 0; lson[0] = rson[0] = 0; seg[0] = 0; root[0] = 0; cur = 0; des.clear();&#125;void add_edge(int u, int v)&#123; edge[++tot].v = v; edge[tot].nxt = head[u]; head[u] = tot;&#125;int get_ans(int u, int v, int a, int b)&#123;// dbg(u, v, a, b); int ans = 0; a = lower_bound(des.begin(), des.end(), a) - des.begin() + 1; b = upper_bound(des.begin(), des.end(), b) - des.begin(); while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); ans += query(a, b, 1, des.size(), root[id[u]]) - query(a, b, 1, des.size(), root[id[top[u]] - 1]);// dbg(u, v, top[u], top[v], ans); u = fa[top[u]]; &#125; if (dep[u] &gt; dep[v]) swap(u, v);// dbg(u, v, a, b, id[u], id[v]); ans += query(a, b, 1, des.size(), root[id[v]]) - query(a, b, 1, des.size(), root[id[u] - 1]); return ans;&#125;int main()&#123; int n, m; while (scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; init(n); for (int i = 1; i &lt;= n; i++) &#123; read(val[i]); des.push_back(val[i]); &#125; des.push_back(0); des.push_back(0x3f3f3f3f); for (int i = 1; i &lt; n; i++) &#123; int u, v; read(u); read(v); add_edge(u, v); add_edge(v, u); &#125; sort(des.begin(), des.end()); des.erase(unique(des.begin(), des.end()), des.end()); dfs1(1, 0, 1); dfs2(1, 0, 1); while (m--) &#123; int u, v, a, b; read(u); read(v); read(a); read(b); printf("%d ", get_ans(u, v, a, b)); &#125; putchar('\n'); &#125; return 0;&#125; 赛后我自己去测试，这种做法跑最大的数据比正解慢很多。12345678910111213141516171819203.86user 0.04system 0:03.91elapsed 99%CPU (0avgtext+0avgdata 21884maxresident)k0inputs+9824outputs (0major+4724minor)pagefaults 0swaps13.40user 0.10system 0:13.52elapsed 99%CPU (0avgtext+0avgdata 36392maxresident)k0inputs+9824outputs (0major+8545minor)pagefaults 0swapsAC3.86user 0.03system 0:03.90elapsed 99%CPU (0avgtext+0avgdata 21784maxresident)k0inputs+9824outputs (0major+4725minor)pagefaults 0swaps13.45user 0.09system 0:13.55elapsed 99%CPU (0avgtext+0avgdata 36288maxresident)k0inputs+9824outputs (0major+8546minor)pagefaults 0swapsAC3.86user 0.04system 0:03.91elapsed 99%CPU (0avgtext+0avgdata 21884maxresident)k0inputs+9808outputs (0major+4724minor)pagefaults 0swaps13.65user 0.09system 0:13.77elapsed 99%CPU (0avgtext+0avgdata 36292maxresident)k0inputs+9808outputs (0major+8546minor)pagefaults 0swapsAC3.95user 0.03system 0:03.98elapsed 99%CPU (0avgtext+0avgdata 21784maxresident)k0inputs+9816outputs (0major+4726minor)pagefaults 0swaps13.90user 0.07system 0:13.99elapsed 99%CPU (0avgtext+0avgdata 36288maxresident)k0inputs+9816outputs (0major+8545minor)pagefaults 0swapsAC 离线树状数组（或线段树）+树链剖分这个做法也很好理解，但是开始的时候深陷主席树的泥潭不能自拔。离线求出小于等于某个数字的点有多少，查询结果的时候用之前离线处理的点相减就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;ll val[N];int size[N], son[N], dep[N], id[N], top[N], fa[N];int cur;struct node&#123; int v, nxt;&#125;edge[2 * N];int head[N], tot, t;// vector&lt;int&gt; des;ll sum[N];int lowbit(int x)&#123; return x &amp; (-x);&#125;void add(int x, ll v)&#123; while (x &lt;= cur) &#123;// dbg(x); sum[x] += v; x += lowbit(x); &#125;&#125;ll query(int x)&#123; ll ans = 0; while (x) &#123; ans += sum[x]; x -= lowbit(x); &#125; return ans;&#125;void dfs1(int u, int f, int d)&#123; size[u] = 1; dep[u] = d; son[u] = -1; fa[u] = f; for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f) continue; dfs1(v, u, d + 1); size[u] += size[v]; if (son[u] == -1 || size[v] &gt; size[son[u]]) son[u] = v; &#125;&#125;/*void dfs2(int u, int f, int t)&#123; top[u] = t; id[u] = ++cur; if (son[u] != -1) dfs2(son[u], u, t); for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f || v == son[u]) continue; dfs2(v, u, v); &#125;&#125;void push_up(int rt)&#123; seg[rt] = seg[lson[rt]] + seg[rson[rt]];&#125;void update(int p, int old, int L, int R, int &amp;rt)&#123; rt = ++t; seg[rt] = seg[old]; lson[rt] = lson[old]; rson[rt] = rson[old]; if (L == R) &#123; seg[rt] += des[p - 1];// dbg(p, seg[rt]); return; &#125; int mid = (L + R) &gt;&gt; 1; if (p &lt;= mid) update(p, lson[old], L, mid, lson[rt]); else update(p, rson[old], mid + 1, R, rson[rt]); push_up(rt);&#125;int query(int l, int r, int L, int R, int rt)&#123;// dbg(l, r, L, R, rt); if (rt == 0) return 0; if (l &lt;= L &amp;&amp; r &gt;= R) return seg[rt]; int mid = (L + R) &gt;&gt; 1; int ans = 0; if (l &lt;= mid) ans += query(l, r, L, mid, lson[rt]); if (r &gt; mid) ans += query(l, r, mid + 1, R, rson[rt]);// dbg(ans); return ans;&#125;*/void dfs2(int u, int f, int t)&#123; top[u] = t; id[u] = ++cur;// update(p, root[cur - 1], 1, des.size(), root[cur]);// dbg(p, cur); if (son[u] != -1) dfs2(son[u], u, t); for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f || v == son[u]) continue; dfs2(v, u, v); &#125;&#125;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;void init(int n)&#123; for (int i = 1; i &lt;= n; i++) &#123; son[i] = -1; head[i] = -1; &#125; tot = 0; cur = 0;// des.clear(); memset(sum, 0, sizeof(sum));&#125;void add_edge(int u, int v)&#123; edge[++tot].v = v; edge[tot].nxt = head[u]; head[u] = tot;&#125;ll get_ans(int u, int v)&#123;// dbg(u, v, a, b); ll ans = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); //ans += query(a, b, 1, des.size(), root[id[u]]) - query(a, b, 1, des.size(), root[id[top[u]] - 1]); ans += query(id[u]) - query(id[top[u]] - 1);// dbg(u, v, top[u], top[v], ans); u = fa[top[u]]; &#125; if (dep[u] &gt; dep[v]) swap(u, v);// dbg(u, v, a, b, id[u], id[v]);// ans += query(a, b, 1, des.size(), root[id[v]]) - query(a, b, 1, des.size(), root[id[u] - 1]); ans += query(id[v]) - query(id[u] - 1); return ans;&#125;struct nn&#123; int a, b, u, v, id;/* int to1, to2; bool operator &lt; (const nn&amp; w) const &#123; return id &lt; w.id; &#125;*/&#125;que[N];struct wa&#123; int a, u, v; ll ans; int type; wa (int u = 0, int v = 0, int a = 0, int type = 0): u(u), v(v), a(a), type(type) &#123;&#125;&#125;wai[N * 3];int num[3 * N];bool cmp(int a, int b)&#123; if (wai[a].a == wai[b].a) return wai[a].type &lt; wai[b].type; return wai[a].a &lt; wai[b].a;&#125;int main()&#123; int n, m; while (scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; init(n); for (int i = 1; i &lt;= n; i++) &#123; read(val[i]); &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; read(u); read(v); add_edge(u, v); add_edge(v, u); &#125; dfs1(1, 0, 1); dfs2(1, 0, 1); int now = 0; for (int i = 1; i &lt;= m; i++) &#123; int u, v, a, b; read(que[i].u); read(que[i].v); read(que[i].a); read(que[i].b); wai[++now] = wa(que[i].u, que[i].v, que[i].a - 1, 2); num[now] = now; wai[++now] = wa(que[i].u, que[i].v, que[i].b, 2); num[now] = now; &#125; for (int i = 1; i &lt;= n; i++) wai[++now] = wa(i, 0, val[i], 1), num[now] = now; sort(num + 1, num + now + 1, cmp); for (int i = 1; i &lt;= now; i++) &#123;// dbg(i, wai[num[i]].u, wai[num[i]].type, num[i]); if (wai[num[i]].type == 2) wai[num[i]].ans = get_ans(wai[num[i]].u, wai[num[i]].v); else add(id[wai[num[i]].u], wai[num[i]].a); &#125; for (int i = 1; i &lt;= m; i++) printf("%lld%c", wai[2 * i].ans - wai[2 * i - 1].ans, i == m? '\n': ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFF at Valentine]]></title>
    <url>%2F2019%2F07%2F09%2FFFF-at-Valentine%2F</url>
    <content type="text"><![CDATA[题目链接Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int maxn=1010;const int maxm=6010;vector&lt;int&gt; vec[maxn];int vis[maxn];int graph[maxn][maxn];void dfs(int u)&#123; vis[u]=1; for(int i=0;i&lt;vec[u].size();i++)&#123; int v=vec[u][i]; if(vis[v]) continue; dfs(v); &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; vec[i].clear(); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; graph[i][j]=0; &#125; &#125; bool flag=true; for(int i=1;i&lt;=m;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); vec[u].push_back(v); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; vis[j]=0; &#125; dfs(i); for(int j=1;j&lt;=n;j++)&#123; if(vis[j]) graph[i][j]=1; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; if(i==j) continue; //cout&lt;&lt;graph[i][j]&lt;&lt;" "&lt;&lt;i&lt;&lt; " "&lt;&lt;j&lt;&lt;" "&lt;&lt;graph[j][i]&lt;&lt;endl; if(graph[i][j]==1 || graph[j][i]==1)continue; flag=false; break; &#125; &#125; if(flag) printf("I love you my love and our love save us!\n"); else printf("Light my fire!\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>强连通</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two String]]></title>
    <url>%2F2019%2F07%2F09%2FTwo-String%2F</url>
    <content type="text"><![CDATA[题目链接题意判断两个字符串是否匹配，匹配规则按照正则表达式的’.’和’*’来。 思路第一开始暴力匹配真的是傻。 dp$dp[i][j]$表示第一个字符串到位置$i$，第二个字符串到位置$j$能否匹配。只有三种情况的转。三种情况考虑仔细，具体看代码。这题边界有点难处理。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 2505;int dp[N][N];char s[N], t[N];int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%s%s", s+1, t+1); int lens = strlen(s+1), lent = strlen(t+1); memset(dp, 0, sizeof(dp)); dp[0][0] = 1; if(t[2]=='*')&#123; dp[0][2]=1; &#125; for (int i = 0; i &lt;= lens; i++) &#123; for (int j = 1; j &lt;=lent; j++) &#123; if(t[j] == '.') dp[i][j]=dp[i-1][j-1]; else if(t[j] == '*') &#123; dp[i][j]=max(dp[i][j-1],dp[i][j-2]); if(s[i]==s[i-1] &amp;&amp; dp[i-1][j]==1) dp[i][j]=1; &#125; else if(t[j]==s[i]) dp[i][j]=dp[i-1][j-1]; &#125; &#125; printf("%s\n", dp[lens][lent]? "yes":"no"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numbers]]></title>
    <url>%2F2019%2F07%2F09%2FNumbers%2F</url>
    <content type="text"><![CDATA[题目链接题意有一个数列$a$，从中任意挑出两个相加，可以形成一个新的数列$b$。现在把两个数列混在一起，问哪些是属于数列$a$的。 思路贪心因为所有数字都是正数，所以最小的一个数字一定是数列$a$的。我们可以把所有备用的已知的和记录一下，然后获得的数字如果是我们已经记录下来的要出现的，那么就把那个数字除掉。否则就是$a$数列的，其实每一次就是看新的数字是不是在我们已知的$b$数列范围里。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 505;int a[N], to[125500];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;int main()&#123; int n; while (scanf("%d", &amp;n) != EOF) &#123; while (!pq.empty()) pq.pop(); int cur = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;to[i]); if (!pq.empty() &amp;&amp; to[i] == pq.top()) &#123; pq.pop(); continue; &#125; for (int j = 1; j &lt;= cur; j++) pq.push(to[i] + a[j]); a[++cur] = to[i]; //dbg(cur, a[cur]); &#125; printf("%d\n", cur); for (int i = 1; i &lt;= cur; i++) printf("%d%c", a[i], i == cur? '\n':' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树上点分治]]></title>
    <url>%2F2019%2F07%2F07%2F%E6%A0%91%E4%B8%8A%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[点分治树上点分治 其实就是把序列的分治方法移到了树上操作。序列上每个点的后继只有一个，树上可以有很多，我们找一个分支最多的出去，在不考虑常数的的情况下，这种分治方法是非常划算的。 静态分治关于点分治的思想我不再赘述，很多博客已经讲得很清楚了。我们实现上面代码，主要为下面几个函数。 寻找重心在树上找重心的操作其实相当于在序列上找中点。1int mid = (l + r) &gt;&gt; 1; 而我们在树上是这样操作的。1234567891011121314151617void getroot(int u, int f)&#123; size[u] = 1; mxs[u] = 0; for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (vis[v] || v == f) continue; getroot(v, u); size[u] += size[v]; mxs[u] = max(mxs[u], size[v]); &#125; mxs[u] = max(mxs[u], tsize - size[u]); if (mxs[u] &lt; mxs[root]) root = u;&#125; （其实就是树上跑个dp） 分治得到重心之后，我们分治重心的每个分支，最后相当于pushup上来。注意在这个函数里要进行一些找重心的初始化。12345678910111213141516void solve(int u, int f)&#123; vis[u] = 1; ans += get(u, 0); //治 for (int it = head[u]; it != -1; it = edge[it].nxt) //分 &#123; int v = edge[it].v; if (v == f || vis[v]) continue; ans -= get(v, edge[it].d); //治 root = 0; tsize = size[v]; getroot(v, 0); solve(root, u); &#125;&#125; 计算每个分支的答案这一部分就是我们随意发挥的地方了，我们可以在这里进行一些复杂度约为O(n)计算，达到和序列分治类似甚至更优的效果。 POJ1741以此题为例，我们来搞一波树上点分治。在大部分博客中，分治部分代码对小子树大小的计算方法我觉得有问题，于是后来自己在原来我的AC代码上做了一番修改，貌似还是有几十毫秒的改进的。虽然原来方法复杂度也不是很高，但是在那样的基础上计算会影响我们对树上动态点分治的理解，因为那样每次不一定找到的是重心。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;const int N = 1e4 + 5;struct node&#123; int v, nxt, d;&#125;edge[2 * N];int head[N], tot;int size[N], root, mxs[N], vis[N], tsize;int cnt[N], k;void init(int n)&#123; for (int i = 1; i &lt;= n; i++) head[i] = -1, vis[i] = 0; root = 0; tot = 0; tsize = n; mxs[0] = 0x3f3f3f3f;&#125;void addedge(int u, int v, int d)&#123; edge[++tot].v = v; edge[tot].nxt = head[u]; edge[tot].d = d; head[u] = tot;&#125;void getroot(int u, int f)&#123; size[u] = 1; mxs[u] = 0; for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (vis[v] || v == f) continue; getroot(v, u); size[u] += size[v]; mxs[u] = max(mxs[u], size[v]); &#125; mxs[u] = max(mxs[u], tsize - size[u]); if (mxs[u] &lt; mxs[root]) root = u;&#125;int cur = 0;ll ans = 0;void calc(int u, int f, int d)&#123; cnt[++cur] = d; size[u] = 1; for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f || vis[v]) continue; calc(v, u, d + edge[it].d); size[u] += size[v]; &#125;&#125;int get(int u, int d)&#123; cur = 0; calc(u, 0, d); sort(cnt + 1, cnt + cur + 1); int head = 1, tail = cur; int ret = 0; while (head &lt; tail) &#123; if (cnt[head] + cnt[tail] &lt;= k) &#123; ret += tail - head; head++; &#125; else tail--; &#125; return ret;&#125;void solve(int u, int f)&#123;// dbg(u); vis[u] = 1; ans += get(u, 0); for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f || vis[v]) continue; ans -= get(v, edge[it].d); root = 0; tsize = size[v];// puts("getroot");// dbg(v, tsize); getroot(v, 0); solve(root, u); &#125;&#125;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;int main()&#123; int n; while (true) &#123; read(n); read(k); if (n == 0 &amp;&amp; k == 0) break; init(n); for (int i = 1; i &lt; n; i++) &#123; int u, v, d; read(u); read(v); read(d); addedge(u, v, d); addedge(v, u, d); &#125; ans = 0; root = 0; getroot(1, 0); solve(root, 0); printf("%lld\n", ans); &#125; return 0;&#125; 动态点分治有了前面的基础，我们来了解一下动态点分治。 动态在哪里我们之所以将这种点分治和之前加以区分，是因为这一类题目会要求可以做一些修改，而显而易见我们不能每次暴力修改然后查询的时候用O(nlog(n))时间去查询，这是十分爆炸的。 解决方案还是考虑分治的时候，如果我们要求修改某一个点，那么我们可以像线段树那样每次取一半，看看要修改的点在哪个区间，然后向上层push。我们这样只去修改会受到影响的log(n)级别个区间，查询类似。为了方便快捷地知道我们后面该往哪里走，先预处理出一棵点分树，在这棵树上是我们寻找重心的顺序，后面将会用到这棵树。 点分树这棵树是由我们原本的树建出来的，但是树形又和原来不同。点分树的父子关系，是由原树的分治顺序决定的，也就是说，我们寻找重心的时候的顺序，其实应该是点分树上的遍历顺序。既然这样，那我们的数其实也是比较好建立了。12345678910111213141516inline void get_tree(int u, int f)&#123; //dbg(u); vis[u] = 1; fa[u] = f; for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (vis[v]) continue; root = 0; tsz = size[v]; get_root(v, u, 1); get_tree(root, u); &#125;&#125; 使用点分树我们要这样一棵树有什么用呢？其实理解树上点分治的话，就会觉得这棵树其实是很有必要的。我们要维护这棵树上的一些父子关系。分治的过程，我们要知道当前这一部分要往哪个点合并，知道方向我们才好处理。为了不用每次都去get_root，我们预先把所有点父子关系存下来。就像我们在归并的时候向上返回，总要做些处理，如果当前区间已经覆盖了要修改或查询的点，直接返回，否则分半去修改或查询。使用方法需要随机应变的。 BZOJ3730 震波123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50#define lowbit(x) ((x)&amp;-(x))const int N = 1e5 + 5;struct node&#123; int v, nxt;&#125;edge[2 * N];int tot, head[N], val[N], vis[N];int dep[N];inline void add_edge(int u, int v)&#123; edge[++tot].v = v; edge[tot].nxt = head[u]; head[u] = tot;&#125;int root, tsz, mxs[N], size[N], fa[N], dis[N];vector&lt;ll&gt; sum[2][N];inline void init(int n)&#123; for (int i = 1; i &lt;= n; i++) &#123; head[i] = -1; vis[i] = 0; sum[0][i].clear(); sum[1][i].clear(); &#125; root = 0; mxs[0] = 0x3f3f3f3f; tsz = n; tot = 0;&#125;/* //树链剖分求lcaT掉了，后来改了ST表int Dep[N], son[N], Top[N], pa[N];inline void dfs1(int u, int f, int d)&#123; Dep[u] = d; son[u] = -1; size[u] = 1; pa[u] = f; for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f) continue; dfs1(v, u, d + 1); size[u] += size[v]; if (son[u] == -1 || size[v] &gt; size[u]) son[u] = v; &#125;&#125;inline void dfs2(int u, int f, int t)&#123; Top[u] = t; if (son[u] != -1) dfs2(son[u], u, t); for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f || v == son[u]) continue; dfs2(v, u, v); &#125;&#125;*/int st[2 * N], cur, Dep[N];int first[N];inline void dfs(int u, int f)&#123; st[++cur] = u; first[u] = cur; Dep[u] = Dep[f] + 1; for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f) continue; dfs(v, u); st[++cur] = u; &#125;&#125;int dp[N * 2][20];void rmq_pre()&#123; for (int i = 1; i &lt;= cur; i++) dp[i][0] = st[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= cur; j++) for (int i = 1; i + (1 &lt;&lt; j) &lt;= cur + 1; i++) &#123; int d1 = Dep[dp[i][j - 1]], d2 = Dep[dp[i + (1 &lt;&lt; (j - 1))][j - 1]]; if (d1 &lt; d2) dp[i][j] = dp[i][j - 1]; else dp[i][j] = dp[i + (1 &lt;&lt; (j - 1))][j - 1]; &#125;&#125;inline int rmq(int l, int r)&#123; int k = 31 - __builtin_clz(r - l + 1); int d1 = dp[l][k], d2 = dp[r - (1 &lt;&lt; k) + 1][k]; if (d1 &lt; d2) return dp[l][k]; return dp[r - (1 &lt;&lt; k) + 1][k];&#125;inline int lca(int u, int v)&#123; /* while (Top[u] != Top[v]) &#123; if (Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v); u = pa[Top[u]]; &#125; if (Dep[u] &lt; Dep[v]) return u; else return v; */ if (first[u] &gt; first[v]) swap(u, v); return rmq(first[u], first[v]);&#125;inline int Dis(int u, int v)&#123; int ca = lca(u, v); return Dep[u] + Dep[v] - 2 * Dep[ca];&#125;inline void get_root(int u, int f, int d)&#123;// dbg(u, d); size[u] = 1; mxs[u] = 0; dep[u] = d; for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (vis[v] || v == f) continue; get_root(v, u, d + 1); size[u] += size[v]; mxs[u] = max(mxs[u], size[v]); &#125; mxs[u] = max(mxs[u], tsz - size[u]); if (mxs[u] &lt; mxs[root]) root = u;&#125;/*inline int lowbit(int x)&#123; return x &amp; (-x);&#125;*/inline void update(int bla, int id, int x, int val)&#123; while (x &lt; sum[bla][id].size()) &#123; sum[bla][id][x] += val; x += lowbit(x); &#125;&#125;inline ll query(int bla, int id, int x)&#123; ll ans = 0; if (x &gt;= sum[bla][id].size()) x = sum[bla][id].size() - 1; // dbg(id, x); while (x &gt; 0) &#123; ans += sum[bla][id][x]; x -= lowbit(x); &#125; return ans;&#125;inline pair&lt;int, int&gt; get_dep(int u, int f, int d)&#123; pair&lt;int, int&gt; ans = make_pair(d, dep[u]); for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (vis[v] || v == f) continue; pair&lt;int, int&gt; tmp = get_dep(v, u, d + 1); ans.first = max(ans.first, tmp.first); ans.second = max(ans.second, tmp.second); &#125; return ans;&#125;inline void calc(int u, int f, int top, int d)&#123; size[u] = 1; update(0, top, d, val[u]); //dbg(top, d, val[u], u); for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (vis[v] || v == f) continue; calc(v, u, top, d + 1); size[u] += size[v]; &#125;&#125;inline void calc2(int u, int f, int top)&#123; update(1, top, dep[u], val[u]); for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (vis[v] || v == f) continue; calc2(v, u, top); &#125;&#125;inline void get_tree(int u, int f)&#123; //dbg(u); vis[u] = 1; fa[u] = f; pair&lt;int, int&gt; mxd = get_dep(u, 0, 0); sum[0][u].resize(mxd.first + 1); sum[1][u].resize(mxd.second + 1); calc2(u, f, u);// dbg(u, ans); for (int it = head[u]; it != -1; it = edge[it].nxt) &#123; int v = edge[it].v; if (vis[v]) continue; calc(v, u, u, 1); //dbg(u, v, ans); root = 0; tsz = size[v]; get_root(v, u, 1); get_tree(root, u); &#125;// update(1, u, dep[u], val[u]);&#125;inline ll s_que(int u, int k)&#123; ll ans = val[u] + query(0, u, k); //dbg(u, k, query(0, u, k), ans); int tmp = u; while (fa[tmp]) &#123; int d1 = Dis(fa[tmp], u); if (k - d1 &gt;= 0) ans += query(0, fa[tmp], k - d1) - query(1, tmp, k - d1) + (k - d1 &gt;= 0) * val[fa[tmp]]; //dbg(tmp, fa[tmp], d1, k - d1, k, query(0, fa[tmp], k - d1), query(1, tmp, k - d1), ans); tmp = fa[tmp]; &#125; return ans;&#125;inline void s_update(int u, int v)&#123; ll del = v - val[u]; int tmp = u; while (fa[tmp]) &#123; int dis = Dis(u, fa[tmp]); update(0, fa[tmp], dis, del); update(1, tmp, dis, del); tmp = fa[tmp]; &#125; val[u] = v;&#125;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' | c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;int main()&#123; int n, m; read(n), read(m); init(n); //puts("init over"); for (int i = 1; i &lt;= n; i++) read(val[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; read(u); read(v); add_edge(u, v); add_edge(v, u); &#125; /* dfs1(1, 0, 1); dfs2(1, 0, 1); */ Dep[0] = 0; dfs(1, 0); rmq_pre(); get_root(1, 0, 1); get_tree(root, 0); ll ans = 0; while (m--) &#123; int type; read(type); if (type == 0) &#123; int u, k; read(u); read(k); u ^= ans; k ^= ans; printf("%lld\n", ans = s_que(u, k)); &#125; else &#123; int u, v; read(u); read(v); u ^= ans; v ^= ans; s_update(u, v); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitset]]></title>
    <url>%2F2019%2F07%2F07%2FBitset%2F</url>
    <content type="text"><![CDATA[Bitset是什么 我们常常用一个数字的二进制表现一个集合中的子集，但是由于我们最大常用数字也就是longlong，所以能表示的集合大小是比较小的。 大集合我们怎么表示呢？在空间压缩的不太紧张的情况下，一般都是选择用数组来替代位，这样理解起来很直观。但有个缺点，我们空间浪费十分严重，而且没法快速做集合运算，如异或、与、或等。 bitset应运而生，它的每个位只占一个bit，这为我们大大节省了空间。而且它也支持如同数字之间的与、或、异或操作。 stl 我们看一下C++的stl中的bitset，它实现了一个类似我们上面所描述的那样的功能。 我们可以参考C++Refence来使用它。最常用的几个函数有： 123456bitset&lt;size&gt; bt; //constructor functionbt[i]; //get bitbt.count(); //get the number of "1" in bitsetbt.set(i); //set the position i to "1"bt.reset(); //reset all bitsbt.flip(); //flip some position 优化 学习stl的最好方法就是多用它，做完几道模板题之后我们发现，这样的结果虽然能做对，但是速度并不是很高效，在vjudge上看看别人的代码，发现很多人都自己写了一套bitset，我们意识到，或许C++给我们的bitset并不是那么优秀。 我们可以自己写一套用int去压二进制位实现bitset的模板。 手写bitset 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253 #include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int SN = 1005;const int N = 5e5 + 5;unsigned int BitReverse(unsigned int x)&#123; static unsigned int a[1 &lt;&lt; 16 | 1], now = 1; if(now) &#123; a[0] = now = 0; for (int i = 1; i &lt; 1 &lt;&lt; 16; i++) a[i] = (a[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; 15); &#125; return a[x &gt;&gt; 16] | (a[x &amp; 65535] &lt;&lt; 16);&#125;int BitNum(unsigned int x)&#123; static unsigned int a[1 &lt;&lt; 16 | 1], now = 1; if (now) &#123; a[0] = now = 0; for (int i = 1; i &lt; 1 &lt;&lt; 16; i++) a[i] = a[i &gt;&gt; 1] + (i &amp; 1); &#125; return a[x &gt;&gt; 16] + a[x &amp; 65535];&#125;struct Bitset &#123; static const int BIT = 32; static const int SIZE = SN / BIT + 1; unsigned int a[SIZE]; Bitset(); unsigned int &amp; operator [] (const int); const unsigned int &amp; operator [] (const int) const; Bitset operator &amp; (const Bitset &amp;) const; Bitset operator | (const Bitset &amp;) const; Bitset operator ^ (const Bitset &amp;) const; Bitset operator &lt;&lt; (int) const; Bitset operator &gt;&gt; (int) const; Bitset &amp; operator &amp;= (const Bitset &amp;); Bitset &amp; operator |= (const Bitset &amp;); Bitset &amp; operator ^= (const Bitset &amp;); Bitset &amp; operator &lt;&lt;= (int); Bitset &amp; operator &gt;&gt;= (int); Bitset operator ~ () const; // reverse the binary bit in [0, x) // "000110010".Reverse(5) = "000001001" Bitset Reverse(int x) const ; // set the xth binary bit value to f void Set(int x, bool f = true); // set all binary bit value to 0 void Clear(); // return the xth binary bit value bool CheckBit(int x) const ; // return the number of one in binary bit value int AllBit() const; void Flip(int x);&#125;s[N];Bitset::Bitset()&#123; memset(a, 0, sizeof a);&#125;unsigned int &amp; Bitset::operator [] (const int x)&#123; return a[x];&#125;const unsigned int &amp; Bitset::operator [] (const int x) const&#123; return a[x];&#125;Bitset Bitset::operator &amp; (const Bitset &amp;x) const&#123; Bitset ans; for (int i = 0; i &lt; SIZE; i++) ans[i] = x[i] &amp; a[i]; return ans;&#125;Bitset Bitset::operator | (const Bitset &amp;x) const&#123; Bitset ans; for (int i = 0; i&lt; SIZE; i++) ans[i] = x[i] | a[i]; return ans;&#125;Bitset Bitset::operator ^ (const Bitset &amp;x) const&#123; Bitset ans; for (int i = 0; i &lt; SIZE; i++) ans[i] = x[i] ^ a[i]; return ans;&#125;Bitset Bitset::operator &lt;&lt; (int x) const&#123; Bitset ans; int y = x &gt;&gt; 5, z = x &amp; 31; if (z) for (int i = SIZE - 1; i &gt;= y + 1; i--) ans[i] = (a[i - y] &lt;&lt; z) | (a[i - y - 1] &gt;&gt; (BIT - z)); else for (int i = SIZE - 1; i &gt;= y + 1; i--) ans[i] = a[i - y]; ans[y] = a[0] &lt;&lt; z; return ans;&#125;Bitset Bitset::operator &gt;&gt; (int x) const&#123; Bitset ans; int y = x &gt;&gt; 5, z = x &amp; 31; if(z) for (int i = 0; i &lt; SIZE - y - 1; i++) ans[i] = (a[i + y] &gt;&gt; z) | (a[i + y + 1] &lt;&lt; (BIT - z)); else for (int i = 0; i &lt; SIZE - y - 1; i++) ans[i] = a[i + y]; ans[SIZE - y - 1] = a[SIZE - 1] &gt;&gt; z; return ans;&#125;Bitset &amp; Bitset::operator &amp;= (const Bitset &amp;x)&#123; for (int i = 0; i &lt; SIZE; i++) a[i] &amp;= x[i]; return *this;&#125;Bitset &amp; Bitset::operator |= (const Bitset &amp;x)&#123; for (int i = 0; i &lt; SIZE; i++) a[i] |= x[i]; return *this;&#125;Bitset &amp; Bitset::operator ^= (const Bitset &amp;x)&#123; for (int i = 0; i &lt; SIZE; i++) a[i] ^= x[i]; return *this;&#125;Bitset &amp; Bitset::operator &lt;&lt;= (int x)&#123; int y = x &gt;&gt; 5, z = x &amp; 31; if(z) for (int i = SIZE - 1; i &gt;= y + 1; i--) a[i] = (a[i - y] &lt;&lt; z) | (a[i - y - 1] &gt;&gt; (BIT - z)); else for (int i = SIZE - 1; i &gt;= y + 1; i--) a[i] = a[i - y]; a[y] = a[0] &lt;&lt; z; for (int i = 0; i &lt; y; i++) a[i] = 0; return *this;&#125;Bitset &amp; Bitset::operator &gt;&gt;= (int x)&#123; int y = x &gt;&gt; 5, z = x &amp; 31; if(z) for (int i = 0; i &lt; SIZE - y - 1; i++) a[i] = (a[i + y] &gt;&gt; z) | (a[i + y + 1] &lt;&lt; (BIT - z)); else for (int i = 0; i &lt; SIZE - y - 1; i++) a[i] = a[i + y]; a[SIZE - y - 1] = a[SIZE - 1] &gt;&gt; z; for (int i = SIZE - y; i &lt; SIZE; i++) a[i] = 0; return *this;&#125;Bitset Bitset::operator ~ () const&#123; Bitset ans; for (int i = 0; i &lt; SIZE; i++) ans[i] = ~a[i]; return ans;&#125;Bitset Bitset::Reverse(int x) const&#123; Bitset ans; int y = x &gt;&gt; 5, z = x &amp; 31; for (int i = 0; i &lt;= y; i++) ans[i] = BitReverse(a[y - i]); return ans &gt;&gt; (BIT - z);&#125;void Bitset::Set(int x, bool f)&#123; int y = x &gt;&gt; 5, z = x &amp; 31; a[y] |= 1 &lt;&lt; z; if (!f) a[y] ^= 1 &lt;&lt; z;&#125;void Bitset::Clear()&#123; memset(a, 0, sizeof a);&#125;int Bitset::AllBit() const&#123; int ans = 0; for (int i= 0; i &lt; SIZE; i++) ans += BitNum(a[i]); return ans;&#125;bool Bitset::CheckBit(int x) const&#123; int y = x &gt;&gt; 5, z = x &amp; 31; return a[y] &gt;&gt; z &amp; 1;&#125;void Bitset::Flip(int x)&#123; int y = x &gt;&gt; 5, z = x &amp; 31; a[y] ^= 1 &lt;&lt; z;&#125; 效果 POJ2443是一道bitset模板题，我们不如来试试我们的bitset。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int SN = 1005;const int N = 5e5 + 5;unsigned int BitReverse(unsigned int x)&#123; static unsigned int a[1 &lt;&lt; 16 | 1], now = 1; if(now) &#123; a[0] = now = 0; for (int i = 1; i &lt; 1 &lt;&lt; 16; i++) a[i] = (a[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; 15); &#125; return a[x &gt;&gt; 16] | (a[x &amp; 65535] &lt;&lt; 16);&#125;int BitNum(unsigned int x)&#123; static unsigned int a[1 &lt;&lt; 16 | 1], now = 1; if (now) &#123; a[0] = now = 0; for (int i = 1; i &lt; 1 &lt;&lt; 16; i++) a[i] = a[i &gt;&gt; 1] + (i &amp; 1); &#125; return a[x &gt;&gt; 16] + a[x &amp; 65535];&#125;struct Bitset &#123; static const int BIT = 32; static const int SIZE = SN / BIT + 1; unsigned int a[SIZE]; Bitset(); unsigned int &amp; operator [] (const int); const unsigned int &amp; operator [] (const int) const; Bitset operator &amp; (const Bitset &amp;) const; Bitset operator | (const Bitset &amp;) const; Bitset operator ^ (const Bitset &amp;) const; Bitset operator &lt;&lt; (int) const; Bitset operator &gt;&gt; (int) const; Bitset &amp; operator &amp;= (const Bitset &amp;); Bitset &amp; operator |= (const Bitset &amp;); Bitset &amp; operator ^= (const Bitset &amp;); Bitset &amp; operator &lt;&lt;= (int); Bitset &amp; operator &gt;&gt;= (int); Bitset operator ~ () const; // reverse the binary bit in [0, x) // "000110010".Reverse(5) = "000001001" Bitset Reverse(int x) const ; // set the xth binary bit value to f void Set(int x, bool f = true); // set all binary bit value to 0 void Clear(); // return the xth binary bit value bool CheckBit(int x) const ; // return the number of one in binary bit value int AllBit() const; void Flip(int x);&#125;s[N];Bitset::Bitset()&#123; memset(a, 0, sizeof a);&#125;unsigned int &amp; Bitset::operator [] (const int x)&#123; return a[x];&#125;const unsigned int &amp; Bitset::operator [] (const int x) const&#123; return a[x];&#125;Bitset Bitset::operator &amp; (const Bitset &amp;x) const&#123; Bitset ans; for (int i = 0; i &lt; SIZE; i++) ans[i] = x[i] &amp; a[i]; return ans;&#125;Bitset Bitset::operator | (const Bitset &amp;x) const&#123; Bitset ans; for (int i = 0; i&lt; SIZE; i++) ans[i] = x[i] | a[i]; return ans;&#125;Bitset Bitset::operator ^ (const Bitset &amp;x) const&#123; Bitset ans; for (int i = 0; i &lt; SIZE; i++) ans[i] = x[i] ^ a[i]; return ans;&#125;Bitset Bitset::operator &lt;&lt; (int x) const&#123; Bitset ans; int y = x &gt;&gt; 5, z = x &amp; 31; if (z) for (int i = SIZE - 1; i &gt;= y + 1; i--) ans[i] = (a[i - y] &lt;&lt; z) | (a[i - y - 1] &gt;&gt; (BIT - z)); else for (int i = SIZE - 1; i &gt;= y + 1; i--) ans[i] = a[i - y]; ans[y] = a[0] &lt;&lt; z; return ans;&#125;Bitset Bitset::operator &gt;&gt; (int x) const&#123; Bitset ans; int y = x &gt;&gt; 5, z = x &amp; 31; if(z) for (int i = 0; i &lt; SIZE - y - 1; i++) ans[i] = (a[i + y] &gt;&gt; z) | (a[i + y + 1] &lt;&lt; (BIT - z)); else for (int i = 0; i &lt; SIZE - y - 1; i++) ans[i] = a[i + y]; ans[SIZE - y - 1] = a[SIZE - 1] &gt;&gt; z; return ans;&#125;Bitset &amp; Bitset::operator &amp;= (const Bitset &amp;x)&#123; for (int i = 0; i &lt; SIZE; i++) a[i] &amp;= x[i]; return *this;&#125;Bitset &amp; Bitset::operator |= (const Bitset &amp;x)&#123; for (int i = 0; i &lt; SIZE; i++) a[i] |= x[i]; return *this;&#125;Bitset &amp; Bitset::operator ^= (const Bitset &amp;x)&#123; for (int i = 0; i &lt; SIZE; i++) a[i] ^= x[i]; return *this;&#125;Bitset &amp; Bitset::operator &lt;&lt;= (int x)&#123; int y = x &gt;&gt; 5, z = x &amp; 31; if(z) for (int i = SIZE - 1; i &gt;= y + 1; i--) a[i] = (a[i - y] &lt;&lt; z) | (a[i - y - 1] &gt;&gt; (BIT - z)); else for (int i = SIZE - 1; i &gt;= y + 1; i--) a[i] = a[i - y]; a[y] = a[0] &lt;&lt; z; for (int i = 0; i &lt; y; i++) a[i] = 0; return *this;&#125;Bitset &amp; Bitset::operator &gt;&gt;= (int x)&#123; int y = x &gt;&gt; 5, z = x &amp; 31; if(z) for (int i = 0; i &lt; SIZE - y - 1; i++) a[i] = (a[i + y] &gt;&gt; z) | (a[i + y + 1] &lt;&lt; (BIT - z)); else for (int i = 0; i &lt; SIZE - y - 1; i++) a[i] = a[i + y]; a[SIZE - y - 1] = a[SIZE - 1] &gt;&gt; z; for (int i = SIZE - y; i &lt; SIZE; i++) a[i] = 0; return *this;&#125;Bitset Bitset::operator ~ () const&#123; Bitset ans; for (int i = 0; i &lt; SIZE; i++) ans[i] = ~a[i]; return ans;&#125;Bitset Bitset::Reverse(int x) const&#123; Bitset ans; int y = x &gt;&gt; 5, z = x &amp; 31; for (int i = 0; i &lt;= y; i++) ans[i] = BitReverse(a[y - i]); return ans &gt;&gt; (BIT - z);&#125;void Bitset::Set(int x, bool f)&#123; int y = x &gt;&gt; 5, z = x &amp; 31; a[y] |= 1 &lt;&lt; z; if (!f) a[y] ^= 1 &lt;&lt; z;&#125;void Bitset::Clear()&#123; memset(a, 0, sizeof a);&#125;int Bitset::AllBit() const&#123; int ans = 0; for (int i= 0; i &lt; SIZE; i++) ans += BitNum(a[i]); return ans;&#125;bool Bitset::CheckBit(int x) const&#123; int y = x &gt;&gt; 5, z = x &amp; 31; return a[y] &gt;&gt; z &amp; 1;&#125;void Bitset::Flip(int x)&#123; int y = x &gt;&gt; 5, z = x &amp; 31; a[y] ^= 1 &lt;&lt; z;&#125;//bitsetint main()&#123; int n; while (scanf("%d", &amp;n) != EOF) &#123; for (int i = 1; i &lt;= n; i++) s[i].Clear(); for (int i = 1; i &lt;= n; i++) &#123; int k; scanf("%d", &amp;k); while (k--) &#123; int a; scanf("%d", &amp;a); s[a].Set(i); &#125; &#125; int m; scanf("%d", &amp;m); while (m--) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); if ((s[a] &amp; s[b]).AllBit()) puts("Yes"); else puts("No"); &#125; &#125; return 0;&#125; 这份代码测下来结果是没啥问题，但是速度上和stl原生的bitset相比并没有快很多，大约只有100ms的差距，可能还需要改进。 其他优化 其实我们还可以用longlong来压缩，比原来压32位多压一倍。]]></content>
      <categories>
        <category>acm</category>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kolakoski]]></title>
    <url>%2F2019%2F07%2F05%2FKolakoski%2F</url>
    <content type="text"><![CDATA[题目链接题意给出一个规则构造数列。 思路按题意暴力模拟即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int maxn=1e7+10;int arr[maxn];queue&lt;int&gt; q;void init()&#123; int cnt=0; arr[++cnt]=1; q.push(2); int cur=1; int flag=1; while(!q.empty() &amp;&amp; cnt&lt;maxn-2)&#123; int tmp=q.front(); q.pop(); cnt++; arr[cnt]=((arr[cnt-1]-1)^1)+1; q.push(arr[cnt]); if(flag)&#123; q.pop(); flag--; &#125; if(tmp==2)&#123; cnt++; arr[cnt]=arr[cnt-1]; q.push(arr[cnt]); &#125; &#125;&#125;int main()&#123; init(); int t; scanf("%d",&amp;t); while(t--)&#123; int n; scanf("%d",&amp;n); printf("%d\n",arr[n]); &#125;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Just do it]]></title>
    <url>%2F2019%2F07%2F05%2FJust-do-it%2F</url>
    <content type="text"><![CDATA[题目链接题意对一个求m次前缀异或和，求这个数列。 思路我们找一下规律，发现将这个东西列出来之后，对角线上的数字都是组合数。不同数字产生贡献的位置是这些组合数为奇数的位置。那么我们可以去计算这些组合数是奇数还是偶数，如果为奇数，那么所有数字都会对对应偏移位置产生贡献。怎么计算一个很大的组合数是奇是偶呢？介绍两种方法。可以把它拆成阶乘的形式，分别计算分子分母有多少个2因子，相减一下。也可以考虑模2情况下的卢卡斯定理，变成分解其二进制。两种方法复杂度均为O(log_{2}(n)). Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;const ll mod = 1e9 + 7;ll calc(ll n)&#123; ll sum = 0; while (n &gt; 1) &#123; sum += n / 2; n /= 2; &#125; return sum;&#125;const int N = 2e5 + 5;int a[N];int ans[N];int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n; ll m; read(n); read(m); for(int i=1;i&lt;=n;i++) ans[i]=0; for (int i = 1; i &lt;= n; i++) read(a[i]); for(int i=1;i&lt;=n;i++)&#123; ans[i]^=a[i]; &#125; for(int i=2;i&lt;=n;i++)&#123; ll tmp1=i+m-2; ll tmp2=i-1; ll tmp3=m-1; tmp1=calc(tmp1); tmp2=calc(tmp2); tmp3=calc(tmp3); if(tmp1==tmp2+tmp3)&#123; for(int j=0;j+i&lt;=n;j++)&#123; ans[j+i]^=a[j+1]; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) printf("%d%c",ans[i],i==n?'\n':' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inverse of sum]]></title>
    <url>%2F2019%2F07%2F05%2FInverse-of-sum%2F</url>
    <content type="text"><![CDATA[题目链接题意给一个数列$a$,问有多少对$i,j$满足 \frac{1}{a_{i} + a_{j} } \equiv \frac{1}{a_{i} } + \frac{1}{a_{j} } mod p思路\frac{1}{a_{i} + a_{j} } \equiv \frac{1}{a_{i} } + \frac{1}{a_{j} } mod p\frac{1}{a_{i} + a_{j} } \equiv \frac{a_{i} + a_{j} }{a_{i} a_{j}} mod p{(a_{i} + a_{j})}^{2} \equiv a_{i} a_{j} mod p{a_{i} }^{2} + {a_{j} }^{2} + a_{i} a_{j} \equiv 0 mod p(a_{i} - a_{j})({a_{i} }^{2} + {a_{j} }^{2} + a_{i} a_{j}) \equiv 0 mod p{a_{i} }^{3} - {a_{j} }^{3} \equiv 0 mod p这样我们就找到了满足这个条件的$i$与$j$的关系，注意去掉一些a_{i} = a_{j}的情况。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50ll mod;ll mult(ll a, ll b)&#123; ll ans = 0; while (b) &#123; if (b &amp; 1) ans = (ans + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; &#125; return ans;&#125;ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = mult(ans, a); a = mult(a, a); b &gt;&gt;= 1; &#125; return ans;&#125;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;const int maxn=1e5+100;ll a[maxn];map &lt;ll,int&gt; mp1,mp2;int main()&#123; int T; read(T); while (T--) &#123; int n; read(n); read(mod); for(int i=1;i&lt;=n;i++)&#123; read(a[i]); &#125; mp1.clear(); mp2.clear(); ll ans=0; for(int i=1;i&lt;=n;i++)&#123; if(a[i]==0) continue; ll tmp=mult(mult(a[i],a[i]),a[i]); ans+=mp2[tmp]; if(mp1[a[i]]!=0)&#123; ll tmp2=mult(a[i],a[i])*3%mod; if(tmp2!=0)&#123; ans-=mp1[a[i]]; &#125; &#125; mp1[a[i]]++; mp2[tmp]++; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Euler theorem]]></title>
    <url>%2F2019%2F07%2F05%2FEuler-theorem%2F</url>
    <content type="text"><![CDATA[题目链接题意计算$a%b$的不同可能结果，已知$a$。 思路数字$a$的余数一定比$b$小，所以可能结果只有$a$大小一半的规模，且必有两个可能结果$0$和$a$，在$1$到$a-1$这$n-1$个数字中，只有$1$到\frac{n-1}{2}可以作为余数。 Code1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n; scanf("%d",&amp;n); printf("%d\n",(n-1)/2+2); &#125;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Build a tree]]></title>
    <url>%2F2019%2F07%2F05%2FBuild-a-tree%2F</url>
    <content type="text"><![CDATA[题目链接题意给一个$k$叉树，已知总结点数，计算所有结点$size$大小的异或和。 思路我们可以把一层中相同大小的结点一起计算。若是一棵满$k$叉树，我们可以得到它的层数其实是很少的。最后一层的每个结点只有三种情况：要么是满$k$的，要么是空的，要么是不满的。我们可以把层数向下扩展，模拟出后面的大小，然后每一层计算相同的个数，异或到答案里面去。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; ll n,k; scanf("%lld%lld",&amp;n,&amp;k); if(k==1)&#123; ll tmp=n+1; ll ans=0; ll pos=0; while(pos&lt;63 &amp;&amp; (1LL&lt;&lt;pos)&lt;=tmp)&#123; ll cnt=tmp/(1LL&lt;&lt;(pos+1))*(1LL&lt;&lt;pos); ll num=tmp%(1LL&lt;&lt;(pos+1)); if(num&lt;=(1LL&lt;&lt;pos)) num=0; else num=num-(1LL&lt;&lt;pos); cnt+=num; if(cnt &amp; 1) ans^=(1LL&lt;&lt;pos); pos++; &#125; printf("%lld\n",ans); continue; &#125; ll res=n,tmp=1; ll num=0; while(res&gt;=tmp)&#123; res-=tmp; num++; if(tmp&gt;res/k)&#123; break; &#125; tmp*=k; &#125; ll tmp1=0,tmp2=0,tmp3=0; if(res&gt;0)&#123; tmp1=res/k; tmp2=res%k; tmp3=tmp-tmp1-1; &#125; else&#123; ll tmpx=tmp; ll ans=0; ll tmpk=1; for(int i=1;i&lt;=num;i++)&#123; if(tmpx&amp;1) ans^=tmpk; tmpk=tmpk*k+1; tmpx/=k; &#125; printf("%lld\n",ans); continue; &#125; ll ans=0; if(res&amp;1) ans^=1; ll tmpt1=k+1,tmpt2=tmp2+1,tmpt3=1; for(int i=1;i&lt;=num;i++)&#123; if(tmp1&amp;1) ans^=tmpt1; if(tmp3&amp;1) ans^=tmpt3; ans^=tmpt2; tmpt2+=tmpt1*(tmp1%k)+tmpt3*(tmp3%k)+1; tmpt1=tmpt1*k+1; tmpt3=tmpt3*k+1; tmp1/=k; tmp3/=k; &#125; printf("%lld\n",ans); &#125; return 0;&#125; 对于$k=1$情况的特判貌似还是个结论。12345678if(k==1)&#123; ll x=n%4; if(x==0) printf("%lld\n",n); else if(x==1) printf("1\n"); else if(x==2) printf("%lld\n",n+1); else printf("0\n"); continue; &#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mindis]]></title>
    <url>%2F2019%2F06%2F30%2FMindis%2F</url>
    <content type="text"><![CDATA[题目链接题意已知一个圆和不在圆外的两个点P，Q，P和Q在同心圆上。要求在圆上找一点使它到P和Q距离和最小。 思路圆的反演裸题，也可以二分椭圆大小。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50struct po&#123; double x, y; po(double _x = 0, double _y = 0): x(_x), y(_y) &#123;&#125;&#125;;double dis(po a, po b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; double R; scanf("%lf", &amp;R); po P, Q; scanf("%lf%lf", &amp;P.x, &amp;P.y); scanf("%lf%lf", &amp;Q.x, &amp;Q.y); po zero = po(0, 0); double r = dis(zero, P); if (P.x == Q.x &amp;&amp; P.y == Q.y) &#123; printf("%.8f\n", (2 * (R - r))); continue; &#125; double k = R * R / r / r; po PP = po(P.x * k, P.y * k); po QQ = po(Q.x * k, Q.y * k); po mid = po((PP.x + QQ.x) / 2.0, (PP.y + QQ.y) / 2.0); if (dis(mid, zero) &gt;= R) &#123; po m = po((P.x + Q.x) / 2, (P.y + Q.y) / 2); double dm = dis(zero, m); po d = po(m.x * R / dm, m.y * R / dm); printf("%.10f\n", (dis(d, P) + dis(d, Q))); &#125; else &#123; double ans = dis(PP, QQ) * r / R; printf("%.10f\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>圆的反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kirinriki]]></title>
    <url>%2F2019%2F06%2F30%2FKirinriki%2F</url>
    <content type="text"><![CDATA[题目链接题意定义两个字符串dis_{A,B}= \sum_{i=0}^{n - 1}|A_{i}−B_{n-1-i}|.现在给出$S$，问从其中挑出两个不重叠的子串，$dis$小于$m$，最长长度是多少。 思路枚举对称轴，然后划框。主要是个思维题，想到了就没什么可说的。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 5e3 + 5;char s[N];int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; int m; scanf("%d", &amp;m); int ans = 0; scanf("%s", s); int len = strlen(s); for (int i = 0; i &lt; len; i++) &#123; int sum = 0; int head = i, tail = i - 1; while (tail &lt;= len - 2 &amp;&amp; 2 * i - tail - 1 &gt; 0) &#123; tail++; sum += abs(s[tail] - s[2 * i - tail - 1]); while (head &lt;= tail &amp;&amp; sum &gt; m) &#123; sum -= abs(s[head] - s[2 * i - head - 1]); head++; &#125; ans = max(ans, tail - head + 1); &#125; &#125; for (int i = 1; i &lt; len - 1; i++) &#123; int sum = 0; int head = i + 1, tail = i; while (tail &lt;= len - 2 &amp;&amp; 2 * i - tail &gt; 0) &#123; tail++; sum += abs(s[tail] - s[2 * i - tail]); while (head &lt;= tail &amp;&amp; sum &gt; m) &#123; sum -= abs(s[head] - s[2 * i - head]); head++; &#125; ans = max(ans, tail - head + 1); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String]]></title>
    <url>%2F2019%2F06%2F30%2FString%2F</url>
    <content type="text"><![CDATA[题目链接题意给你若干个字符串，每次询问一个$S$,$T$分别作为前缀和后缀不重叠的字符串的数量有多少。 思路直接找不好找，我们可以这样建AC自动机：每个原串str变成$str+$’#’$+str$，每个前缀S后缀T变成T +‘#’+ S插入AC自动机，这样我们查询就可以满足前缀和后缀。还有一个条件，要求不能重叠，那我们再加上一个长度限制就好了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 5e5 + 5;const int maxn = N * 30;int root, sz, ch[maxn][27], fail[maxn], ac_len[maxn], ed[maxn];const int Q = 1e5 + 5;int pos[Q];int react(char c)&#123; if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') return c - 'a'; return 26;&#125;void init()&#123; root = sz = 0; for (int c = 0;c &lt;= 26; c++) ch[root][c] = 0; ac_len[root] = 0; ed[root] = 0;&#125;int newnode()&#123; sz++; for (int c = 0; c &lt;= 26; c++) ch[sz][c] = 0; ed[sz] = 0; return sz;&#125;void insert(char buf[], int id)&#123; int len = strlen(buf); int now = root; for (int i = 0; i &lt; len; i++) &#123; int c = react(buf[i]); if (ch[now][c] == 0) &#123; ch[now][c] = newnode(); ac_len[ch[now][c]] = i + 1; &#125; now = ch[now][c]; &#125; pos[id] = now;// dbg(id, pos[id]);&#125;void get_fail()&#123; queue&lt;int&gt; q; for (int c = 0; c &lt;= 26; c++) &#123; if (ch[root][c] == 0) ch[root][c] = root; else &#123; int u = ch[root][c]; fail[u] = root; q.push(u); &#125; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop();// dbg(u); for (int c = 0; c &lt;= 26; c++) &#123; if (ch[u][c] == 0) &#123; ch[u][c] = ch[fail[u]][c]; continue; &#125; int v = ch[u][c]; fail[v] = ch[fail[u]][c]; q.push(v); &#125; &#125; //puts("over2");&#125;void query(char buf[], int Len)&#123; int len = strlen(buf); int now = root;// puts(buf);// dbg(Len); for (int i = 0; i &lt; len; i++) &#123; int c = react(buf[i]); while (now != root &amp;&amp; !ch[now][c]) now = fail[now]; now = ch[now][c]; int tmp = now; while (tmp != root) &#123;// printf("-----------------%d, ac_len %d\n", tmp, ac_len[tmp]); if (Len &gt;= ac_len[tmp]) ed[tmp]++; tmp = fail[tmp]; &#125; &#125;&#125;char s[N];char tmp[N * 2];int len[Q];char pre[N];int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n, q; scanf("%d%d", &amp;n, &amp;q); int cpos = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", s + cpos); len[i] = strlen(s + cpos); cpos += len[i]; &#125; init(); for (int k = 1; k &lt;= q; k++) &#123; scanf("%s", pre); scanf("%s", tmp); int cur = strlen(tmp); tmp[cur++] = '#'; int j = 0; while (pre[j]) &#123; tmp[cur++] = pre[j++]; &#125; tmp[cur] = 0;// puts(tmp); insert(tmp, k); &#125; // puts("build over"); get_fail(); cpos = 0; // puts("over"); for (int i = 1; i &lt;= n; i++) &#123; int j; for (j = 0; j &lt; len[i]; j++) tmp[j] = tmp[j + len[i] + 1] = s[cpos++]; tmp[j] = '#'; tmp[j + len[i] + 1] = 0;// puts(tmp); query(tmp, len[i] + 1); &#125; for (int i = 1; i &lt;= q; i++) &#123; printf("%d\n", ed[pos[i]]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inversion]]></title>
    <url>%2F2019%2F06%2F30%2FInversion%2F</url>
    <content type="text"><![CDATA[题目链接题意计算B_{i} = max_{i∤j}(A_{j}). Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;int lcy[N][20];int a[N];void rmq_pre(int n)&#123; for (int i = 1; i &lt;= n; i++) lcy[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) &lt;= n + 1; i++) &#123; lcy[i][j] = max(lcy[i][j - 1], lcy[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125;&#125;int rmq(int l, int r)&#123; int k = 31 - __builtin_clz(r - l + 1);// dbg(l, k, r - (1 &lt;&lt; k) + 1, 1 &lt;&lt; k); return max(lcy[l][k], lcy[r - (1 &lt;&lt; k) + 1][k]);&#125;int main()&#123; int n, T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); rmq_pre(n); for (int i = 2; i &lt;= n; i++) &#123; int tmp = 0; for (int l = 0, r = i; l &lt; n; l = r, r += i) &#123; //dbg(l, r); tmp = max(tmp, rmq(l + 1, min(r - 1, n))); &#125; printf("%d%c", tmp, i == n? '\n' : ' '); &#125; // dbg(rmq(4, 5), lcy[4][1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>签到题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rikka with String]]></title>
    <url>%2F2019%2F06%2F28%2FRikka-with-String%2F</url>
    <content type="text"><![CDATA[题目链接题意 定义antisymmetric串为任意1 \leq i \leq |s|，都有s[i] != s[|s|-i+1]. 现在问有多少长度为$2L$的antisymmetric串，包含给出的$n$个串。 思路 如果没有antisymmetric的限制，那么就是一道很裸的AC自动机上的dp。现在我们考虑加了这一个条件，我们会增加怎样的限制呢。 仔细想一想，我们这个字符串，是可以通过确定一半来得到另一半的。 对于字符串只在其中一边出现的情况，我们可以建出所有串的正串和反串，然后放在AC自动机上跑就可以啦。 那么还有另一种情况，就是这个字符串是跨过中轴的，对于我们的做法，跨过中轴的也是可以处理的，只要我们确定字符伸展到这个位置时确实包含了当前要找的字符串，首先我们枚举他跨过中轴的位置，然后看两侧是否满足反对称，如果是反对称，那么在AC自动机上建出长的那一部分，去跑dp就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50#define siz 2const int N = 5e4 + 5;const ll mod = 998244353;int ch[N][siz];int fail[N];int ed[N], ed2[N];int sz;int root;int pos[N];char nit = '0';void init()&#123; root = 0; for (int i = 0; i &lt; siz; i++) ch[root][i] = -1; fail[root] = -1; ed[root] = 0; ed2[root] = 0; sz = 0;&#125;int newnode()&#123; sz++; for (int i = 0; i &lt; siz; i++) &#123; ch[sz][i] = -1; &#125; fail[sz] = -1; ed[sz] = 0; ed2[sz] = 0;// dbg(sz); return sz;&#125;void insert(char buf[], int &amp;id, bool cross)&#123; int len = strlen(buf); int now = root;// dbg(len); for (int i = 0; i &lt; len; i++) &#123; if (ch[now][buf[i] - nit] == -1) &#123; ch[now][buf[i] - nit] = newnode(); &#125; now = ch[now][buf[i] - nit];// dbg(i); &#125; if (!cross) &#123; if (ed[now] == 0) ed[now] |= (1 &lt;&lt; id), pos[now] = id; else &#123; id = pos[now]; &#125; &#125; else ed2[now] |= (1 &lt;&lt; id);&#125;void getfail()&#123; fail[root] =root; queue&lt;int&gt; Q; for (int i = 0; i &lt; siz; i++) &#123; int u = ch[root][i]; if (u != -1) &#123; fail[u] = root; Q.push(u); &#125; else ch[root][i] = root; &#125; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); ed[u] |= ed[fail[u]]; ed2[u] |= ed2[fail[u]]; for (int i = 0; i &lt; siz; i++) &#123; int v = ch[u][i]; if (v == -1) &#123; ch[u][i] = ch[fail[u]][i]; continue; &#125; int tmp = fail[u]; fail[v] = ch[tmp][i]; Q.push(v); &#125; &#125;&#125;/*int query(char buf[])&#123; int len = strlen(buf); int cnt = 0; int now = root; resetv(); for (int i = 0; i &lt; len; i++) &#123; while (now != root &amp;&amp; !ch[now][buf[i] - nit]) now = fail[now]; now = ch[now][buf[i] - nit]; int tmp = now; while (tmp != root) &#123; if (ed[tmp] &amp;&amp; !vis[tmp]) &#123; cnt += ed[tmp]; vis[tmp] = true; &#125; tmp = fail[tmp]; &#125; &#125; return cnt;&#125;*/char s[100];char t[100];const int S = (1 &lt;&lt; 6) + 5;ll dp[2][S][N];int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; memset(dp, 0, sizeof(dp)); int n, L; scanf("%d%d", &amp;n, &amp;L); init(); int mxl = 0; int id = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%s", s); int len = strlen(s); mxl = max(mxl, len); int now = id; insert(s, now, 0); for (int i = 0; i &lt; len; i++) t[i] = (s[len - i - 1] == '0')? '1' : '0' ; t[len] = 0;// puts(s);// puts(t); insert(t, now, 0); for (int k = 1; k &lt; len; k++) &#123; bool f = 1, rm = 0; for (int j = 1; j &lt; len - k + 1; j++) &#123; if (k - j &lt; 0) &#123; rm = 1; break; &#125; if (s[k - j] == s[k + j - 1]) &#123; f = 0; break; &#125; &#125; if (!f) continue; int clen = 0; if (rm) &#123; for (int j = len - 1; j &gt;= k; j--) t[clen++] = (s[j] == '0')? '1' : '0'; &#125; else &#123; for (int j = 0; j &lt; k; j++) t[clen++] = s[j]; &#125; t[clen] = 0;// puts(t); insert(t, now, 1); &#125; if (now == id) id++; &#125; getfail(); dp[0][0][0] = 1; int cur = 0;// dbg(ch[5][1]); for (int i = 1; i &lt;= L; i++) &#123; cur ^= 1; memset(dp[cur], 0, sizeof(dp[cur])); for (int u = 0; u &lt;= sz; u++) for (int k = 0; k &lt; (1 &lt;&lt; id); k++) &#123; if (dp[cur ^ 1][k][u] == 0) continue; for (int c = 0; c &lt;= 1; c++) &#123;// dbg(i, u, k, c); int v = ch[u][c]; int nxt_s = k | ed[v]; if (i == L) nxt_s = nxt_s | ed2[v];// dbg(nxt_s); dp[cur][nxt_s][v] += dp[cur ^ 1][k][u]; dp[cur][nxt_s][v] %= mod; &#125; &#125; &#125; ll ans = 0;// puts("over1"); for (int i = 0; i &lt;= sz; i++) ans = (ans + dp[cur][(1 &lt;&lt; id) - 1][i]) % mod; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rikka with Candies]]></title>
    <url>%2F2019%2F06%2F28%2FRikka-with-Candies%2F</url>
    <content type="text"><![CDATA[题目链接题意 有$n$个人，每个人有A_{i}钱，有m种糖，每个糖B_{i}元，每个人会尽量多的买他喜欢的糖，现在问有多少$(i,j)$满足第$i$个人买第$j$种糖，最后剩$k$元。 思路 若有A_{i} % B_{j} = k，则(A_{i} - k) mod B_{j} = 0.，我们不妨设x=A_{i}-k，则x mod B_{j} = 0，我们找到$x$的因子作为B_{j}，且必须有B_{j} > k，此时x=A_{i}-k，对于这样一对A_{i},B_{j}就会对答案产生贡献。 我们可以把k从大到小枚举，记录所有比当前k大的数字的倍数作为$x$，那么所有存在的A_{i}会和对应的差$k$的B_{j}产生贡献。 用bitset优化上面的算法。（学习一下手写bitset） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 5e4 + 5;bitset&lt;N&gt; ans, A, B;int ret[N];int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n, m, q; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); int maxa = 0, maxb = 0; A.reset(); B.reset(); ans.reset(); memset(ret, 0, sizeof(ret)); for (int i = 1; i &lt;= n; i++) &#123; int a; scanf("%d", &amp;a); maxa = max(maxa, a); A.set(a); &#125; for (int i = 1; i &lt;= m; i++) &#123; int b; scanf("%d", &amp;b); maxb = max(maxb, b); B.set(b); &#125; for (int k = maxb; k &gt;= 0; k--) &#123; ret[k] = ((A &gt;&gt; k) &amp; ans).count() &amp; 1; if (B[k]) for (int j = 0; j &lt;= maxa; j += k) ans[j].flip(); &#125; while (q--) &#123; int k; scanf("%d", &amp;k); printf("%d\n", ret[k]); &#125; &#125; return 0;&#125; 手写bitset。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 5e4 + 5, SN = 5e4 + 5;#define bitset Bitset#define FOR(i, l, r) for(int i = (l), i##_end = (r); i &lt;= i##_end; ++i)#define REP(i, l, r) for(int i = (l), i##_end = (r); i &lt; i##_end; ++i)#define DFR(i, l, r) for(int i = (l), i##_end = (r); i &gt;= i##_end; --i)#define DRP(i, l, r) for(int i = (l), i##_end = (r); i &gt; i##_end; --i)unsigned int BitReverse(unsigned int x) &#123; static unsigned int a[1 &lt;&lt; 16 | 1], now = 1; if(now) &#123; a[0] = now = 0; REP(i, 1, 1 &lt;&lt; 16) a[i] = (a[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; 15); &#125; return a[x &gt;&gt; 16] | (a[x &amp; 65535] &lt;&lt; 16);&#125;int BitNum(unsigned int x) &#123; static unsigned int a[1 &lt;&lt; 16 | 1], now = 1; if(now) &#123; a[0] = now = 0; REP(i, 1, 1 &lt;&lt; 16) a[i] = a[i &gt;&gt; 1] + (i &amp; 1); &#125; return a[x &gt;&gt; 16] + a[x &amp; 65535];&#125;struct bitset &#123; static const int BIT = 32; static const int SIZE = SN / BIT + 1; unsigned int a[SIZE]; bitset(); unsigned int &amp; operator [] (const int); const unsigned int &amp; operator [] (const int) const; bitset operator &amp; (const bitset &amp;) const; bitset operator | (const bitset &amp;) const; bitset operator ^ (const bitset &amp;) const; bitset operator &lt;&lt; (int) const; bitset operator &gt;&gt; (int) const; bitset &amp; operator &amp;= (const bitset &amp;); bitset &amp; operator |= (const bitset &amp;); bitset &amp; operator ^= (const bitset &amp;); bitset &amp; operator &lt;&lt;= (int); bitset &amp; operator &gt;&gt;= (int); bitset operator ~ () const; // reverse the binary bit in [0, x) // "000110010".Reverse(5) = "000001001" bitset Reverse(int x) const ; // set the xth binary bit value to f void Set(int x, bool f = true); // set all binary bit value to 0 void Clear(); // return the xth binary bit value bool CheckBit(int x) const ; // return the number of one in binary bit value int AllBit() const; void Flip(int x);&#125;;bitset::bitset() &#123;memset(a, 0, sizeof a);&#125;unsigned int &amp; bitset::operator [] (const int x) &#123; return a[x];&#125;const unsigned int &amp; bitset::operator [] (const int x) const &#123; return a[x];&#125;bitset bitset::operator &amp; (const bitset &amp;x) const &#123; bitset ans; REP(i, 0, SIZE) ans[i] = x[i] &amp; a[i]; return ans;&#125;bitset bitset::operator | (const bitset &amp;x) const &#123; bitset ans; REP(i, 0, SIZE) ans[i] = x[i] | a[i]; return ans;&#125;bitset bitset::operator ^ (const bitset &amp;x) const &#123; bitset ans; REP(i, 0, SIZE) ans[i] = x[i] ^ a[i]; return ans;&#125;bitset bitset::operator &lt;&lt; (int x) const &#123; bitset ans; int y = x &gt;&gt; 5, z = x &amp; 31; if(z) DFR(i, SIZE - 1, y + 1) ans[i] = (a[i - y] &lt;&lt; z) | (a[i - y - 1] &gt;&gt; (BIT - z)); else DFR(i, SIZE - 1, y + 1) ans[i] = a[i - y]; ans[y] = a[0] &lt;&lt; z; return ans;&#125;bitset bitset::operator &gt;&gt; (int x) const &#123; bitset ans; int y = x &gt;&gt; 5, z = x &amp; 31; if(z) REP(i, 0, SIZE - y - 1) ans[i] = (a[i + y] &gt;&gt; z) | (a[i + y + 1] &lt;&lt; (BIT - z)); else REP(i, 0, SIZE - y - 1) ans[i] = a[i + y]; ans[SIZE - y - 1] = a[SIZE - 1] &gt;&gt; z; return ans;&#125;bitset &amp; bitset::operator &amp;= (const bitset &amp;x) &#123; REP(i, 0, SIZE) a[i] &amp;= x[i]; return *this;&#125;bitset &amp; bitset::operator |= (const bitset &amp;x) &#123; REP(i, 0, SIZE) a[i] |= x[i]; return *this;&#125;bitset &amp; bitset::operator ^= (const bitset &amp;x) &#123; REP(i, 0, SIZE) a[i] ^= x[i]; return *this;&#125;bitset &amp; bitset::operator &lt;&lt;= (int x) &#123; int y = x &gt;&gt; 5, z = x &amp; 31; if(z) DFR(i, SIZE - 1, y + 1) a[i] = (a[i - y] &lt;&lt; z) | (a[i - y - 1] &gt;&gt; (BIT - z)); else DFR(i, SIZE - 1, y + 1) a[i] = a[i - y]; a[y] = a[0] &lt;&lt; z; REP(i, 0, y) a[i] = 0; return *this;&#125;bitset &amp; bitset::operator &gt;&gt;= (int x) &#123; int y = x &gt;&gt; 5, z = x &amp; 31; if(z) REP(i, 0, SIZE - y - 1) a[i] = (a[i + y] &gt;&gt; z) | (a[i + y + 1] &lt;&lt; (BIT - z)); else REP(i, 0, SIZE - y - 1) a[i] = a[i + y]; a[SIZE - y - 1] = a[SIZE - 1] &gt;&gt; z; REP(i, SIZE - y, SIZE) a[i] = 0; return *this;&#125;bitset bitset::operator ~ () const &#123; bitset ans; REP(i, 0, SIZE) ans[i] = ~a[i]; return ans;&#125;bitset bitset::Reverse(int x) const &#123; bitset ans; int y = x &gt;&gt; 5, z = x &amp; 31; FOR(i, 0, y) ans[i] = BitReverse(a[y - i]); return ans &gt;&gt; (BIT - z);&#125;void bitset::Set(int x, bool f) &#123; int y = x &gt;&gt; 5, z = x &amp; 31; a[y] |= 1 &lt;&lt; z; if(!f) a[y] ^= 1 &lt;&lt; z;&#125;void bitset::Clear() &#123; memset(a, 0, sizeof a);&#125;int bitset::AllBit() const &#123; int ans = 0; REP(i, 0, SIZE) ans += BitNum(a[i]); return ans;&#125;bool bitset::CheckBit(int x) const &#123; int y = x &gt;&gt; 5, z = x &amp; 31; return a[y] &gt;&gt; z &amp; 1;&#125;void bitset::Flip(int x)&#123; int y = x &gt;&gt; 5, z = x &amp; 31; a[y] ^= 1 &lt;&lt; z;&#125;//Bitsetbitset A, B, ans;int ret[N];int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n, m, q; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); int maxa = 0, maxb = 0; A.Clear(); B.Clear(); ans.Clear(); memset(ret, 0, sizeof(ret)); for (int i = 1; i &lt;= n; i++) &#123; int a; scanf("%d", &amp;a); maxa = max(maxa, a); A.Set(a); &#125; for (int i = 1; i &lt;= m; i++) &#123; int b; scanf("%d", &amp;b); maxb = max(maxb, b); B.Set(b); &#125; for (int k = maxb; k &gt;= 0; k--) &#123; ret[k] = ((A &gt;&gt; k) &amp; ans).AllBit() &amp; 1; if (B.CheckBit(k)) for (int j = 0; j &lt;= maxa; j += k) ans.Flip(j); &#125; while (q--) &#123; int k; scanf("%d", &amp;k); printf("%d\n", ret[k]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rikka with Subset]]></title>
    <url>%2F2019%2F06%2F28%2FRikka-with-Subset%2F</url>
    <content type="text"><![CDATA[题目链接题意 有A_{1}到A_{n}的$n$个数字，和为m，于是我们得到了{2}^{m}个子集，每个子集都有一个和，我们现在知道了和为i的子集数量为B_{i}，计算A_{1}到A_{n}. 思路 我们可以贪心的选，举个例子，比如我们知道最小的数字一定是第一个不为$0$的A_{i}，而且它的数量是A_{i}个，那么以它们为子集会产生的贡献我们可以用组合数计算出来，每次我们看到一个新的数字，如果它还有需要的贡献我们没有算，那么就会多出这么多个i，我们再对它计算贡献加到后面去。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rikka with Competition]]></title>
    <url>%2F2019%2F06%2F28%2FRikka-with-Competition%2F</url>
    <content type="text"><![CDATA[题目链接思路 只要所有人的差距都在k以内，所有人都会赢，否则，小的那些人一定不会赢，所以数一下差距为k以内的最大的几个人数量就可以了。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>签到题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化treap]]></title>
    <url>%2F2019%2F06%2F27%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96treap%2F</url>
    <content type="text"><![CDATA[场景 我们需要修改，区间翻转，区间求值等（平衡树暗示），还要访问历史版本。 前面我们用以前的平衡树就够了，但是要想访问历史版本，就要可持久化了。 考虑各种转断腰的平衡树，我们对它们可持久化操作。 回忆一下我们以前用的可持久化线段树，我们发现它有一个特点方便了我们的可持久化思想，也就是每个点只会去记录它的儿子信息，而不会考虑父亲信息。这样我们就可以在原来基础上进行一些重用和替换。但是我们用旋转的平衡树就很难解决这个问题。 无旋treap treap = tree + heap，顾名思义，它是由一棵平衡树和一个堆构成的，每个点既有val，也有key，这棵树的中序遍历是递增的，而每个结点的key都小于（或都大于）它的儿子结点。 关键函数有两个，一个是split，一个是merge。 split 这个函数的作用主要是把一棵树按照权值或者大小分成左右两棵子树，我们只要按照原来的规则不破坏，形成的两棵子树在很大概率上都是比较平衡的。12345678910111213141516171819void split(int root, int&amp; x, int&amp; y, int val)&#123; if (!root) &#123; x = y = 0; return; &#125; if (treap[root].val &lt;= val) &#123; x = root; split(rs(root), rs(x), y, val); &#125; else &#123; y = root; split(ls(root), x, ls(y), val); &#125; pushup(root);&#125; merge merge的操作是把两棵树合并成一棵树，关键字小的在上，左右顺序在参数顺序中已经知道。12345678910111213141516171819void merge(int &amp;root, int x, int y)&#123; if (!x || !y) &#123; root = x + y; return; &#125; if (treap[x].key &lt; treap[y].key) &#123; root = x; merge(rs(root), rs(x), y); &#125; else &#123; root = y; merge(ls(root), x, ls(y)); &#125; pushup(root);&#125; others 其他的操作都是在这个基础上演变而来的，我不一一详谈，几个例子，比如我们要插入一个数，就要做两件事情。 1.找到这个数字应该在的位置。 2.插进去。 那么我们怎么做呢？我们可以将这棵树分成两棵子树，左树权值都比我们要插进去的数字小，右树都比他大。然后我们为这个新的数字新建一棵树（只有他一个根节点），现在我们只要把三棵树合并一下就好了。1234567891011void insert(int&amp; root, int val)&#123; int x = 0, y = 0, z = ++cur; treap[z].val = val; treap[z].size = 1; ls(z) = rs(z) = 0; treap[z].key = Rand(); split(root, x, y, val); merge(x, x, z); merge(root, x, y);&#125; 我们怎么删除一个数字呢，同样还是找到它的位置，然后分成三棵子树，两边的树合并一下就ok啦。123456789void del(int&amp; root, int val)&#123; int x = 0, y = 0, z = 0; split(root, x, y, val); split(x, x, z, val - 1); merge(z, ls(z), rs(z)); merge(x, x, z); merge(root, x, y);&#125; 可持久化 好了，我们现在已经有了一种能够不旋转就完成区间问题、区间翻转、前驱后继等问题的平衡树，我们的可持久化操作都要在它的基础上发展出来。我找了很久都没有找到一篇单独讲怎样把无旋treap可持久化的专门博客，后来发现之所以这样，是因为它和线段树持久化太像了，几乎一模一样，所以基本都认为你会了怎么不旋转，也就会了怎么持久化。 确实如此，treap持久化也是想线段树的套路一样，把左儿子和右儿子能复制的复制，实在复制不了的新建。 比如我们要split，我们看一下要分裂的区间是否是在当前子树的某一侧，如果是，之前去分裂那个子树，否则，说明是跨过根节点的，我们新建一个点u来代替当前的点（不改变当前点的左右儿子），要得到u的左右儿子我们再去分裂当前点的左右儿子。最后返回u。 这样每次操作会新产生log(n)个节点，很多次操作以后，我们就会产生一些“垃圾点”，因为他们不会再被找到而且还占用了内存，我们需要及时暴力重建整棵树，记录哪些点没有被使用，下次垃圾回收一下。 代码可以参考这样一道模板题。]]></content>
      <categories>
        <category>acm</category>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>可持久化treap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rikka with Sequence]]></title>
    <url>%2F2019%2F06%2F27%2FRikka-with-Sequence%2F</url>
    <content type="text"><![CDATA[题目链接题意支持序列三种操作：1.求(l,r)区间和。2.执行代码”for (int i=l;i&lt;=r;i++) A[i]=A[i-k];”3.将区间(l,r)，序列还原。 思路可持久化treap，在无旋treap的基础上发展而来，这道题算是我的第一次可持久treap吧。要注意的一个是操作二，有可能涉及到一个区间重复很多遍，我们可以用类似快速幂的操作将这个区间复制到一个目的长度。还有要及时回收多余的结点，暴力重建整棵树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 2e5 + 10;#define ls(x) treap[x].child[0]#define rs(x) treap[x].child[1]int rt, root, rtop, utop, sz, ver;int a[N], res[N &lt;&lt; 2], used[N &lt;&lt; 2], pos[N &lt;&lt; 2];int n;struct node&#123; int child[2], val, size; ll sum; void init() &#123; child[0] = child[1] = val = sum = 0; size = 1; &#125;&#125;treap[N &lt;&lt; 2];int newnode(int val = 0)&#123; int x; if (rtop) x = res[rtop--]; else x = ++sz; used[++utop] = x; treap[x].init(); treap[x].val = val; return x;&#125;void push_up(int u)&#123; treap[u].size = treap[ls(u)].size + treap[rs(u)].size + 1; treap[u].sum = treap[ls(u)].sum + treap[rs(u)].sum + treap[u].val;&#125;void dfs(int u)&#123; if (!u) return; pos[u] = ver; dfs(ls(u)); dfs(rs(u));&#125;void rebuild()&#123; ver++; dfs(root); dfs(rt); int top = 0; for (int i = 1; i &lt;= utop; i++) if (pos[used[i]] == ver) used[++top] = used[i]; else res[++rtop] = used[i]; utop = top;&#125;int build(int l, int r)&#123; if (l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; int u = newnode(a[mid]); ls(u) = build(l, mid - 1); rs(u) = build(mid + 1, r); push_up(u); return u;&#125;ll seed = 17121197;ll Rand()&#123; return seed = seed * 48271 % 2147483647;&#125;int merge(int x, int y)&#123; if (!x &amp;&amp; !y) return 0; int u = newnode(); if (!x || !y) &#123; treap[u] = treap[x + y]; return u; &#125; if (Rand() &amp; 1) &#123; treap[u] = treap[x]; rs(u) = merge(rs(x), y); &#125; else &#123; treap[u] = treap[y]; ls(u) = merge(x, ls(y)); &#125; push_up(u); return u;&#125;int Pow(int a, int b)&#123; int ret = 0; while (b) &#123; if (b &amp; 1) ret = merge(ret, a); a = merge(a, a); b &gt;&gt;= 1; &#125; return ret;&#125;int split(int x, int l, int r)&#123; if (l &gt; r) return 0; if (l == 1 &amp;&amp; r == treap[x].size) &#123; int u = newnode(); treap[u] = treap[x]; return u; &#125; if (r &lt;= treap[ls(x)].size) return split(ls(x), l, r); if (l &gt; treap[ls(x)].size + 1) return split(rs(x), l - treap[ls(x)].size - 1, r - treap[ls(x)].size - 1); int u = newnode(treap[x].val); ls(u) = split(ls(x), l, treap[ls(x)].size); rs(u) = split(rs(x), 1, r - treap[ls(x)].size - 1); push_up(u); return u;&#125;void update(int l, int r, int k)&#123; int x = split(rt, 1, l - k - 1), y = split(rt, l - k, l - 1); int z = Pow(y, (r - l + 1) / k); int a = split(rt, l - k, l - k + 1 + (r - l + 1) % k); int b = split(rt, r + 1, n); rt = merge(x, y); rt = merge(rt, z); rt = merge(rt, a); rt = merge(rt, b);&#125;void back(int l, int r)&#123; int x = split(rt, 1, l - 1), y = split(root, l, r), z = split(rt, r + 1, n); rt = merge(x, y); rt = merge(rt, z);&#125;int main()&#123; int q; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); int limit = 450; ls(0) = rs(0) = treap[0].sum = 0; treap[0].size = 0; rt = root = build(1, n); while (q--) &#123; int type; scanf("%d", &amp;type); int l, r; scanf("%d%d", &amp;l, &amp;r); if (q % limit == 0) rebuild(); if (type == 1) printf("%lld\n", treap[split(rt, l, r)].sum); else if (type == 2) &#123; int k; scanf("%d", &amp;k); update(l, r, k); &#125; else back(l, r); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>可持久化treap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rikka with Rock-paper-scissors]]></title>
    <url>%2F2019%2F06%2F27%2FRikka-with-Rock-paper-scissors%2F</url>
    <content type="text"><![CDATA[题目链接题意有两个人进行$n$局石头剪刀布游戏，设其中一个人赢了$a$局，另一个人赢了$b$局，$n-a-b$局平局。则分数为$gcd(a,b)$。问分数的期望。 思路ans={3}^{n} \sum_{a=0}^{n} \sum_{b=0}^{n-a} C_{n}^{a} C_{n-a}^{b} gcd(a, b).={3}^{n} \sum_{d=1}^{n} \sum_{a=0}^{n} \sum_{b=0}^{n-a} C_{n}^{a} C_{n-a}^{b} d[gcd(a,b)==d].={3}^{n} \sum_{d=1}^{n} d f(d).f(d) = \sum_{a=0}^{n} \sum_{b=0}^{n-a} C_{n}^{a} C_{n-a}^{b} [gcd(a,b) == d].F(d) = \sum_{a=0}^{n} \sum_{b=0}^{n-a} C_{n}^{a} C_{n-a}^{b} [d | gcd(a, b)].F(d) = \sum_{d | k} f(k).f(d) = \sum_{d | k} \mu( \frac{k}{d}) F(k).F(d) = \sum_{a=0}^{n} \sum_{b=0}^{n-a} C_{n}^{a} C_{n-a}^{b} [d | gcd(a,b)] [gcd(a, b) != 0].= \sum_{a=0}^{ \frac{n}{d} } \sum_{b=0}^{ \frac{n}{d} - a} C_{n}^{ad} C_{n-ad}^{bd} -1.= \sum_{a=0}^{ \frac{n}{d} } \sum_{b=0}^{ \frac{n}{d} - a} \frac{n!}{(ad)!(bd)!(n-ad-bd)!} -1.= \sum_{a=0}^{ \frac{n}{d} } \sum_{b=0}^{a} \frac{n!}{(ad - bd)!(bd)!(n-ad)!} - 1.= n! \sum_{a=0}^{ \frac{n}{d} } \frac{1}{(n - ad)! } \sum_{b=0}^{a} \frac{1}{(bd)!(ad-bd)!} - 1.= n! \sum_{a=0}^{ \frac{n}{d} } \frac{1}{(n - ad)! } (fac * fac)_{a} - 1.可以用FFT优化这个狄利克雷卷积。 ans = {3}^{n} \sum_{d=1}^{n} d f(d).= {3}^{n} \sum_{d=1}^{n} d \sum_{d | k} \mu( \frac{k}{d} ) F(k).= {3}^{n} \sum_{k=1}^{n} \sum_{d | k} d \mu( \frac{k}{d} ) F(k).= {3}^{n} \sum_{k=1}^{n} F(k) \phi(k).]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>NTT</tag>
        <tag>Inversion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本实现对拍]]></title>
    <url>%2F2019%2F06%2F27%2Fshell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%8B%8D%2F</url>
    <content type="text"><![CDATA[每天我苦于各种找bug，总是不知道自己哪里写错了，总感觉对于所有数据应该都已经完美了。手动对拍所有数据。不停重复着三条命令：./t &gt; 1.in./a &lt; 1.in./b &lt; 1.in…… 今天我才知道，原来shell的命令脚本可以替代我完成这样枯燥的事情。我真的是愚蠢了！ 1234567891011while true; do ./t &gt; 1.in ./a &lt; 1.in &gt; a.out ./b &lt; 1.in &gt; b.out if diff a.out b.out; then printf "AC\n" else printf "WA\n" exit 0 fidone]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Classic Quotation]]></title>
    <url>%2F2019%2F06%2F26%2FClassic-Quotation%2F</url>
    <content type="text"><![CDATA[题目链接题意有串S和T，询问在S中挖去S.substr(i,j),(1 \leq i \leq L, R \leq j \leq n)后，T在其中出现的次数和。 思路题解讲的很清楚。 说的好像很好写的样子，但是除了上帝没人知道我下面的代码在干什么。挖个坑，回头把它改一改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;char s[N], t[105];int Next[105];void kmp_pre()&#123; int tlen = strlen(t); int i, j; j = Next[0] = -1; i = 0; while (i &lt; tlen) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = Next[j]; Next[++i] = ++j; &#125;&#125;ll pref[N], preg[N], suf[N][105], sum[N][105];ll l, r;int k, n, m;ll get()&#123; ll ans = (n - r) * preg[l];// dbg(n, l, r, ans); for (int i = 0; i &lt; m; i++) &#123;// dbg(i, sum[l][i], suf[r][i]); ans += sum[l][i] * suf[r][i]; &#125; return ans;&#125;void solve()&#123; kmp_pre(); int slen = strlen(s), tlen = strlen(t); int i = 0, j = 0; pref[0] = 0; preg[0] = 0; while (i &lt; slen) &#123; while (j != -1 &amp;&amp; s[i] != t[j]) j = Next[j]; j++, i++; preg[i] = preg[i - 1] + (j == tlen); if (j == tlen) j = Next[j]; pref[i] = j;// dbg(i, pref[i], preg[i]); &#125; for (int i = 0; i &lt;= slen; i++) for (int j = 0; j &lt;= tlen; j++) suf[i][j] = 0; for (int i = slen - 2; i &gt;= 0; i--) for (int j = tlen - 1; j &gt;= 0; j--) &#123; int cj = j; while (cj != -1 &amp;&amp; t[cj] != s[i + 1]) cj = Next[cj]; cj++; suf[i][j] = suf[i + 1][cj % tlen] + (cj == tlen);// dbg(i, j, suf[i][j]); &#125; for (int i = 1; i &lt; slen; i++) preg[i] += preg[i - 1]; for (int j = 0; j &lt; tlen; j++) for (int i = tlen - 2; i &gt;= 0; i--) suf[i][j] += suf[i + 1][j]; for (int i = 0; i &lt;= tlen; i++) for (int j = 0; j &lt;= slen; j++) sum[j][i] = 0; for (int i = 0; i &lt; slen; i++) sum[i + 1][pref[i]]++; for (int i = 0; i &lt; slen; i++) for (int j = 0; j &lt; tlen; j++) sum[i][j] += sum[i - 1][j]; while (k--) &#123; scanf("%lld%lld", &amp;l, &amp;r); l--, r--; printf("%lld\n", get()); &#125;&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); scanf("%s", s); scanf("%s", t); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dirt Ratio]]></title>
    <url>%2F2019%2F06%2F26%2FDirt-Ratio%2F</url>
    <content type="text"><![CDATA[题目链接题意给$n$个数，计算$(l,r)$中不同数字数量/$(r-l+1)$.即\frac{size(l, r)}{r - l + 1} 的最小值。 思路二分答案，每次去看$Mid$值是否合法。我们将上面式子变形为 \frac{size(l, r)}{r-l+1} \leq Mid.size(l, r) + l \times Mid \leq Mid \times (r + 1).我们枚举$r$，在线段树上维护到当前$r$每一$l$的size(l,r)+Mid \times l.动态更新r会产生影响的l。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50#define lson rt &lt;&lt; 1#define rson rt &lt;&lt; 1 | 1#define Lson L, mid, lson#define Rson mid + 1, R, rsonconst int N = 6e4 + 5;double lazy[N &lt;&lt; 2];double val[N &lt;&lt; 2];double Mid;void push_up(int rt)&#123; //sum[rt] = sum[lson] + sum[rson]; val[rt] = min(val[lson], val[rson]);&#125;void build(int L, int R, int rt)&#123; //sum[rt] = 0; lazy[rt] = 0; val[rt] = inf; if (L == R) &#123; val[rt] = L * Mid; return; &#125; int mid = (L + R) &gt;&gt; 1; build(Lson); build(Rson); push_up(rt);&#125;void push_down(int len, int rt)&#123; if (lazy[rt]) &#123;// sum[lson] = sum[lson] + (len - (len &gt;&gt; 1)) * lazy[rt];// sum[rson] = sum[rson] + (len &gt;&gt; 1) * lazy[rt]; val[lson] = val[lson] + lazy[rt]; val[rson] = val[rson] + lazy[rt]; lazy[lson] += lazy[rt]; lazy[rson] += lazy[rt]; lazy[rt] = 0; &#125;&#125;void update(int l, int r, int v, int L, int R, int rt)&#123; if (l &lt;= L &amp;&amp; r &gt;= R) &#123; int len = R - L + 1; lazy[rt] += v;// sum[rt] += v * len; val[rt] += v; return; &#125; /* if (L == R) &#123; val[rt] += v; return; &#125; */ int mid = (L + R) &gt;&gt; 1; push_down(R - L + 1, rt); if (l &lt;= mid) update(l, r, v, Lson); if (r &gt; mid) update(l, r, v, Rson); push_up(rt);&#125;double query(int l, int r, int L, int R, int rt)&#123; if (l &lt;= L &amp;&amp; r &gt;= R) return val[rt]; double ans = (1ll &lt;&lt; 50) * 1.0; push_down(R - L + 1, rt); int mid = (L + R) &gt;&gt; 1; if (l &lt;= mid) ans = min(ans, query(l, r, Lson)); if (r &gt; mid) ans = min(ans, query(l, r, Rson)); return ans;&#125;int pre[N];int pos[N];int a[N], n;bool check()&#123; //dbg(Mid); build(1, n, 1); for (int i = 1; i &lt;= n; i++) &#123; // dbg(i); update(pre[i] + 1, i, 1, 1, n, 1); // dbg(query(1, i, 1, n, 1)); if (query(1, i, 1, n, 1) &lt;= Mid * 1.0 * (i + 1)) return true; &#125; return false;&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) pos[i] = 0; for (int i = 1; i &lt;= n; i++) &#123; pre[i] = pos[a[i]]; pos[a[i]] = i; &#125; double l = 0, r = n + 1, eps = 1e-6; while (r - l &gt;= eps) &#123; Mid = (r + l) / 2.0; if (check()) r = Mid; else l = Mid; &#125; printf("%.5f\n", l); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Counting Divisors]]></title>
    <url>%2F2019%2F06%2F26%2FCounting-Divisors%2F</url>
    <content type="text"><![CDATA[题目链接题意$d(i)$表示约数函数。计算\sum_{i=l}^{r} d({i}^{k}) mod 998244353.其中1 \leq l \leq r \leq {10}^{12}, r - l \leq {10}^{6}, 1 \leq k \leq {10}^{7}. 思路因为注意到r - l其实范围不大，我们可以计算这个范围内每一个数字的答案，分开素数和非素数。素数的话答案就是k+1，非素数我们可以按唯一分解定理将其分成n={p_{1}}^{e_{1}}{p_{2}}^{e_{2}}...{p_{w}^{e_{w}}}. {n}^{k} = {p_{1}}^{e_{1}k}{p_{2}}^{e_{2}k}...{p_{w}}^{e_{w}k}.d({n}^{k}) = (e_{1}k + 1)(e_{2}k + 1)...(e_{w}k + 1).具体见代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e6 + 100;ll prime[N];int tot;bool vis[N];void pre()&#123; tot = 0; for (int i = 2; i &lt;= 1000010; i++) &#123; if (!vis[i]) prime[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= 1000010; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;ll cnt[N];ll val[N];const ll mod = 998244353;int main()&#123; int T; scanf("%d", &amp;T); pre(); while (T--) &#123; ll l, r, k; scanf("%lld%lld%lld", &amp;l, &amp;r, &amp;k); for (int i = 0; i &lt;= r - l; i++) &#123; cnt[i] = 1; val[i] = i + l; &#125; for (int i = 1; i &lt;= tot &amp;&amp; prime[i] * prime[i] &lt;= r; i++) &#123; //dbg(i); ll cur = l / prime[i] * prime[i]; while (cur &lt; l) &#123; cur = cur + prime[i]; &#125; for (; cur &lt;= r; cur += prime[i]) &#123; ll c = 0; while (val[cur - l] % prime[i] == 0) &#123; val[cur - l] /= prime[i]; c++; &#125; cnt[cur - l] = (cnt[cur - l] * (c * k % mod + 1)) % mod; //dbg(cur, cnt[cur - l + 1]); &#125; &#125; ll ans = 0; for (int i = 0; i + l &lt;= r; i++) &#123; if (val[i] == 1) ans = (ans + cnt[i]) % mod; else ans = (ans + cnt[i] * (k + 1) % mod) % mod; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>区间筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Time To Get Up]]></title>
    <url>%2F2019%2F06%2F26%2FTime-To-Get-Up%2F</url>
    <content type="text"><![CDATA[题目链接题意用一个7*21的二维矩阵表示一个时间，要求输出时间。 思路可以记录每条边是否出现，对于这样若干条边的集合记录数字是多少。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50char s[10][30];const int up = 1 &lt;&lt; 8;int hack[up];int check(int t)&#123; int ans = 0; if (s[0][t + 1] == 'X') ans |= (1 &lt;&lt; 1); if (s[1][t + 3] == 'X') ans |= (1 &lt;&lt; 0); if (s[1][t] == 'X') ans |= (1 &lt;&lt; 2); if (s[3][t + 1] == 'X') ans |= (1 &lt;&lt; 3); if (s[4][t] == 'X') ans |= (1 &lt;&lt; 6); if (s[6][t + 1] == 'X') ans |= (1 &lt;&lt; 5); if (s[4][t + 3] == 'X') ans |= (1 &lt;&lt; 4); return hack[ans];&#125;int main()&#123; int T; scanf("%d", &amp;T); hack[119] = 0; hack[17] = 1; hack[107] = 2; hack[59] = 3; hack[29] = 4; hack[62] = 5; hack[126] = 6; hack[19] = 7; hack[127] = 8; hack[63] = 9; while (T--) &#123; for (int i = 0; i &lt; 7; i++) scanf("%s", s[i]); printf("%d%d:%d%d\n", check(0), check(5), check(12), check(17)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Questionnaire]]></title>
    <url>%2F2019%2F06%2F26%2FQuestionnaire%2F</url>
    <content type="text"><![CDATA[题目链接题意让你找到合适的m,k，使得n个数字对m取模结果为k的数量为cnt，且cnt不少于n-cnt。 思路我们可以看其中奇数数量和偶数数量，那么就可以让m为2，然后比较一下就可以得到答案了。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;int a[N];int main()&#123; int T; scanf("%d", &amp;T); while (T--)&#123; int n; scanf("%d", &amp;n); int cnt= 0; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); if (x &amp; 1) cnt++; &#125; if (cnt &gt;= n - cnt) printf("2 1\n"); else printf("2 0\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>签到题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lazy Running]]></title>
    <url>%2F2019%2F06%2F26%2FLazy-Running%2F</url>
    <content type="text"><![CDATA[题目链接同余最短路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, ll&gt; P;const ll MAX = 1e18;struct POINT&#123; int dis; int id;&#125; a[10][5];ll d[5][60050];void djs(int st, ll m)&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; q.push(P(2, 0)); while (!q.empty()) &#123; P now = q.top(); q.pop(); ll dis1 = now.second; int u = now.first; if(dis1&gt;d[u][dis1%m]) continue; for (int i = 0; i &lt; 2; i++) &#123; ll dis2 = a[u][i].dis + d[u][dis1 % m]; if (dis2 &lt; d[a[u][i].id][dis2 % m]) &#123; d[a[u][i].id][dis2 % m] = dis2; q.push(P(a[u][i].id, dis2)); &#125; &#125; &#125;&#125;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;int main()&#123; int T; read(T); while (T--) &#123; ll k; ll ans = MAX; int d1, d2, d3, d4; read(k), read(d1), read(d2), read(d3), read(d4); a[1][0].dis = d1, a[1][0].id = 2; a[1][1].dis = d4, a[1][1].id = 4; a[2][0].dis = d2, a[2][0].id = 3; a[2][1].dis = d1, a[2][1].id = 1; a[3][0].dis = d3, a[3][0].id = 4; a[3][1].dis = d2, a[3][1].id = 2; a[4][0].dis = d4, a[4][0].id = 1; a[4][1].dis = d3, a[4][1].id = 3; ll m = min(d1, d2) * 2; for (int i = 0; i &lt; 5; i++) for (int j = 0; j &lt;= m; j++) d[i][j] = MAX; d[2][0] = 0; djs(2, m); for (int i = 0; i &lt; m; i++) &#123; if (d[2][i] &lt; k) &#123; ll yu = k - d[2][i], cx; if (yu % m) cx = (yu / m) + 1; else cx = yu / m; ans = min(ans, d[2][i] + cx * m); &#125; else ans = min(ans, d[2][i]); &#125; printf("%lld\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXD, tree and sequence]]></title>
    <url>%2F2019%2F06%2F23%2FRXD-tree-and-sequence%2F</url>
    <content type="text"><![CDATA[题目链接题意有一棵树，$n$个结点，有$n$一个排列$p$。现在要求将$p$分成$k$段，每段求出$lca$后使得每段$lca$深度和最小。 思路很明显是一道dp。状态也很容易想到用$dp[i][j]$表示前$i$个数字已经划分了$j$段。要知道一个性质是，每次在一段区间末尾加入一个数字后，值是不增的。 第一种dp所以我们不妨假设$p[i]$加入$p[j]$时不会产生影响。直接$dp[i][j]=dp[i - 1][j].$实际上我们知道这是有条件的，也就是要求$p[i]$与$p[i-1]$的$lca$在这段区间里是不起决定性作用的，那我们这样暴力按照相等转移是对的么？不要着急，其实我们本来不应该直接$dp[i][j] = dp[i - 1][j]$，但是由于这个答案是不增的，所以要么这个式子满足，要么会有更优的答案来代替它。现在我们来看一下其他可能更优秀的转移。（我个人觉得上面这个比较难理解）如上所述，第一种情况，$dp[i][j]=dp[i-1][j].$第二种情况，$p[i]$单独成段，$dp[i][j]=dp[i-1][j-1]+dep(p[i]).$第三种情况，如果$p[i]$是起决定性作用的点，那么这段区间的$lca$可由它和区间里任意一个点的$lca$得到。我们不妨就用$p[i-1]$，$dp[i][j]=dp[i-2][j-1]+dep(lca(p[i], p[i-1])).$ 上面三种情况去最小就好了。 不知道为什么，用邻接表一直WA，改前向星就过了，我这可怜的一个小时就这样过去了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 3e5 + 5;struct Edge &#123; int v, nxt;&#125; E[N * 2];int head[N];int cnt = 0;void add(int u, int v) &#123; E[cnt].v = v; E[cnt].nxt = head[u]; head[u] = cnt++;&#125;int tot, ver[2 * N], deep[2 * N], first[N], lcy[2 * N][30], dir[N];void dfs(int u, int f, int dep)&#123; first[u] = ++tot; ver[tot] = u; deep[tot] = dep; dir[u] = dep; for (int it = head[u]; ~it; it = E[it].nxt) &#123; int v = E[it].v; if (v == f) continue; dfs(v, u, dep + 1); ver[++tot] = u; deep[tot] = dep; &#125;&#125;void ST()&#123; for (int i = 1; i &lt;= tot; i++) lcy[i][0] = i; for (int j = 1; (1 &lt;&lt; j) &lt;= tot; j++) &#123; for (int i = 1; i + (1 &lt;&lt; j) &lt; tot; i++) &#123; int a = lcy[i][j - 1], b = lcy[i + (1 &lt;&lt; (j - 1))][j - 1]; lcy[i][j] = deep[a] &lt; deep[b]? a : b;// dbg(i, j, lcy[i][j]); &#125; &#125;&#125;int RMQ(int l, int r)&#123; int k = 31 - __builtin_clz(r - l + 1); int a = lcy[l][k], b = lcy[r - (1 &lt;&lt; k) + 1][k];// dbg(lcy[l][k], lcy[r - (1 &lt;&lt; k) + 1][k]); if (deep[a] &lt; deep[b]) return a; else return b;&#125;int lca(int x, int y)&#123; int a = first[x], b = first[y];// dbg(a, b); if (a &gt; b) swap(a, b); return ver[RMQ(a, b)];&#125;vector&lt;vector&lt;int&gt; &gt;dp;int p[N];int main()&#123; int n, k; while (scanf("%d%d", &amp;n, &amp;k) != EOF) &#123; tot = 0; cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;p[i]); head[i] = -1; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); add(u, v); add(v, u); &#125; dp.resize(n + 1); for (int i = 0; i &lt;= n; i++) &#123; dp[i].resize(k + 1); for (int j = 1; j &lt;= k; j++) dp[i][j] = 0x3f3f3f3f; &#125; dfs(1, 0, 1); ST();// puts("ove1r"); dp[0][0] = 0;// dbg(lca(4, 6));// puts("over2");// /* for (int j = 1; j &lt;= k; j++) &#123; for (int i = j; i &lt;= n; i++) &#123;// dbg(j, i); dp[i][j] = dp[i - 1][j]; dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + dir[p[i]]); if (i - 1 &gt;= j) dp[i][j] = min(dp[i][j], dp[i - 2][j - 1] + dir[lca(p[i], p[i - 1])]);// dbg(i, j, dp[i][j], first[p[i]], lca(p[i], p[i - 1])); &#125; &#125; printf("%d\n", dp[n][k]);// */ &#125; return 0;&#125; 第二种 cdq分治这也是标程的做法，我在赛中也是想过加速$k$层dp的，但是没想出怎么单调来。这个做法其实也是用了前面的性质，即将一段区间$B$加在区间$A$的后面，$B$的$lca$有可能是具有决定性的，也可能不是。只有这两种可能，我们在cdq分治的时候可以将$l$到$mid$区间分成两部分，一部分是和$mid+1$到$i$拼接起来后$lca$与后半段无关的。另外一部分是要将两部分取$lca$的。这两种情况的分界点，经过观察具有单调性。于是我们就可以用cdq分治在$O(nklogn)$的时间内解决了。 参考博客123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 3e5 + 5;struct node&#123; int v, nxt;&#125;edge[N * 2];int tot, head[N];void add_edge(int u, int v)&#123; edge[++tot].v = v; edge[tot].nxt = head[u]; head[u] = tot;&#125;int first[N], dep[2 * N], st[2 * N][30], ord[2 * N];int cur = 0;void dfs(int u, int f, int d)&#123; dep[u] = d; first[u] = ++cur; st[cur][0] = cur; ord[cur] = u; for (int it = head[u]; ~it; it = edge[it].nxt) &#123; int v = edge[it].v; if (v == f) continue;// dbg(u, v); dfs(v, u, d + 1); st[++cur][0] = cur; ord[cur] = u; &#125;&#125;void ST()&#123; for (int j = 1; (1 &lt;&lt; j) &lt;= cur; j++) for (int i = 1; i + (1 &lt;&lt; j) &lt;= cur + 1; i++) &#123; int a = st[i][j - 1], b = st[i + (1 &lt;&lt; (j - 1))][j - 1]; st[i][j] = dep[ord[a]] &lt; dep[ord[b]] ? a : b;// dbg(i, j, dep[ord[st[i][j]]]); &#125;&#125;int RMQ(int l, int r)&#123; int k = 31 - __builtin_clz(r - l + 1); int a = st[l][k], b = st[r - (1 &lt;&lt; k) + 1][k]; if (dep[ord[a]] &lt; dep[ord[b]]) return ord[a]; else return ord[b];&#125;int lca(int u, int v)&#123; int x = first[u], y = first[v]; if (x &gt; y) swap(x, y); return RMQ(x, y);&#125;vector&lt;vector&lt;int&gt; &gt; dp;int p[N];int a[N], b[N], c[N];void cdq(int l, int r, int k)&#123; if (l &gt;= r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid, k); a[mid] = p[mid]; a[mid + 1] = p[mid + 1]; for (int i = mid - 1; i &gt;= l; i--) a[i] = lca(a[i + 1], p[i]); for (int i = mid + 2; i &lt;= r; i++) a[i] = lca(a[i - 1], p[i]); for (int i = mid + 1; i &lt;= r; i++) dp[i][k] = min(dp[mid][k - 1] + dep[a[i]], dp[i][k]); b[l] = 0x3f3f3f3f; for (int i = l + 1; i &lt;= mid; i++) b[i] = min(b[i - 1], dp[i - 1][k - 1] + dep[a[i]]); c[mid + 1] = 0x3f3f3f3f; for (int i = mid; i &gt;= l + 1; i--) c[i] = min(c[i + 1], dp[i - 1][k - 1]); int tmp = lca(a[mid], a[mid + 1]); int pos = mid; while (pos &gt; l &amp;&amp; dep[a[pos]] &gt; dep[tmp]) pos--; for (int i = mid + 1; i &lt;= r; i++) &#123; if (dep[a[i]] &lt; dep[tmp]) tmp = lca(tmp, p[i]); while (pos &gt; l &amp;&amp; dep[a[pos]] &gt; dep[tmp]) pos--; dp[i][k] = min(dp[i][k], c[pos + 1] + dep[tmp]); dp[i][k] = min(dp[i][k], b[pos]); &#125; cdq(mid + 1, r, k);&#125;void init(int n, int k)&#123; for (int i = 1; i &lt;= n; i++) head[i] = -1; tot = cur = 0; dp.resize(n + 1); for (int i = 0; i &lt;= n; i++) dp[i].resize(k + 1);&#125;int main()&#123; int n, k; while (scanf("%d%d", &amp;n, &amp;k) != EOF) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); init(n, k); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); add_edge(u, v); add_edge(v, u); &#125; dfs(1, 0, 1); ST(); dp[0][0] = 0; for (int i = 0; i &lt;= n; i++) for (int j = 1; j &lt;= k; j++) dp[i][j] = 0x3f3f3f3f; int tmp = p[1]; for (int i = 1; i &lt;= n; i++) &#123; tmp = lca(tmp, p[i]); dp[i][1] = dep[tmp]; &#125; for (int kk = 2; kk &lt;= k; kk++) cdq(1, n, kk); printf("%d\n", dp[n][k]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Tree</tag>
        <tag>lca</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXD and functions]]></title>
    <url>%2F2019%2F06%2F23%2FRXD-and-functions%2F</url>
    <content type="text"><![CDATA[题目链接题意已知f(x)= \sum_{i=0}^{n} c_{i} {x}^{i}.定义变换$Tr(f,a)$，使得g(x)=Tr(f,a)=f(x-a).已知g_{0}=f，且有g_{i}=Tr(g_{i-1}, a_{i}),g_{m} = \sum_{i=0}^{n} b_{i} {x}^{i}，输入m。求b_{i}对998244353取模。 思路推式子时间到。 f(x) = \sum_{i=0}^{n} c_{i} {x}^{i}Tr(f, a)=f(x-a)g_{0}=f, g_{i}=Tr(g_{i-1}, a_{i}).g_{1}= \sum_{i=0}^{n} c_{i}{(x-a_{1})}^{i}.g_{2}= \sum_{i=0}^{n} c_{i} {(x - a_{1} - a_{2})}^{i}....g_{m} = \sum_{i=0}^{n} c_{i} {(x-a_{1}-a_{2}-a_{3}...)}^{i}.S = \sum_{i=1}^{m} a_{i}.g_{m} = \sum_{i=0}^{n} c_{i} {(x-S)}^{i}.=b_{i}{x}^{i}.b_{i} = \sum_{j=i}^{n}c_{j} C_{j}^{i} {(-S)}^{j-i}.= \sum_{j=i}^{n} c_{j} \times \frac{j!}{(j-i)!i!} {(-S)}^{j-i}.= \frac{1}{i!} \sum_{j=i}^{n} c_{j} \frac{j!}{(j-i)!} {(-S)}^{j-i}.= \frac{1}{i!} \sum_{j=0}^{n-i} c_{i+j} (i+j)! \frac{ {(-S)}^{j} }{j!}.= \frac{1}{i!} \sum_{j=0}^{n-i} c_{i+j} (i+j)! \frac{ {(-S)}^{n-(n-j)} }{(n-(n-j))!}.= \frac{1}{i!} \times (A*B)_{n+i}.其中A_{i} = c_{i} \times i!,B_{i} = \frac{ {(-S)}^{n-i} }{(n-i)!}. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const ll mod = 998244353;const ll g = 3;ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;void change(ll y[],int len)&#123; for(int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); int k = len / 2; while (j &gt;= k) &#123; j -= k; k /= 2; &#125; if (j &lt; k) j += k; &#125;&#125;void ntt(ll y[], int len, int on)&#123; change(y, len); for(int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; ll wn = Pow(g, (mod-1) / h); if(on == -1) wn = Pow(wn, mod-2); for(int j = 0; j &lt; len; j += h) &#123; ll w = 1LL; for (int k = j; k &lt; j + h / 2; k++) &#123; ll u = y[k]; ll t = w * y[k + h / 2] % mod; y[k] = (u + t) % mod; y[k + h / 2] = (u - t + mod) % mod; w = w * wn % mod; &#125; &#125; &#125; if (on == -1) &#123; ll t = Pow(len, mod-2); for(int i = 0; i &lt; len; i++) y[i] = y[i] * t % mod; &#125;&#125;const int N = 1e5 + 5;ll c[N], b[N];ll x1[N &lt;&lt; 2], x2[N &lt;&lt; 2];ll fac[N], inv[N];int main()&#123; ll n, m; fac[0] = 1; for (int i = 1; i &lt;= 100000; i++) fac[i] = fac[i - 1] * i % mod; inv[100000] = Pow(fac[100000], mod - 2); for (int i = 99999; i &gt;= 0; i--) inv[i] = inv[i + 1] * (i + 1) % mod; while (scanf("%lld", &amp;n) != EOF) &#123; for (int i = 0; i &lt;= n; i++) scanf("%lld", &amp;c[i]); ll s = 0; scanf("%lld", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; ll a; scanf("%lld", &amp;a); s = (s + a + mod) % mod; &#125; if (s == 0) &#123; for (int i = 0; i &lt;= n; i++) printf("%lld ", c[i]); putchar('\n'); continue; &#125; int len = 1; while (len &lt;= 2 * (n + 1)) len &lt;&lt;= 1; for (int i = 0; i &lt;= len; i++) x1[i] = x2[i] = 0; for (int i = 0; i &lt;= n; i++) x1[i] = c[i] * fac[i] % mod; ll tmp = 1ll; for (int i = n; i &gt;=0; i--) &#123; x2[i] = tmp * inv[n - i] % mod; tmp = tmp * (-s) % mod; tmp = (tmp + mod) % mod; &#125; ntt(x1, len, 1); ntt(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i] % mod; ntt(x1, len, -1); for (int i = n; i &lt;= 2 * n; i++) printf("%lld ", x1[i] * inv[i - n] % mod); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXD and dividing]]></title>
    <url>%2F2019%2F06%2F23%2FRXD-and-dividing%2F</url>
    <content type="text"><![CDATA[题目链接题意有一棵n个点的树，每条边有边权，现在要求将$2,3,4…n$划分成$k$部分，定义$f(S)$为$S$集合的最小斯坦纳树的边权和。求res=\sum_{i=1}^{k}f({1} \bigcup S_{i})最大。 思路首先解释一下什么是斯坦纳树。 斯坦纳树斯坦纳树允许在给定的集合外多加一些点，使得总开销最小。最小生成树是一种特殊的斯坦纳树。 贪心按照贡献计算，每个几何最后都要和1号点也就是根结点连通，所以如果选择他或他的子结点作为一个集合的一部分，那么它上面这条边能产生w_{i}的贡献，他最大贡献即是w_{i} \times min(size(u), k)，只要$dfs$一下就可以了。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kanade's trio]]></title>
    <url>%2F2019%2F06%2F23%2FKanade-s-trio%2F</url>
    <content type="text"><![CDATA[题目链接题意数列$A$，计算有多少$i,j,k$满足i < j < k, A_{i} xor A_{j} < A_{j} xor A_{k}. 思路如果已经确定A_{i}与A_{k}，那么我们很容易根据他们两个二进制中最高的不同那位确定出A_{j}这一位是什么。建一棵字典树，我们枚举$k$，在树上插入A_{k}，插入过程中我们可以顺便求出有多少$i$与$j$是满足要求的。假设我们现在找到了A_{k}的第$p$位，如果是0，我们可以去找这一位是1的A_{i}，现在的问题是如何找$j$有多少个。 第一部分，A_{i}与A_{j}都是当前节点的儿子。即二者前$p-1$位都和A_{k}一样。这个比较好理解。第二部分，A_{i}是这个节点的儿子，A_{j}在其它地方。第三部分，第二部分直接计数会有一部分$i &gt; j$的也被计入，所以要把它减去，于是我们想到用一个新东西去记录每个数字被插入前，有多少个数字不在他的子树里，而且当前这一位和他相同。这是下面代码中的$ext$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 2e7 + 5;int tot;int size[N], ch[N][2];ll ext[N], cnt[32][2];int root;int newnode()&#123; size[++tot] = 0; ch[tot][1] = ch[tot][0] = 0; return tot;&#125;ll ans = 0;void insert(ll x)&#123; int cur = root; for (int i = 31; i &gt;= 0; i--) &#123; int d = (x &gt;&gt; i) &amp; 1; ll s = size[ch[cur][!d]]; ans += s * (s - 1) / 2; ans += (cnt[i][!d] - s) * s - ext[ch[cur][!d]]; if (!ch[cur][d]) ch[cur][d] = newnode(); cur = ch[cur][d]; ext[cur] += cnt[i][d] - size[cur]; cnt[i][d]++; size[cur]++; &#125;&#125;int main()&#123; int n, T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); memset(cnt, 0, sizeof(cnt)); memset(ext, 0, sizeof(ext)); tot = 0; root = newnode(); ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); insert(x); &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>01-Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kanade's sum]]></title>
    <url>%2F2019%2F06%2F23%2FKanade-s-sum%2F</url>
    <content type="text"><![CDATA[题目链接题意定义$f(l, r, k)$为$A[l…r]$的$k-th$大。计算 \sum_{l=1}^{n} \sum_{r=l}^{n} f(l, r, k). 思路不妨计算每个数字的贡献，我们求出每个数字的贡献区间即可。标程是用链表写的。我觉得其实笛卡尔树也是一个不错的选择，每次删的都是根结点，但是会T，因为如果树的形状是第一个元素次小的样子，去找那$k$个区间的时候是$O(n)$的。我还是把它贴在这里吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 5e5 + 5;ll seed = 17124057;#define ls(x) treap[x].child[0]#define rs(x) treap[x].child[1]struct node&#123; int val, key, size; int child[2];&#125;treap[N];void push_up(int root)&#123; treap[root].size = treap[ls(root)].size + treap[rs(root)].size + 1;&#125;void split(int root, int &amp;x, int &amp;y, int val)&#123; return;&#125;void merge(int &amp;root, int x, int y)&#123; if (!x || !y) &#123; root = x + y; return; &#125; if (treap[x].key &lt;= treap[y].key) &#123; root = x; merge(rs(x), rs(x), y); &#125; else &#123; root = y; merge(ls(y), x, ls(y)); &#125; push_up(root);&#125;int tot = 0;int root;void insert(int val, int key)&#123; int z = ++tot; treap[z].size = 1; treap[z].val = val; treap[z].key = key; ls(z) = 0, rs(z) = 0; merge(root, root, z);&#125;ll ans = 0;ll interval[2][100];int n, k;void dfs(int dir, int u, int &amp;le)&#123; if (!u) return; dfs(dir, treap[u].child[!dir], le); if (le &gt;= k) return; interval[dir][++le] = 1ll * treap[u].val; if (le &gt;= k) return; dfs(dir, treap[u].child[dir], le);&#125;void solve()&#123; int top = root; //dbg(treap[root].val, treap[root].key); int le = 0, ri = 0; dfs(0, ls(root), le); dfs(1, rs(root), ri); interval[0][0] = interval[1][0] = treap[root].val; if (le &lt; k) interval[0][++le] = 0; if (ri &lt; k) interval[1][++ri] = n + 1; for (int i = 1; i &lt;= le; i++) &#123; if (k - i + 1 &gt; ri) continue; ans = ans + treap[root].val * 1ll * (interval[0][i - 1] - interval[0][i]) * (interval[1][k - i + 1] - interval[1][k - i]); &#125; merge(root, ls(root), rs(root));&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;k); tot = 0; root = 0; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); insert(i, x); &#125; ans = 0; for (int i = 1; i &lt;= n; i++) solve(); printf("%lld\n", ans); &#125; return 0;&#125; 链表1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 10;typedef long long ll;int pre[N], nxt[N], v[N], pos[N], n, k;ll a[N], b[N];ll solve(int x) &#123; int c1 = 0, c2 = 0; for(int i = x; i &amp;&amp; c1 &lt;= k; i = pre[i]) a[++c1] = i - pre[i]; for(int i = x; i &lt;= n &amp;&amp; c2 &lt;= k; i = nxt[i]) b[++c2] = nxt[i] - i; ll ans = 0; for(int i = 1; i &lt;= c1; i++) if(k - i + 1 &lt;= c2 &amp;&amp; k - i + 1 &gt;= 1) ans += a[i] * b[k-i+1]; return ans;&#125;void del(int x) &#123; pre[nxt[x]] = pre[x]; nxt[pre[x]] = nxt[x];&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;v[i]), pos[v[i]] = i; for(int i = 0; i &lt;= n + 1; i++) pre[i] = i - 1, nxt[i] = i + 1; pre[0] = 0; nxt[n+1] = n + 1; ll ans = 0; for(int i = 1; i &lt;= n; i++) &#123; ans += solve(pos[i]) * i; del(pos[i]); &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kanade's convolution]]></title>
    <url>%2F2019%2F06%2F22%2FKanade-s-convolution%2F</url>
    <content type="text"><![CDATA[题目链接题意已知$A$和$B$数列，且 C_{k} = \sum_{i and j = k} A_{i xor j} \times B_{i or j}.计算 \sum_{i=0}^{ {2}^{m} - 1} C_{i} \times {1526}^{i} mod 998244353. 思路设$i$ $or$ $j = x$,$i$ $xor$ $j = y$.那么$i$ $and$ $j = x$ $xor$ $y$.且要求$x$ $and$ $y = y$. C_{k} = \sum_{x} \sum_{y} [x and y == y] \times [x xor y == k] \times B_{x} \times A_{y} \times {2}^{bit(y)}.C_{k} = \sum_{x xor y = k} [x and y == y] \times B_{x} \times A_{y} \times {2}^{bit(y)}.C_{k} = \sum_{x xor y = k} [bit(x) - bit(y) == bit(k)] \times B_{x} \times A_{y} \times {2}^{bit(y)}.考虑新的函数F(A, k)_{i}表示[bit(i)==k] \times A_{i}，F(B, k)_{i}同理。 则有FWT[F(C, h)] = \sum_{i=k}^{m} FWT[F(A, i-h)] * FWT[F(B, i) )]. C_{k} = F(C, bit(k))_{k}.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const ll mod = 998244353;const ll inv2 = (998244353 + 1) / 2;/*void FWT_or(ll *a, int n, int opt)&#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) for (int k = 0; k &lt; n; ++k) if (opt == 1) a[i + j + k] = a[j + k] + a[i + j + k]; else a[i + j + k] = a[i + j + k] - a[j + k];&#125;void FWT_and(ll *a, int n, int opt)&#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) for (int k = 0; k &lt; i; ++k) if (opt == 1) a[j + k] = a[j + k] + a[i + j + k]; else a[j + k] = a[j + k] - a[i + j + k];&#125;*/void FWT_xor(ll *a, int n, int opt)&#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) for (int k = 0; k &lt; i; ++k) &#123; ll X = a[j + k], Y = a[i + j + k]; a[j + k] = (X + Y) % mod; a[i + j + k] = (X - Y + mod) % mod; if (opt == -1) a[j + k] = 1ll * a[j + k] * inv2 % mod, a[i + j + k] = 1ll * a[i + j + k] * inv2 % mod; &#125;&#125;const int N = 1e6 + 5;ll a[20][N], b[20][N];ll A[N], B[N];ll c[20][N];int main()&#123; int m; scanf("%d", &amp;m); int up = 1 &lt;&lt; m; for (int i = 0; i &lt; up; i++) &#123; scanf("%lld", &amp;A[i]); A[i] = A[i] * (1 &lt;&lt; (__builtin_popcount(i))) % mod; &#125; for (int i = 0; i &lt; up; i++) scanf("%lld", &amp;B[i]); for (int i = 0; i &lt; up; i++) for (int k = 0; k &lt;= m; k++) &#123; a[k][i] = (__builtin_popcount(i) == k)? A[i] : 0; b[k][i] = (__builtin_popcount(i) == k)? B[i] : 0; &#125; for (int k = 0; k &lt;= m; k++) &#123; FWT_xor(a[k], up, 1); FWT_xor(b[k], up, 1); &#125; for (int h = 0; h &lt;= m; h++) for (int k = 0; k &lt;= h; k++) &#123; for (int i = 0; i &lt; up; i++) c[k][i] = (c[k][i] + a[h - k][i] * b[h][i] % mod) % mod; &#125; for (int i = 0; i &lt;= m; i++) FWT_xor(c[i], up, -1); ll ans = 0; ll base = 1; for (int i = 0; i &lt; up; i++) &#123; ans = ans + base * c[__builtin_popcount(i)][i] % mod; ans %= mod; base = base * 1526 % mod; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXD and math]]></title>
    <url>%2F2019%2F06%2F22%2FRXD-and-math%2F</url>
    <content type="text"><![CDATA[题目链接题意计算\sum_{i-1}^{ {n}^{k} } { \mu(i)}^{2} \left \lfloor \sqrt{ \frac{ {n}^{k} }{i} } \right \rfloor. 思路赛中是找规律的，规律是比较明显。 根据题解的说法，任意一个数字可以表示成x={a}^{2} \times b.其中$b$是不含二次因子的，| \mu(b)|=1. 这个式子相当于在枚举$b$，然后问能用$a$和$b$表示成${n}^{k}$以内多少个数字.对于每一个$b$，$a$有\left \lfloor \sqrt{ \frac{ {n}^{k} }{i} } \right \rfloor 种。所以相当于所有数字都被数了一遍，答案就是${n}^{k}.$]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXD's date]]></title>
    <url>%2F2019%2F06%2F22%2FRXD-s-date%2F</url>
    <content type="text"><![CDATA[题目链接题意找出小于等于35的数字数量即可队友把我咕了好伤心… 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; scanf("%d", &amp;n); int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); cnt += (x &lt;= 35); &#125; printf("%d\n", cnt); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>签到题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组套权值线段数]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%A0%91%E5%A5%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[码量预警我们常常使用可持久化线段树来二分求得区间第k大，但是主席树只能应对没有修改的情况，一旦有修改，修改量对于主席树来说将是灾难性的打击。所以我们不能直接修改后面每一棵线段树。处理区间问题我们最常用的套路之一不就是树状数组么，所以我们在这里用树状数组优化出一个log，虽说还是复杂度有点爆炸，但是已经够用了。 树状数组每个点代表一个权值线段树，这棵权值线段树我们也不需要全部建出来，只需要log个点。虽然叫作带修主席树，但他和主席树本质是不一样的，它的思想更像是原本的若干棵权值线段树，每棵树并非承接上一个，而是独立一棵，没有儿子共享的问题。趁着今天大概还明白它是什么东西，赶紧记录一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5e4 + 5;const int M = 1e4 * 2 + N;int n, m;struct query&#123; int x, y, k, type, id;&#125;q[M];int a[N], sum[N];int lowbit(int x)&#123; return x &amp; (-x);&#125;void update(int x, int val)&#123; while (x &lt;= n) &#123; sum[x] += val; x += lowbit(x); &#125;&#125;int get(int x)&#123; if (x == 0) return 0; int ans = 0; while (x) &#123; ans += sum[x]; x -= lowbit(x); &#125; return ans;&#125;int maxnum, tot = 0;char op[5];query q1[M], q2[M];int ans[M];bool is[M];void init()&#123; memset(sum, 0, sizeof(sum)); memset(ans, 0, sizeof(ans)); memset(is, 0, sizeof(is)); return;&#125;void solve(int head, int tail, int l, int r)&#123; if (head &gt; tail) &#123; return; &#125;/* printf("l , r , %d %d\n", l, r); for (int i = head; i &lt;= tail; i++) &#123; printf("query %d %d %d %d %d\n", q[i].x, q[i].y, q[i].k, q[i].type, q[i].id); &#125;*/ if (l == r) &#123; for (int i = head; i &lt;= tail; i++) &#123; if(q[i].type == 2) &#123; is[q[i].id] = 1; ans[q[i].id] = l; &#125; &#125; return; &#125; int mid = l + r &gt;&gt; 1; int f = 0, s = 0; for (int i = head; i &lt;= tail; i++) &#123; if (q[i].type == 1) &#123; if (q[i].y &lt;= mid) &#123; update(q[i].x, q[i].k); q1[++f] = q[i]; &#125; else &#123; q2[++s] = q[i]; &#125; &#125; if (q[i].type == 2) &#123; int ss = get(q[i].y) - get(q[i].x - 1); // printf("ss &amp;&amp; %d %d\n", get(q[i].y), get(q[i].x - 1)); if (ss &gt;= q[i].k) &#123; q1[++f] = q[i]; &#125; else &#123; q[i].k -= ss; q2[++s] = q[i]; &#125; &#125; &#125; for (int i = 1; i &lt;= f; i++) if (q1[i].type == 1) update(q1[i].x, -q1[i].k); int qpos = head; for (int i = 1; i &lt;= f; i++, qpos++) q[qpos] = q1[i]; for (int i = 1; i &lt;= s; i++, qpos++) q[qpos] = q2[i]; solve(head, head + f - 1, l, mid); solve(head + f, tail, mid + 1, r);&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); freopen("out1.txt", "w", stdout); #endif int T; scanf("%d", &amp;T); while (T--) &#123; init(); scanf("%d%d", &amp;n, &amp;m); maxnum = 0; tot = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); maxnum = max(maxnum, a[i]); q[++tot].x = i; q[tot].y = a[i]; q[tot].k = 1; q[tot].type = 1; q[tot].id = tot; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%s", op); int x, y; scanf("%d%d", &amp;x, &amp;y); if (op[0] == 'Q') &#123; q[++tot].type = 2; int k; scanf("%d", &amp;k); q[tot].x = x, q[tot].y = y; q[tot].k = k; q[tot].id = tot; &#125; else &#123; q[++tot].type = 1; q[tot].x = x; q[tot].y = a[x]; q[tot].k = -1; q[tot].id = tot; q[++tot].type = 1; q[tot].x = x; q[tot].y = y; q[tot].id = tot; q[tot].k = 1; maxnum = max(maxnum, y); a[x] = y; &#125; &#125; solve(1, tot, 0, maxnum); for (int i = 1; i &lt;= tot; i++) &#123; if (is[i]) printf("%d\n", ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String and String]]></title>
    <url>%2F2019%2F06%2F22%2FString-and-String%2F</url>
    <content type="text"><![CDATA[题目链接题意输入两个字符串$s$,$t$，且$S$串每个位置有权值$f(i)$，定义$Sval$为$S$串（所有匹配$T$串某一个位置）的子串的右端点权值的和。$q$次操作：1.把 f(a_{i} XOR ans)改为b_{i} XOR ans。 2.询问$T$子串T.substr(a_{i} XOR ans, b_{i} XOR ans)的$Sval$。 思路这题理解了好久，可能还没理解透彻。先整理下思路，后面更新代码。总的来说是一道码量惊人的题目。 后缀自动机实现匹配，我们很容易想到后缀自动机，首先将$S$拼接在$T$后面（反过来也行），建出的后缀自动机，但是由于这题权值定义为右端点，如果用后缀去搞，我们明显更容易确定左端点，所以我们在建串的时候先把两个串反过来。那么能够匹配$T$串某一个子串的$S$串起始位置在后缀树组上其实是一段连续的区间，我们现在要求的其实就是这段区间里其实位置在$S$串要求范围里的$f$值。 RMQ首先我们来看一下怎么找这个区间，利用后缀数组，我们可以知道两个不同位置开始的后缀的$lcp$，我们可以在上面两次二分，找出最大的能够匹配整个要求的$T$子串的范围。怎么check呢？回想我们以前后缀数组的套路，无非就是RMQ一下，看看整个区间是不是height最小值大于等于我们要的长度。 树套数我们现在已经利用RMQ知道了这个后缀数组中的区间在哪里，现在要做的就是求和。也就是\sum_{i=0}^{k}f(y_{i}) (c_{i} XOR ans \leq x_{i}, y_{i} \leq d_{i} XOR ans).如果只是普通求$f$和我们一个线段树或树状数组就可以解决，现在还有一维范围要求，那么我们可以树套数解决这个问题。树状数组的每个点都是一棵线段树，按照sa的顺序往线段树里面加点，这样就可以求出一个后缀数组区间里指定范围内的权值和。 蔡队代码，具体可见wiki123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;bits/stdc++.h&gt;using std::min;using std::printf;using std::reverse;using std::scanf;using std::swap;const int maxn = 1 &lt;&lt; 19;namespace Suffix_Array&#123;char s[maxn];int sa[maxn], t[maxn], t2[maxn], c[maxn], rank[maxn], height[maxn];void build_sa(int m, int n)&#123; n++; int *x = t, *y = t2; for (int i = 0; i &lt; m; i++) c[i] = 0; for (int i = 0; i &lt; n; i++) c[x[i] = s[i]]++; for (int i = 1; i &lt; m; i++) c[i] += c[i - 1]; for (int i = n - 1; ~i; i--) sa[--c[x[i]]] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for (int i = n - k; i &lt; n; i++) y[p++] = i; for (int i = 0; i &lt; n; i++) if (sa[i] &gt;= k) y[p++] = sa[i] - k; for (int i = 0; i &lt; m; i++) c[i] = 0; for (int i = 0; i &lt; n; i++) c[x[y[i]]]++; for (int i = 1; i &lt; m; i++) c[i] += c[i - 1]; for (int i = n - 1; ~i; i--) sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for (int i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++; if (p &gt;= n) break; m = p; &#125; n--; int k = 0; for (int i = 0; i &lt;= n; i++) rank[sa[i]] = i; for (int i = 0; i &lt; n; i++) &#123; if (k) k--; int j = sa[rank[i] - 1]; while (s[i + k] == s[j + k]) k++; height[rank[i]] = k; &#125;&#125;int dp[maxn][30];void initrmq(int n)&#123; for (int i = 1; i &lt;= n; i++) dp[i][0] = height[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125;int rmq(int l, int r)&#123; int k = 31 - __builtin_clz(r - l + 1); return min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);&#125;int lcp(int a, int b)&#123; a = rank[a], b = rank[b]; if (a &gt; b) swap(a, b); return rmq(a + 1, b);&#125;&#125; // namespace Suffix_Arrayusing Suffix_Array::build_sa;using Suffix_Array::initrmq;using Suffix_Array::lcp;using Suffix_Array::rank;using Suffix_Array::rmq;using Suffix_Array::sa;namespace BIT&#123;int n, m;int root[maxn], lson[maxn &lt;&lt; 4], rson[maxn &lt;&lt; 4], sum[maxn &lt;&lt; 4], sz;void init(int n, int m)&#123; BIT::n = n, BIT::m = m; for (int i = 0; i &lt;= n; i++) root[i] = -1; sz = 0;&#125;#define Lson l, m, lson[o]#define Rson m + 1, r, rson[o]void update(int p, int v, int l, int r, int&amp; o)&#123; if (!~o) o = sz++, sum[o] = 0, lson[o] = -1, rson[o] = -1; assert(sz &lt; (maxn &lt;&lt; 4)); sum[o] += v; if (l == r) return; const int m = l + r &gt;&gt; 1; if (p &lt;= m) update(p, v, Lson); else update(p, v, Rson);&#125;int query(int L, int R, int l, int r, int o)&#123; if (!~o) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return sum[o]; const int m = l + r &gt;&gt; 1; int ret = 0; if (L &lt;= m) ret += query(L, R, Lson); if (m &lt; R) ret += query(L, R, Rson); return ret;&#125;void update(int x, int p, int v)&#123; for (int i = x; i &lt;= n; i += i &amp; -i) update(p, v, 0, m, root[i]);&#125;int query(int L, int R, int l, int r)&#123; int ret = 0; for (int i = R; i; i -= i &amp; -i) ret += query(l, r, 0, m, root[i]); for (int i = L - 1; i; i -= i &amp; -i) ret -= query(l, r, 0, m, root[i]); return ret;&#125;&#125; // namespace BITchar s[maxn], t[maxn];int f[maxn];int ans;inline void decode(int&amp; a) &#123; a ^= ans; &#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; ans = 0; scanf("%s%s", s, t); int n = strlen(s), m = strlen(t); reverse(s, s + n), reverse(t, t + m); for (int i = 0; s[i]; i++) scanf("%d", f + i); reverse(f, f + n); int sz = 0; for (int i = 0; s[i]; i++) Suffix_Array::s[sz++] = s[i]; Suffix_Array::s[sz++] = '$'; for (int i = 0; t[i]; i++) Suffix_Array::s[sz++] = t[i]; Suffix_Array::s[sz] = 0; assert(sz == n + m + 1); build_sa(128, sz); initrmq(sz); BIT::init(sz, n - 1); for (int i = 1; i &lt;= sz; i++) if (sa[i] &lt; n) BIT::update(i, sa[i], f[sa[i]]); int q; scanf("%d", &amp;q); while (q--) &#123; static int op, a, b, c, d; scanf("%d", &amp;op); if (op == 1) &#123; scanf("%d%d", &amp;a, &amp;b); decode(a), decode(b); a = n - a - 1; assert(a &lt; n &amp;&amp; a &gt;= 0); BIT::update(rank[a], a, b - f[a]); f[a] = b; &#125; else if (op == 2) &#123; scanf("%d%d%d%d", &amp;c, &amp;d, &amp;a, &amp;b); decode(a), decode(b), decode(c), decode(d); a = n - 1 - a, b = n - 1 - b, c = m - c + n, d = m - d + n; swap(a, b), swap(c, d); int l = 1, r = rank[c] - 1; int lb = rank[c], ub = rank[c]; while (l &lt;= r) &#123; int m = l + r &gt;&gt; 1; if (rmq(m + 1, rank[c]) &gt;= d - c + 1) lb = m, r = m - 1; else l = m + 1; &#125; l = rank[c] + 1, r = sz; while (l &lt;= r) &#123; int m = l + r &gt;&gt; 1; if (rmq(rank[c] + 1, m) &gt;= d - c + 1) ub = m, l = m + 1; else r = m - 1; &#125; b = b - d + c; if (a &gt; b) ans = 0; else ans = BIT::query(lb, ub, a, b); printf("%d\n", ans); &#125; else assert(false); &#125; &#125;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>Tree</tag>
        <tag>String</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[If the starlight never fade]]></title>
    <url>%2F2019%2F06%2F21%2Fstarlight%2F</url>
    <content type="text"><![CDATA[题目链接题意定义$f(i)$表示方程${(x+y)}^{i} \equiv {x}^{i} (mod p), 1 \leq x \leq p-1, 1 \leq y \leq m $ 解的数量, $p$为素数。要求计算\sum_{i=1}^{p-1}if(i)。 思路令g为p的原根,x \equiv {g}^{a} (mod p), y \equiv {g}^{b} (mod p)，那么有 { ({g}^{a}+{g}^{b}) }^{i} \equiv {g}^{ai} (mod p){(1+{g}^{b-a}) }^{i} \equiv 1 (mod p)注意到1+{g}^{b-a} > 1 可以令1+{g}^{b-a} \equiv {g}^{k} (mod p)，则有 {g}^{ki} \equiv 1 (mod p).ki \equiv 0 (mod p-1).k= \frac{s \times (p-1)}{i}k= \frac{t \times (p-1)}{gcd(i, p-1)}因为k不能取0，所以k有gcd(i,p-1)-1种取值，逆推上去，f(i)=m (gcd(i, p-1)-1). \sum_{i=1}^{p-1}if(i) = \sum_{i=1}^{p-1}i m (gcd(i,p-1)-1)= m \sum_{i=1}^{p-1}igcd(i,p-1) - m \frac{(p-1)p}{2}S_{1} = m \sum_{d|(p-1)}^{p-1}{d}^{2} \sum_{e=1}^{ \frac{p-1}{d}}e[gcd(e, \frac{p-1}{d}) == 1]= m \sum_{d|(p-1)}^{p-1}{d}^{2} \frac{ \frac{(p-1)}{d} \varphi(\frac{(p-1)}{d})}{2}.]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>原根</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular polygon]]></title>
    <url>%2F2019%2F06%2F21%2FRegular-polygon%2F</url>
    <content type="text"><![CDATA[题目链接题意二维平面上有$n$个点，问你这些点能组成多少个正多边形。 思路观察一下就可以发现，除了正四边形整数点不可能构成其他多边形，所以我们只需要找有多少个正四边形。注意这个题的四边形其实可以是斜着的，所以我们不能只枚举左下角。需要枚举至少两个点。我的方法是枚举其中两个点，这两个点会构成一个向量$(dx,dy)$，有一个可能的正方形是这样的:$(0,0),(dx,dy),(-dy,dx),(dx-dy,dx+dy).$我们去看是否这四个点都存在，如果存在记录答案，最后答案除以4，因为每个正方形的4条边都被计算了一次。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 205;int mov[3][2]=&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;1,1&#125;&#125;;bool has[210][210];vector&lt;pair&lt;int, int&gt; &gt; v;int main()&#123; int n; while (scanf("%d", &amp;n) != EOF) &#123; for (int i = 0; i &lt;= 209; i++) for (int j = 0; j &lt;= 209; j++) has[i][j] = 0; v.clear(); for (int i = 1; i &lt;= n; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); has[x + 100][y + 100] = true; v.push_back(make_pair(x, y)); &#125; ll cnt = 0; int sz=v.size(); for (int i=0;i&lt;sz;i++) &#123; int x=v[i].first,y=v[i].second; for(int j=0;j&lt;sz;j++)&#123; int xx=v[j].first,yy=v[j].second; if(j==i) continue; int dx=xx-x,dy=yy-y; int flag=1; int dxx=x-dy,dyy=y+dx; if(dxx&lt;-100 || dxx&gt;100 || dyy&lt;-100 || dyy&gt;100||!has[dxx+100][dyy+100])&#123; flag=0; &#125; dxx=x-dy+dx,dyy=y+dx+dy; if(dxx&lt;-100 || dxx&gt;100 || dyy&lt;-100 || dyy&gt;100||!has[dxx+100][dyy+100])&#123; flag=0; &#125; cnt+=flag; &#125; &#125; printf("%lld\n",cnt / 4); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TrickGCD]]></title>
    <url>%2F2019%2F06%2F21%2FTrickGCD%2F</url>
    <content type="text"><![CDATA[题目链接题意输入$a$数组，询问有多少个$b$数组使得： 1 \leq b_{i} \leq a_{i}gcd(b_{l},b_{l+1},b_{l+2}...b_{r}) \geq 2, 1 \leq l \leq r \leq n.思路首先容易想到这题要求整个$b$数列的最大公约数大于1，简记其$gcd$为$gcd(b)$。不妨设$F(d)$表示$d|gcd(b)$的方案数，$f(d)$表示$gcd(b)=d$的方案数。 F(n)= \sum_{n|d}f(d)f(n) = \sum_{n|d} \mu(\frac{d}{n}) F(d)F(d)= \prod_{i=1}^{n} \left \lfloor \frac{a_{i}}{d} \right \rfloor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;int prime[10000];int tot;bool vis[N];ll miu[N];void pre(int n)&#123; tot = 0; miu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) prime[++tot] = i, miu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; miu[i * prime[j]] = 0; break; &#125; miu[i * prime[j]] = -miu[i]; &#125; &#125;&#125;ll cnt[N];int a[N];const ll mod = 1e9 + 7;ll f[N];ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; int n; pre(100000); int T; scanf("%d", &amp;T); for (int ks = 1; ks &lt;= T; ks++) &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt;= 100000; i++) cnt[i] = 0; int mnv = 0x3f3f3f3f, mxv = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); mnv = min(mnv, a[i]); mxv = max(mxv, a[i]); cnt[a[i]]++; &#125; if (mnv &lt;= 1) &#123; printf("Case #%d: %lld\n", ks, 0ll); continue; &#125; for (int i = 1; i &lt;= mxv; i++) cnt[i] = cnt[i] + cnt[i - 1]; ll ans = 0; int j; for (int i = 0; i &lt;= mxv; i++) f[i] = 0ll; for (int i = 2; i &lt;= mnv; i++) &#123; f[i] = 1ll; for (int l = i; l &lt;= mxv; l += i) &#123; //f[i] = f[i] * (cnt[min(l + i - 1, mxv)] - cnt[l - 1] + mod) % mod * (l / i) % mod; f[i] = f[i] * Pow(1ll * l / i, cnt[min(l + i - 1, mxv)] - cnt[l - 1]) % mod; &#125; //dbg(i, f[i]); /* for (int j = i; j &lt;= mxv; j++) &#123; f[i] = f[i] * Pow(j / i, cnt[j]) % mod; &#125; */ &#125; for (int i = 2; i &lt;= mnv; i++) &#123; for (int d = i; d &lt;= mxv; d += i) ans = (ans + f[d] * miu[d / i] % mod + mod) % mod; &#125; printf("Case #%d: %lld\n", ks, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Mobius inversion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Funny Function]]></title>
    <url>%2F2019%2F06%2F21%2FFunny-Function%2F</url>
    <content type="text"><![CDATA[题目链接题意F_{1,1}=F_{1,2}=1F_{1,i}=F_{1,i-1}+2F_{1,i-2}, i \geq 3F_{i,j}= \sum_{k=j}^{j+n-1} F_{i-1,k} (i \geq 2, j \geq 1)输入$n$和$m$，计算F_{m,1}.对$1000000007$取模。 思路首先很容易可以用特征根计算出F_{1,i}的通项公式。 F_{1,i}= \frac{1}{3} {2}^{i} - \frac{1}{3} {(-1)}^{i}然后无脑计算F_{i,j},容易发现其实他也是等比数列。 F_{i,j} = \sum_{k=j}^{j+n-1} F_{i-1,k}F_{2,j}= \sum_{k=j}^{j+n-1} \frac{1}{3} {2}^{k-1} - \sum_{k=j}^{j+n-1} \frac{1}{3} {(-1)}^{k-1}= (\frac{1}{3} {2}^{n}) {2}^{j} - \frac{1}{3} (1-{(-1)}^{n}) {(-1)}^{j}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const ll mod = 1e9 + 7;ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;int main()&#123; int T; read(T); while (T--) &#123; ll n, m; read(n); read(m); ll ans = 0; ll inv3 = Pow(3, mod - 2); ans = Pow(2, n % (mod - 1)) - 1; ans = (ans + mod) % mod; ans = Pow(ans, m - 1) % mod * inv3 % mod; ans = ans * 2 % mod; if (n % 2 == 1) &#123; ans = (ans + inv3 + mod) % mod; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Sequence]]></title>
    <url>%2F2019%2F06%2F21%2FMaximum-Sequence%2F</url>
    <content type="text"><![CDATA[题目链接队友直接过了，打扰了]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Is Derek lying?]]></title>
    <url>%2F2019%2F06%2F21%2FIs-Derek-lying%2F</url>
    <content type="text"><![CDATA[题目链接题意有$n$到题，有两个人，每个人都做了选择，并且分别得分为$x$, $y$，现在问这个分数是否是真实的。 思路这题解法肯定是去从二者答案相同数量和不同数量去考虑，设相同答案数量为$cnt$，如果分数真实，需要满足以下条件：分数的差异来自于答案的差异，所以分数只差一定小于等于不同答案数量，即$abs(x-y) \leq n-cnt.$两个人分数之和最多是两个人相同的全对，所以$x+y \leq n + cnt$ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 80005;char s1[N], s2[N];int main()&#123; int n; int x, y; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d", &amp;n, &amp;x, &amp;y); scanf("%s%s", s1, s2); int cnt = 0; for (int i = 0; i &lt; n; i++) if (s1[i] == s2[i]) cnt++; if (x + y - cnt &gt; n) &#123; puts("Lying"); continue; &#125; cnt = n - cnt; if (abs(x - y) &gt; cnt) puts("Lying"); else puts("Not lying"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Limited Permutation]]></title>
    <url>%2F2019%2F06%2F21%2FLimited-Permutation%2F</url>
    <content type="text"><![CDATA[题目链接题意有$n$个元素的全排列的合法性定义为：有$n$个区间，对于第$i$个区间[l_{i},r_{i}]有l_{i} \leq i \leq r_{i},对于任意1 \leq L \leq i \leq R \leq n.当且仅当l_{i} \leq L \leq i \leq R \leq r_{i}时,P[i]=min(P[L],P[L+1],...,P[R])。现在给出序列和相应的区间，问多少区间是否合法？ 思路 我们可以先确定的是，这些区间一定是要么包含关系，要么交集为空，而且我们还知道，排列中最小数字的位置左端点一定是$1$，右端点一定是$n$。 我们把$n$个区间进行排序，优先左端点升序，然后右端点降序。这样第一个区间的位置$i$一定放最小的数字，$i$将数列分成两段，我们把$2$到$n$中$i-1$个数放到左边，剩下放到右边，相当于解决一个子问题，答案更新: ans = ans \times C_{n-1}^{i-1}. 123456789ll dfs(int l, int r) &#123; if (l &gt; r) return 1; if (a[rear].l != l || a[rear].r != r) return 0; node now = a[rear++]; ll ret = C(now.r - now.l, now.id - now.l) * dfs(now.l, now.id - 1) % mod; ret = (ret * dfs(now.id + 1, now.r)) % mod; return ret;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>partition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hints of sd0061]]></title>
    <url>%2F2019%2F06%2F21%2FHints-of-sd0061%2F</url>
    <content type="text"><![CDATA[题目链接题意 用给的随机函数可以得到数列$a$，$m$次查询，问第$b_{i}$小的数字。 思路 这道题要线性第$k$小，肯定是不能排序的。 一个思路是手写快排，然后将所有询问一起二分掉，比较卡的做法。 其实这是个套路题 使用STL &lt; algorithm &gt;中的 1nth_element(A, A + k, A + n) 可以在线性时间找到第k大，此题还需要一点小trick，可以先将询问排序，然后每次将排序范围缩小，可以减小枚举量。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>nth element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function]]></title>
    <url>%2F2019%2F06%2F21%2FFunction%2F</url>
    <content type="text"><![CDATA[题目链接题意 已知一个$n$的全排列$a$，和一个$m$的全排列$b$，现在问你有多少种不同的映射$f$使得满足以下条件： f(i)=b_{f(a_{i})}, 0 \leq i < n-1 答案对$1000000007$取模。 思路 假设对于我们现在已有的一个$f$映射，存在这样的关系： f(i)=b_{f(a_{i})}f(a_{i})=b_{f(a_{a_{i}})} ...f(i)=b_{b_{b_{...b_{t}}}}.则我们可以得到一个与$i$有关的闭合环，设$0$到$n-1$中有$w$个这样的环，则这些环之间是不会相互影响的，我们可以分别算出每个环有多少种合法的映射。 对于一个有$x$个数字的环，我们有多少种合法的映射呢？观察以下可以发现，只要确定其中一个位置映射的数字，就可以确定整个环中所有数字的映射，为了使环绕回$i$位置时与原来我们假设的数字不冲突。可以先在$b$数列中求出每个位置循环大小。 设为sz_{b}(i), a中环大小sz_{a}(i)，则a中包含位置i的环合法映射数量为\sum_{j=0}^{j < m} [sz_{b}(j)|sz_{a}(i)] 实际上我们只需要统计数量，所以不需要把每个位置是多少记录下来，只需要处理$a$时记录对应的$sz_{b}(j)$的数量即可。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Division Game]]></title>
    <url>%2F2019%2F06%2F20%2FDivision-Game%2F</url>
    <content type="text"><![CDATA[题目链接题意 用唯一表示法表示出n，输入m，k，表示有k堆石子，每堆有n个，现在拿石子。规则如下： 每次只能在下一堆中拿石子 每次拿走后剩余石子数量d，拿走前n，则必须有$d|n$ 拿到某一堆只剩一颗石子时游戏结束 询问在每一堆石子结束的方案数。 思路 设拿到第$i$堆，拿了$x$次结束的方案数为$f(x)$，则拿到第$i$堆，拿了$x-1$次没结束的方案数也为$f(i)$。 ans(i, x)= \prod_{j=1}^{j < i} {f(x+1)} \times \prod_{j=i+1}^{j \leq k} {f(x)}={f(x+1)}^{i-1} \times {f(x)}^{k-i+1}考虑$x$范围 记$ w= \sum e_{i} $ 当$i = 1$，$x \leq w$；当$i &gt; 1$，$x &lt; w$。 容斥计算$f(x)$ 考虑每个素因子，相当于将$e_{i}$个小球放入$x$个盒子中，不允许空。$g(x)$ 表示$x$盒子，允许空放盒子方案数。 g(x) = \prod_{i=1}^{m} {C_{e_{i}+x-1}^{x-1}} = \sum_{y=0}^{x} {(-1)}^{x-y} g(y) \frac{x!}{y!(x-y)!} 对这个式子NTT即可。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Colorful Tree]]></title>
    <url>%2F2019%2F06%2F20%2FColorful-Tree%2F</url>
    <content type="text"><![CDATA[题目链接题意 一棵有n个节点的树，每个点有一个点权，问在这棵树上所有的$\frac{n(n-1)}{2}$条链颜色种类的和是多少。 思路 对于每种颜色计算其贡献，我们可以先算出每种颜色在多少条链中不出现，用总数减一下就可以得到在多少条链中出现，dfs序处理一下，遍历到一个点的时候我只考虑这个点与其儿子构成的连同块，在这些块里面都不出现这个颜色。 dfs1234567891011121314151617void dfs(int u, int f)&#123; sz[u] = 1; ll all = 0; for (auto &amp;v : G[u]) &#123; if (v == f) continue; ll last = sum[c[u]]; dfs(v, u); sz[u] += sz[v]; ll add = sum[c[u]] - last; ans += (sz[v] - add) * (sz[v] - add - 1) / 2; all += sz[v] - add; &#125; sum[c[u]] += all + 1;&#125; 1234567891011int main()&#123; for (int i = 1; i &lt;= n; i++) &#123; if (!hasc[i]) continue; ans += (n - sum[i]) * (n - sum[i] - 1) / 2ll; &#125; printf("%lld\n", (n - 1) * n / 2 * cnt - ans); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Balala Power!]]></title>
    <url>%2F2019%2F06%2F19%2FBalala-Power%2F</url>
    <content type="text"><![CDATA[题目链接题意输入n个字符串，重新定义字母’a’~’z’的权值，使得给出的字符串在26进制下和最大 思路记录每个字母在每个位置出现的次数，按照贪心高为出现次数多的字母权值大排序（别暴力排，比赛时用个堆维护，一个数组记录最高位置）]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add More Zero]]></title>
    <url>%2F2019%2F06%2F19%2FAdd-More-Zero%2F</url>
    <content type="text"><![CDATA[题目链接题意 输入m，求最大k满足： 10^{k} \leq 2^{m} 其中$1 \leq m \leq 10^{5}$. 思路 因为当k与m均为整数时, 10^{k} \neq 2^{m}10^{k} \leq 2^{m}k \leq lg(2^{m}) = mlg(2) 直接计算答案]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2F2019%2F06%2F19%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[Congratulations for my first blog on github!!!Thanks to github and hexo. Then I probably test some function on this page. Cpp code1234567#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; printf("Hello, world.\n"); return 0;&#125; linkmore markdown rules fomularFibonacci comes like this: F(n)=F(n-1)+F(n-2)Euler function: n = \sum_{d|n} \phi (d)]]></content>
  </entry>
</search>
