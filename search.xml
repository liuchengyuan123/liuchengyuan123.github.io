<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Limited Permutation]]></title>
    <url>%2F2019%2F06%2F21%2FLimited-Permutation%2F</url>
    <content type="text"><![CDATA[题目链接题意有$n$个元素的全排列的合法性定义为：有$n$个区间，对于第$i$个区间[l_{i},r_{i}]有l_{i} \leq i \leq r_{i},对于任意1 \leq L \leq i \leq R \leq n.当且仅当l_{i} \leq L \leq i \leq R \leq r_{i}时,P[i]=min(P[L],P[L+1],...,P[R])。现在给出序列和相应的区间，问多少区间是否合法？ 思路 我们可以先确定的是，这些区间一定是要么包含关系，要么交集为空，而且我们还知道，排列中最小数字的位置左端点一定是$1$，右端点一定是$n$。 我们把$n$个区间进行排序，优先左端点升序，然后右端点降序。这样第一个区间的位置$i$一定放最小的数字，$i$将数列分成两段，我们把$2$到$n$中$i-1$个数放到左边，剩下放到右边，相当于解决一个子问题，答案更新: $ans = ans \times C{n-1}^{i-1}.$ 123456789ll dfs(int l, int r) &#123; if (l &gt; r) return 1; if (a[rear].l != l || a[rear].r != r) return 0; node now = a[rear++]; ll ret = C(now.r - now.l, now.id - now.l) * dfs(now.l, now.id - 1) % mod; ret = (ret * dfs(now.id + 1, now.r)) % mod; return ret;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>partition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hints of sd0061]]></title>
    <url>%2F2019%2F06%2F21%2FHints-of-sd0061%2F</url>
    <content type="text"><![CDATA[题目链接题意 用给的随机函数可以得到数列$a$，$m$次查询，问第$b_{i}$小的数字。 思路 这道题要线性第$k$小，肯定是不能排序的。 一个思路是手写快排，然后将所有询问一起二分掉，比较卡的做法。 其实这是个套路题 使用STL &lt; algorithm &gt;中的 1nth_element(A, A + k, A + n) 可以在线性时间找到第k大，此题还需要一点小trick，可以先将询问排序，然后每次将排序范围缩小，可以减小枚举量。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>nth element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function]]></title>
    <url>%2F2019%2F06%2F21%2FFunction%2F</url>
    <content type="text"><![CDATA[题目链接题意 已知一个$n$的全排列$a$，和一个$m$的全排列$b$，现在问你有多少种不同的映射$f$使得满足以下条件： f(i)=b_{f(a_{i})}, 0 \leq i < n-1 答案对$1000000007$取模。 思路 假设对于我们现在已有的一个$f$映射，存在这样的关系： f(i)=b_{f(a_{i})}f(a_{i})=b_{f(a_{a_{i}})} ...f(i)=b_{b_{b_{...b_{t}}}}.则我们可以得到一个与$i$有关的闭合环，设$0$到$n-1$中有$w$个这样的环，则这些环之间是不会相互影响的，我们可以分别算出每个环有多少种合法的映射。 对于一个有$x$个数字的环，我们有多少种合法的映射呢？观察以下可以发现，只要确定其中一个位置映射的数字，就可以确定整个环中所有数字的映射，为了使环绕回$i$位置时与原来我们假设的数字不冲突。可以先在$b$数列中求出每个位置循环大小。 设为sz_{b}(i), a中环大小sz_{a}(i)，则a中包含位置i的环合法映射数量为\sum_{j=0}^{j < m} [sz_{b}(j)|sz_{a}(i)] 实际上我们只需要统计数量，所以不需要把每个位置是多少记录下来，只需要处理$a$时记录对应的$sz_{b}(j)$的数量即可。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Division Game]]></title>
    <url>%2F2019%2F06%2F20%2FDivision-Game%2F</url>
    <content type="text"><![CDATA[题目链接题意 用唯一表示法表示出n，输入m，k，表示有k堆石子，每堆有n个，现在拿石子。规则如下： 每次只能在下一堆中拿石子 每次拿走后剩余石子数量d，拿走前n，则必须有$d|n$ 拿到某一堆只剩一颗石子时游戏结束 询问在每一堆石子结束的方案数。 思路 设拿到第$i$堆，拿了$x$次结束的方案数为$f(x)$，则拿到第$i$堆，拿了$x-1$次没结束的方案数也为$f(i)$。 ans(i, x)= \prod_{j=1}^{j < i} {f(x+1)} \times \prod_{j=i+1}^{j \leq k} {f(x)}={f(x+1)}^{i-1} \times {f(x)}^{k-i+1}考虑$x$范围 记$ w= \sum e_{i} $ 当$i = 1$，$x \leq w$；当$i &gt; 1$，$x &lt; w$。 容斥计算$f(x)$ 考虑每个素因子，相当于将$e_{i}$个小球放入$x$个盒子中，不允许空。$g(x)$ 表示$x$盒子，允许空放盒子方案数。 g(x) = \prod_{i=1}^{m} {C_{e_{i}+x-1}^{x-1}} = \sum_{y=0}^{x} {(-1)}^{x-y} g(y) \frac{x!}{y!(x-y)!} 对这个式子NTT即可。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Colorful Tree]]></title>
    <url>%2F2019%2F06%2F20%2FColorful-Tree%2F</url>
    <content type="text"><![CDATA[题目链接题意 一棵有n个节点的树，每个点有一个点权，问在这棵树上所有的$\frac{n(n-1)}{2}$条链颜色种类的和是多少。 思路 对于每种颜色计算其贡献，我们可以先算出每种颜色在多少条链中不出现，用总数减一下就可以得到在多少条链中出现，dfs序处理一下，遍历到一个点的时候我只考虑这个点与其儿子构成的连同块，在这些块里面都不出现这个颜色。 dfs1234567891011121314151617void dfs(int u, int f)&#123; sz[u] = 1; ll all = 0; for (auto &amp;v : G[u]) &#123; if (v == f) continue; ll last = sum[c[u]]; dfs(v, u); sz[u] += sz[v]; ll add = sum[c[u]] - last; ans += (sz[v] - add) * (sz[v] - add - 1) / 2; all += sz[v] - add; &#125; sum[c[u]] += all + 1;&#125; 1234567891011int main()&#123; for (int i = 1; i &lt;= n; i++) &#123; if (!hasc[i]) continue; ans += (n - sum[i]) * (n - sum[i] - 1) / 2ll; &#125; printf("%lld\n", (n - 1) * n / 2 * cnt - ans); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Balala Power!]]></title>
    <url>%2F2019%2F06%2F19%2FBalala-Power%2F</url>
    <content type="text"><![CDATA[题目链接题意输入n个字符串，重新定义字母’a’~’z’的权值，使得给出的字符串在26进制下和最大 思路记录每个字母在每个位置出现的次数，按照贪心高为出现次数多的字母权值大排序（别暴力排，比赛时用个堆维护，一个数组记录最高位置）]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add More Zero]]></title>
    <url>%2F2019%2F06%2F19%2FAdd-More-Zero%2F</url>
    <content type="text"><![CDATA[题目链接题意 输入m，求最大k满足： 10^{k} \leq 2^{m} 其中$1 \leq m \leq 10^{5}$. 思路 因为当k与m均为整数时, 10^{k} \neq 2^{m}10^{k} \leq 2^{m}k \leq lg(2^{m}) = mlg(2) 直接计算答案]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2F2019%2F06%2F19%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[Congratulations for my first blog on github!!!Thanks to github and hexo. Then I probably test some function on this page. Cpp code1234567#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; printf("Hello, world.\n"); return 0;&#125; linkmore markdown rules fomularFibonacci comes like this: F(n)=F(n-1)+F(n-2)Euler function: n = \sum_{d|n} \phi (d)]]></content>
  </entry>
</search>
