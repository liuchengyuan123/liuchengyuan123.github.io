<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[树状数组套权值线段数]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%A0%91%E5%A5%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[码量预警我们常常使用可持久化线段树来二分求得区间第k大，但是主席树只能应对没有修改的情况，一旦有修改，修改量对于主席树来说将是灾难性的打击。所以我们不能直接修改后面每一棵线段树。处理区间问题我们最常用的套路之一不就是树状数组么，所以我们在这里用树状数组优化出一个log，虽说还是复杂度有点爆炸，但是已经够用了。 树状数组每个点代表一个权值线段树，这棵权值线段树我们也不需要全部建出来，只需要log个点。虽然叫作带修主席树，但他和主席树本质是不一样的，它的思想更像是原本的若干棵权值线段树，每棵树并非承接上一个，而是独立一棵，没有儿子共享的问题。趁着今天大概还明白它是什么东西，赶紧记录一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5e4 + 5;const int M = 1e4 * 2 + N;int n, m;struct query&#123; int x, y, k, type, id;&#125;q[M];int a[N], sum[N];int lowbit(int x)&#123; return x &amp; (-x);&#125;void update(int x, int val)&#123; while (x &lt;= n) &#123; sum[x] += val; x += lowbit(x); &#125;&#125;int get(int x)&#123; if (x == 0) return 0; int ans = 0; while (x) &#123; ans += sum[x]; x -= lowbit(x); &#125; return ans;&#125;int maxnum, tot = 0;char op[5];query q1[M], q2[M];int ans[M];bool is[M];void init()&#123; memset(sum, 0, sizeof(sum)); memset(ans, 0, sizeof(ans)); memset(is, 0, sizeof(is)); return;&#125;void solve(int head, int tail, int l, int r)&#123; if (head &gt; tail) &#123; return; &#125;/* printf("l , r , %d %d\n", l, r); for (int i = head; i &lt;= tail; i++) &#123; printf("query %d %d %d %d %d\n", q[i].x, q[i].y, q[i].k, q[i].type, q[i].id); &#125;*/ if (l == r) &#123; for (int i = head; i &lt;= tail; i++) &#123; if(q[i].type == 2) &#123; is[q[i].id] = 1; ans[q[i].id] = l; &#125; &#125; return; &#125; int mid = l + r &gt;&gt; 1; int f = 0, s = 0; for (int i = head; i &lt;= tail; i++) &#123; if (q[i].type == 1) &#123; if (q[i].y &lt;= mid) &#123; update(q[i].x, q[i].k); q1[++f] = q[i]; &#125; else &#123; q2[++s] = q[i]; &#125; &#125; if (q[i].type == 2) &#123; int ss = get(q[i].y) - get(q[i].x - 1); // printf("ss &amp;&amp; %d %d\n", get(q[i].y), get(q[i].x - 1)); if (ss &gt;= q[i].k) &#123; q1[++f] = q[i]; &#125; else &#123; q[i].k -= ss; q2[++s] = q[i]; &#125; &#125; &#125; for (int i = 1; i &lt;= f; i++) if (q1[i].type == 1) update(q1[i].x, -q1[i].k); int qpos = head; for (int i = 1; i &lt;= f; i++, qpos++) q[qpos] = q1[i]; for (int i = 1; i &lt;= s; i++, qpos++) q[qpos] = q2[i]; solve(head, head + f - 1, l, mid); solve(head + f, tail, mid + 1, r);&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); freopen("out1.txt", "w", stdout); #endif int T; scanf("%d", &amp;T); while (T--) &#123; init(); scanf("%d%d", &amp;n, &amp;m); maxnum = 0; tot = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); maxnum = max(maxnum, a[i]); q[++tot].x = i; q[tot].y = a[i]; q[tot].k = 1; q[tot].type = 1; q[tot].id = tot; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%s", op); int x, y; scanf("%d%d", &amp;x, &amp;y); if (op[0] == 'Q') &#123; q[++tot].type = 2; int k; scanf("%d", &amp;k); q[tot].x = x, q[tot].y = y; q[tot].k = k; q[tot].id = tot; &#125; else &#123; q[++tot].type = 1; q[tot].x = x; q[tot].y = a[x]; q[tot].k = -1; q[tot].id = tot; q[++tot].type = 1; q[tot].x = x; q[tot].y = y; q[tot].id = tot; q[tot].k = 1; maxnum = max(maxnum, y); a[x] = y; &#125; &#125; solve(1, tot, 0, maxnum); for (int i = 1; i &lt;= tot; i++) &#123; if (is[i]) printf("%d\n", ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String and String]]></title>
    <url>%2F2019%2F06%2F22%2FString-and-String%2F</url>
    <content type="text"><![CDATA[题目链接题意输入两个字符串$s$,$t$，且$S$串每个位置有权值$f(i)$，定义$Sval$为$S$串（所有匹配$T$串某一个位置）的子串的右端点权值的和。$q$次操作：1.把 f(a_{i} XOR ans)改为b_{i} XOR ans。 2.询问$T$子串T.substr(a_{i} XOR ans, b_{i} XOR ans)的$Sval$。 思路这题理解了好久，可能还没理解透彻。先整理下思路，后面更新代码。总的来说是一道码量惊人的题目。 后缀自动机实现匹配，我们很容易想到后缀自动机，首先将$S$拼接在$T$后面（反过来也行），建出的后缀自动机，但是由于这题权值定义为右端点，如果用后缀去搞，我们明显更容易确定左端点，所以我们在建串的时候先把两个串反过来。那么能够匹配$T$串某一个子串的$S$串起始位置在后缀树组上其实是一段连续的区间，我们现在要求的其实就是这段区间里其实位置在$S$串要求范围里的$f$值。 RMQ首先我们来看一下怎么找这个区间，利用后缀数组，我们可以知道两个不同位置开始的后缀的$lcp$，我们可以在上面两次二分，找出最大的能够匹配整个要求的$T$子串的范围。怎么check呢？回想我们以前后缀数组的套路，无非就是RMQ一下，看看整个区间是不是height最小值大于等于我们要的长度。 树套数我们现在已经利用RMQ知道了这个后缀数组中的区间在哪里，现在要做的就是求和。也就是\sum_{i=0}^{k}f(y_{i}) (c_{i} XOR ans \leq x_{i}, y_{i} \leq d_{i} XOR ans).如果只是普通求$f$和我们一个线段树或树状数组就可以解决，现在还有一维范围要求，那么我们可以树套数解决这个问题。树状数组的每个点都是一棵线段树，按照sa的顺序往线段树里面加点，这样就可以求出一个后缀数组区间里指定范围内的权值和。 蔡队代码，具体可见wiki123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;bits/stdc++.h&gt;using std::min;using std::printf;using std::reverse;using std::scanf;using std::swap;const int maxn = 1 &lt;&lt; 19;namespace Suffix_Array&#123;char s[maxn];int sa[maxn], t[maxn], t2[maxn], c[maxn], rank[maxn], height[maxn];void build_sa(int m, int n)&#123; n++; int *x = t, *y = t2; for (int i = 0; i &lt; m; i++) c[i] = 0; for (int i = 0; i &lt; n; i++) c[x[i] = s[i]]++; for (int i = 1; i &lt; m; i++) c[i] += c[i - 1]; for (int i = n - 1; ~i; i--) sa[--c[x[i]]] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for (int i = n - k; i &lt; n; i++) y[p++] = i; for (int i = 0; i &lt; n; i++) if (sa[i] &gt;= k) y[p++] = sa[i] - k; for (int i = 0; i &lt; m; i++) c[i] = 0; for (int i = 0; i &lt; n; i++) c[x[y[i]]]++; for (int i = 1; i &lt; m; i++) c[i] += c[i - 1]; for (int i = n - 1; ~i; i--) sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for (int i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++; if (p &gt;= n) break; m = p; &#125; n--; int k = 0; for (int i = 0; i &lt;= n; i++) rank[sa[i]] = i; for (int i = 0; i &lt; n; i++) &#123; if (k) k--; int j = sa[rank[i] - 1]; while (s[i + k] == s[j + k]) k++; height[rank[i]] = k; &#125;&#125;int dp[maxn][30];void initrmq(int n)&#123; for (int i = 1; i &lt;= n; i++) dp[i][0] = height[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125;int rmq(int l, int r)&#123; int k = 31 - __builtin_clz(r - l + 1); return min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);&#125;int lcp(int a, int b)&#123; a = rank[a], b = rank[b]; if (a &gt; b) swap(a, b); return rmq(a + 1, b);&#125;&#125; // namespace Suffix_Arrayusing Suffix_Array::build_sa;using Suffix_Array::initrmq;using Suffix_Array::lcp;using Suffix_Array::rank;using Suffix_Array::rmq;using Suffix_Array::sa;namespace BIT&#123;int n, m;int root[maxn], lson[maxn &lt;&lt; 4], rson[maxn &lt;&lt; 4], sum[maxn &lt;&lt; 4], sz;void init(int n, int m)&#123; BIT::n = n, BIT::m = m; for (int i = 0; i &lt;= n; i++) root[i] = -1; sz = 0;&#125;#define Lson l, m, lson[o]#define Rson m + 1, r, rson[o]void update(int p, int v, int l, int r, int&amp; o)&#123; if (!~o) o = sz++, sum[o] = 0, lson[o] = -1, rson[o] = -1; assert(sz &lt; (maxn &lt;&lt; 4)); sum[o] += v; if (l == r) return; const int m = l + r &gt;&gt; 1; if (p &lt;= m) update(p, v, Lson); else update(p, v, Rson);&#125;int query(int L, int R, int l, int r, int o)&#123; if (!~o) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return sum[o]; const int m = l + r &gt;&gt; 1; int ret = 0; if (L &lt;= m) ret += query(L, R, Lson); if (m &lt; R) ret += query(L, R, Rson); return ret;&#125;void update(int x, int p, int v)&#123; for (int i = x; i &lt;= n; i += i &amp; -i) update(p, v, 0, m, root[i]);&#125;int query(int L, int R, int l, int r)&#123; int ret = 0; for (int i = R; i; i -= i &amp; -i) ret += query(l, r, 0, m, root[i]); for (int i = L - 1; i; i -= i &amp; -i) ret -= query(l, r, 0, m, root[i]); return ret;&#125;&#125; // namespace BITchar s[maxn], t[maxn];int f[maxn];int ans;inline void decode(int&amp; a) &#123; a ^= ans; &#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; ans = 0; scanf("%s%s", s, t); int n = strlen(s), m = strlen(t); reverse(s, s + n), reverse(t, t + m); for (int i = 0; s[i]; i++) scanf("%d", f + i); reverse(f, f + n); int sz = 0; for (int i = 0; s[i]; i++) Suffix_Array::s[sz++] = s[i]; Suffix_Array::s[sz++] = '$'; for (int i = 0; t[i]; i++) Suffix_Array::s[sz++] = t[i]; Suffix_Array::s[sz] = 0; assert(sz == n + m + 1); build_sa(128, sz); initrmq(sz); BIT::init(sz, n - 1); for (int i = 1; i &lt;= sz; i++) if (sa[i] &lt; n) BIT::update(i, sa[i], f[sa[i]]); int q; scanf("%d", &amp;q); while (q--) &#123; static int op, a, b, c, d; scanf("%d", &amp;op); if (op == 1) &#123; scanf("%d%d", &amp;a, &amp;b); decode(a), decode(b); a = n - a - 1; assert(a &lt; n &amp;&amp; a &gt;= 0); BIT::update(rank[a], a, b - f[a]); f[a] = b; &#125; else if (op == 2) &#123; scanf("%d%d%d%d", &amp;c, &amp;d, &amp;a, &amp;b); decode(a), decode(b), decode(c), decode(d); a = n - 1 - a, b = n - 1 - b, c = m - c + n, d = m - d + n; swap(a, b), swap(c, d); int l = 1, r = rank[c] - 1; int lb = rank[c], ub = rank[c]; while (l &lt;= r) &#123; int m = l + r &gt;&gt; 1; if (rmq(m + 1, rank[c]) &gt;= d - c + 1) lb = m, r = m - 1; else l = m + 1; &#125; l = rank[c] + 1, r = sz; while (l &lt;= r) &#123; int m = l + r &gt;&gt; 1; if (rmq(rank[c] + 1, m) &gt;= d - c + 1) ub = m, l = m + 1; else r = m - 1; &#125; b = b - d + c; if (a &gt; b) ans = 0; else ans = BIT::query(lb, ub, a, b); printf("%d\n", ans); &#125; else assert(false); &#125; &#125;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>data structure</tag>
        <tag>String</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[If the starlight never fade]]></title>
    <url>%2F2019%2F06%2F21%2Fstarlight%2F</url>
    <content type="text"><![CDATA[题目链接题意定义$f(i)$表示方程${(x+y)}^{i} \equiv {x}^{i} (mod p), 1 \leq x \leq p-1, 1 \leq y \leq m $ 解的数量, $p$为素数。要求计算\sum_{i=1}^{p-1}if(i)。 思路令g为p的原根,x \equiv {g}^{a} (mod p), y \equiv {g}^{b} (mod p)，那么有 { ({g}^{a}+{g}^{b}) }^{i} \equiv {g}^{ai} (mod p){(1+{g}^{b-a}) }^{i} \equiv 1 (mod p)注意到1+{g}^{b-a} > 1 可以令1+{g}^{b-a} \equiv {g}^{k} (mod p)，则有 {g}^{ki} \equiv 1 (mod p).ki \equiv 0 (mod p-1).k= \frac{s \times (p-1)}{i}k= \frac{t \times (p-1)}{gcd(i, p-1)}因为k不能取0，所以k有gcd(i,p-1)-1种取值，逆推上去，f(i)=m (gcd(i, p-1)-1). \sum_{i=1}^{p-1}if(i) = \sum_{i=1}^{p-1}i m (gcd(i,p-1)-1)= m \sum_{i=1}^{p-1}igcd(i,p-1) - m \frac{(p-1)p}{2}S_{1} = m \sum_{d|(p-1)}^{p-1}{d}^{2} \sum_{e=1}^{ \frac{p-1}{d}}e[gcd(e, \frac{p-1}{d}) == 1]= m \sum_{d|(p-1)}^{p-1}{d}^{2} \frac{ \frac{(p-1)}{d} \varphi(\frac{(p-1)}{d})}{2}.]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>原根</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular polygon]]></title>
    <url>%2F2019%2F06%2F21%2FRegular-polygon%2F</url>
    <content type="text"><![CDATA[题目链接题意二维平面上有$n$个点，问你这些点能组成多少个正多边形。 思路观察一下就可以发现，除了正四边形整数点不可能构成其他多边形，所以我们只需要找有多少个正四边形。注意这个题的四边形其实可以是斜着的，所以我们不能只枚举左下角。需要枚举至少两个点。我的方法是枚举其中两个点，这两个点会构成一个向量$(dx,dy)$，有一个可能的正方形是这样的:$(0,0),(dx,dy),(-dy,dx),(dx-dy,dx+dy).$我们去看是否这四个点都存在，如果存在记录答案，最后答案除以4，因为每个正方形的4条边都被计算了一次。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 205;int mov[3][2]=&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;1,1&#125;&#125;;bool has[210][210];vector&lt;pair&lt;int, int&gt; &gt; v;int main()&#123; int n; while (scanf("%d", &amp;n) != EOF) &#123; for (int i = 0; i &lt;= 209; i++) for (int j = 0; j &lt;= 209; j++) has[i][j] = 0; v.clear(); for (int i = 1; i &lt;= n; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); has[x + 100][y + 100] = true; v.push_back(make_pair(x, y)); &#125; ll cnt = 0; int sz=v.size(); for (int i=0;i&lt;sz;i++) &#123; int x=v[i].first,y=v[i].second; for(int j=0;j&lt;sz;j++)&#123; int xx=v[j].first,yy=v[j].second; if(j==i) continue; int dx=xx-x,dy=yy-y; int flag=1; int dxx=x-dy,dyy=y+dx; if(dxx&lt;-100 || dxx&gt;100 || dyy&lt;-100 || dyy&gt;100||!has[dxx+100][dyy+100])&#123; flag=0; &#125; dxx=x-dy+dx,dyy=y+dx+dy; if(dxx&lt;-100 || dxx&gt;100 || dyy&lt;-100 || dyy&gt;100||!has[dxx+100][dyy+100])&#123; flag=0; &#125; cnt+=flag; &#125; &#125; printf("%lld\n",cnt / 4); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
      <tags>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TrickGCD]]></title>
    <url>%2F2019%2F06%2F21%2FTrickGCD%2F</url>
    <content type="text"><![CDATA[题目链接题意输入$a$数组，询问有多少个$b$数组使得： 1 \leq b_{i} \leq a_{i}gcd(b_{l},b_{l+1},b_{l+2}...b_{r}) \geq 2, 1 \leq l \leq r \leq n.思路首先容易想到这题要求整个$b$数列的最大公约数大于1，简记其$gcd$为$gcd(b)$。不妨设$F(d)$表示$d|gcd(b)$的方案数，$f(d)$表示$gcd(b)=d$的方案数。 F(n)= \sum_{n|d}f(d)f(n) = \sum_{n|d} \mu(\frac{d}{n}) F(d)F(d)= \prod_{i=1}^{n} \left \lfloor \frac{a_{i}}{d} \right \rfloor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 1e5 + 5;int prime[10000];int tot;bool vis[N];ll miu[N];void pre(int n)&#123; tot = 0; miu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) prime[++tot] = i, miu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; miu[i * prime[j]] = 0; break; &#125; miu[i * prime[j]] = -miu[i]; &#125; &#125;&#125;ll cnt[N];int a[N];const ll mod = 1e9 + 7;ll f[N];ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; int n; pre(100000); int T; scanf("%d", &amp;T); for (int ks = 1; ks &lt;= T; ks++) &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt;= 100000; i++) cnt[i] = 0; int mnv = 0x3f3f3f3f, mxv = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); mnv = min(mnv, a[i]); mxv = max(mxv, a[i]); cnt[a[i]]++; &#125; if (mnv &lt;= 1) &#123; printf("Case #%d: %lld\n", ks, 0ll); continue; &#125; for (int i = 1; i &lt;= mxv; i++) cnt[i] = cnt[i] + cnt[i - 1]; ll ans = 0; int j; for (int i = 0; i &lt;= mxv; i++) f[i] = 0ll; for (int i = 2; i &lt;= mnv; i++) &#123; f[i] = 1ll; for (int l = i; l &lt;= mxv; l += i) &#123; //f[i] = f[i] * (cnt[min(l + i - 1, mxv)] - cnt[l - 1] + mod) % mod * (l / i) % mod; f[i] = f[i] * Pow(1ll * l / i, cnt[min(l + i - 1, mxv)] - cnt[l - 1]) % mod; &#125; //dbg(i, f[i]); /* for (int j = i; j &lt;= mxv; j++) &#123; f[i] = f[i] * Pow(j / i, cnt[j]) % mod; &#125; */ &#125; for (int i = 2; i &lt;= mnv; i++) &#123; for (int d = i; d &lt;= mxv; d += i) ans = (ans + f[d] * miu[d / i] % mod + mod) % mod; &#125; printf("Case #%d: %lld\n", ks, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Mobius inversion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Funny Function]]></title>
    <url>%2F2019%2F06%2F21%2FFunny-Function%2F</url>
    <content type="text"><![CDATA[题目链接题意F_{1,1}=F_{1,2}=1F_{1,i}=F_{1,i-1}+2F_{1,i-2}, i \geq 3F_{i,j}= \sum_{k=j}^{j+n-1} F_{i-1,k} (i \geq 2, j \geq 1)输入$n$和$m$，计算F_{m,1}.对$1000000007$取模。 思路首先很容易可以用特征根计算出F_{1,i}的通项公式。 F_{1,i}= \frac{1}{3} {2}^{i} - \frac{1}{3} {(-1)}^{i}然后无脑计算F_{i,j},容易发现其实他也是等比数列。 F_{i,j} = \sum_{k=j}^{j+n-1} F_{i-1,k}F_{2,j}= \sum_{k=j}^{j+n-1} \frac{1}{3} {2}^{k-1} - \sum_{k=j}^{j+n-1} \frac{1}{3} {(-1)}^{k-1}= (\frac{1}{3} {2}^{n}) {2}^{j} - \frac{1}{3} (1-{(-1)}^{n}) {(-1)}^{j}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const ll mod = 1e9 + 7;ll Pow(ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;template&lt;class T&gt;void read(T&amp; ret)&#123; ret = 0; char c; while ((c = getchar()) &gt; '9' || c &lt; '0'); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ret = ret * 10 + c - '0'; c = getchar(); &#125;&#125;int main()&#123; int T; read(T); while (T--) &#123; ll n, m; read(n); read(m); ll ans = 0; ll inv3 = Pow(3, mod - 2); ans = Pow(2, n % (mod - 1)) - 1; ans = (ans + mod) % mod; ans = Pow(ans, m - 1) % mod * inv3 % mod; ans = ans * 2 % mod; if (n % 2 == 1) &#123; ans = (ans + inv3 + mod) % mod; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Sequence]]></title>
    <url>%2F2019%2F06%2F21%2FMaximum-Sequence%2F</url>
    <content type="text"><![CDATA[题目链接队友直接过了，打扰了]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Is Derek lying?]]></title>
    <url>%2F2019%2F06%2F21%2FIs-Derek-lying%2F</url>
    <content type="text"><![CDATA[题目链接题意有$n$到题，有两个人，每个人都做了选择，并且分别得分为$x$, $y$，现在问这个分数是否是真实的。 思路这题解法肯定是去从二者答案相同数量和不同数量去考虑，设相同答案数量为$cnt$，如果分数真实，需要满足以下条件：分数的差异来自于答案的差异，所以分数只差一定小于等于不同答案数量，即$abs(x-y) \leq n-cnt.$两个人分数之和最多是两个人相同的全对，所以$x+y \leq n + cnt$ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#ifndef ONLINE_JUDGE#define dbg(x...) do&#123;cout &lt;&lt; "\033[33;1m" &lt;&lt; #x &lt;&lt; "-&gt;" ; err(x);&#125; while (0)void err()&#123;cout &lt;&lt; "\033[39;0m" &lt;&lt; endl;&#125;template&lt;template&lt;typename...&gt; class T, typename t, typename... A&gt;void err(T&lt;t&gt; a, A... x)&#123;for (auto v: a) cout &lt;&lt; v &lt;&lt; ' '; err(x...);&#125;template&lt;typename T, typename... A&gt;void err(T a, A... x)&#123;cout &lt;&lt; a &lt;&lt; ' '; err(x...);&#125;#else#define dbg(...)#endif#define inf 1ll &lt;&lt; 50const int N = 80005;char s1[N], s2[N];int main()&#123; int n; int x, y; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d", &amp;n, &amp;x, &amp;y); scanf("%s%s", s1, s2); int cnt = 0; for (int i = 0; i &lt; n; i++) if (s1[i] == s2[i]) cnt++; if (x + y - cnt &gt; n) &#123; puts("Lying"); continue; &#125; cnt = n - cnt; if (abs(x - y) &gt; cnt) puts("Lying"); else puts("Not lying"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第二场</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Limited Permutation]]></title>
    <url>%2F2019%2F06%2F21%2FLimited-Permutation%2F</url>
    <content type="text"><![CDATA[题目链接题意有$n$个元素的全排列的合法性定义为：有$n$个区间，对于第$i$个区间[l_{i},r_{i}]有l_{i} \leq i \leq r_{i},对于任意1 \leq L \leq i \leq R \leq n.当且仅当l_{i} \leq L \leq i \leq R \leq r_{i}时,P[i]=min(P[L],P[L+1],...,P[R])。现在给出序列和相应的区间，问多少区间是否合法？ 思路 我们可以先确定的是，这些区间一定是要么包含关系，要么交集为空，而且我们还知道，排列中最小数字的位置左端点一定是$1$，右端点一定是$n$。 我们把$n$个区间进行排序，优先左端点升序，然后右端点降序。这样第一个区间的位置$i$一定放最小的数字，$i$将数列分成两段，我们把$2$到$n$中$i-1$个数放到左边，剩下放到右边，相当于解决一个子问题，答案更新: ans = ans \times C_{n-1}^{i-1}. 123456789ll dfs(int l, int r) &#123; if (l &gt; r) return 1; if (a[rear].l != l || a[rear].r != r) return 0; node now = a[rear++]; ll ret = C(now.r - now.l, now.id - now.l) * dfs(now.l, now.id - 1) % mod; ret = (ret * dfs(now.id + 1, now.r)) % mod; return ret;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>partition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hints of sd0061]]></title>
    <url>%2F2019%2F06%2F21%2FHints-of-sd0061%2F</url>
    <content type="text"><![CDATA[题目链接题意 用给的随机函数可以得到数列$a$，$m$次查询，问第$b_{i}$小的数字。 思路 这道题要线性第$k$小，肯定是不能排序的。 一个思路是手写快排，然后将所有询问一起二分掉，比较卡的做法。 其实这是个套路题 使用STL &lt; algorithm &gt;中的 1nth_element(A, A + k, A + n) 可以在线性时间找到第k大，此题还需要一点小trick，可以先将询问排序，然后每次将排序范围缩小，可以减小枚举量。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>nth element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function]]></title>
    <url>%2F2019%2F06%2F21%2FFunction%2F</url>
    <content type="text"><![CDATA[题目链接题意 已知一个$n$的全排列$a$，和一个$m$的全排列$b$，现在问你有多少种不同的映射$f$使得满足以下条件： f(i)=b_{f(a_{i})}, 0 \leq i < n-1 答案对$1000000007$取模。 思路 假设对于我们现在已有的一个$f$映射，存在这样的关系： f(i)=b_{f(a_{i})}f(a_{i})=b_{f(a_{a_{i}})} ...f(i)=b_{b_{b_{...b_{t}}}}.则我们可以得到一个与$i$有关的闭合环，设$0$到$n-1$中有$w$个这样的环，则这些环之间是不会相互影响的，我们可以分别算出每个环有多少种合法的映射。 对于一个有$x$个数字的环，我们有多少种合法的映射呢？观察以下可以发现，只要确定其中一个位置映射的数字，就可以确定整个环中所有数字的映射，为了使环绕回$i$位置时与原来我们假设的数字不冲突。可以先在$b$数列中求出每个位置循环大小。 设为sz_{b}(i), a中环大小sz_{a}(i)，则a中包含位置i的环合法映射数量为\sum_{j=0}^{j < m} [sz_{b}(j)|sz_{a}(i)] 实际上我们只需要统计数量，所以不需要把每个位置是多少记录下来，只需要处理$a$时记录对应的$sz_{b}(j)$的数量即可。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Division Game]]></title>
    <url>%2F2019%2F06%2F20%2FDivision-Game%2F</url>
    <content type="text"><![CDATA[题目链接题意 用唯一表示法表示出n，输入m，k，表示有k堆石子，每堆有n个，现在拿石子。规则如下： 每次只能在下一堆中拿石子 每次拿走后剩余石子数量d，拿走前n，则必须有$d|n$ 拿到某一堆只剩一颗石子时游戏结束 询问在每一堆石子结束的方案数。 思路 设拿到第$i$堆，拿了$x$次结束的方案数为$f(x)$，则拿到第$i$堆，拿了$x-1$次没结束的方案数也为$f(i)$。 ans(i, x)= \prod_{j=1}^{j < i} {f(x+1)} \times \prod_{j=i+1}^{j \leq k} {f(x)}={f(x+1)}^{i-1} \times {f(x)}^{k-i+1}考虑$x$范围 记$ w= \sum e_{i} $ 当$i = 1$，$x \leq w$；当$i &gt; 1$，$x &lt; w$。 容斥计算$f(x)$ 考虑每个素因子，相当于将$e_{i}$个小球放入$x$个盒子中，不允许空。$g(x)$ 表示$x$盒子，允许空放盒子方案数。 g(x) = \prod_{i=1}^{m} {C_{e_{i}+x-1}^{x-1}} = \sum_{y=0}^{x} {(-1)}^{x-y} g(y) \frac{x!}{y!(x-y)!} 对这个式子NTT即可。]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Colorful Tree]]></title>
    <url>%2F2019%2F06%2F20%2FColorful-Tree%2F</url>
    <content type="text"><![CDATA[题目链接题意 一棵有n个节点的树，每个点有一个点权，问在这棵树上所有的$\frac{n(n-1)}{2}$条链颜色种类的和是多少。 思路 对于每种颜色计算其贡献，我们可以先算出每种颜色在多少条链中不出现，用总数减一下就可以得到在多少条链中出现，dfs序处理一下，遍历到一个点的时候我只考虑这个点与其儿子构成的连同块，在这些块里面都不出现这个颜色。 dfs1234567891011121314151617void dfs(int u, int f)&#123; sz[u] = 1; ll all = 0; for (auto &amp;v : G[u]) &#123; if (v == f) continue; ll last = sum[c[u]]; dfs(v, u); sz[u] += sz[v]; ll add = sum[c[u]] - last; ans += (sz[v] - add) * (sz[v] - add - 1) / 2; all += sz[v] - add; &#125; sum[c[u]] += all + 1;&#125; 1234567891011int main()&#123; for (int i = 1; i &lt;= n; i++) &#123; if (!hasc[i]) continue; ans += (n - sum[i]) * (n - sum[i] - 1) / 2ll; &#125; printf("%lld\n", (n - 1) * n / 2 * cnt - ans); return 0;&#125;]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Balala Power!]]></title>
    <url>%2F2019%2F06%2F19%2FBalala-Power%2F</url>
    <content type="text"><![CDATA[题目链接题意输入n个字符串，重新定义字母’a’~’z’的权值，使得给出的字符串在26进制下和最大 思路记录每个字母在每个位置出现的次数，按照贪心高为出现次数多的字母权值大排序（别暴力排，比赛时用个堆维护，一个数组记录最高位置）]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add More Zero]]></title>
    <url>%2F2019%2F06%2F19%2FAdd-More-Zero%2F</url>
    <content type="text"><![CDATA[题目链接题意 输入m，求最大k满足： 10^{k} \leq 2^{m} 其中$1 \leq m \leq 10^{5}$. 思路 因为当k与m均为整数时, 10^{k} \neq 2^{m}10^{k} \leq 2^{m}k \leq lg(2^{m}) = mlg(2) 直接计算答案]]></content>
      <categories>
        <category>acm</category>
        <category>做题记录</category>
        <category>2017杭电多校赛</category>
        <category>第一场</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2F2019%2F06%2F19%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[Congratulations for my first blog on github!!!Thanks to github and hexo. Then I probably test some function on this page. Cpp code1234567#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; printf("Hello, world.\n"); return 0;&#125; linkmore markdown rules fomularFibonacci comes like this: F(n)=F(n-1)+F(n-2)Euler function: n = \sum_{d|n} \phi (d)]]></content>
  </entry>
</search>
